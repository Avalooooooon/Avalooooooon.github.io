---
title: git笔记
updated: 2021-12-20 15:40:59
date: 2021-12-20 15:40:59
tags: [git]
categories:
---



查看完整教程：[Git-scm](https://git-scm.com/book/zh/v2/起步-关于版本控制)

## 查看版本/日志

```bash
# 项目所在目录git log：查看提交日志（查看版本号）
git log		
git reflog 		# 查看版本号  
```
不传入任何参数的默认情况下，git log 会按时间先后顺序列出所有的提交，最近的更新排在最上面。 
git log 有许多选项可以帮助你搜寻你所要找的提交，下面是最常用的几个：

+ `-p` 或 ``--patch` ：显示每次提交所引入的差异（按补丁的格式输出）
+ `-<n>` :仅显示最近的 `n` 条提交。
+ `--since` 和 `--until` ：按照时间作限制。
  ```bash
  # 列出最近两周的所有提交
  $ git log --since=2.weeks
  ```
  

该命令可用的格式十分丰富——可以是类似 `"2008-01-15"` 的具体的某一天，也可以是类似 `"2 years 1 day 3 minutes ago"` 的相对日期。
+ `--author` : 指定作者

+ `--grep` : 搜索提交说明中的关键字

+ `--stat`：显示每次提交的简略统计信息。`--stat` 选项在每次提交的下面列出所有被修改过的文件、有多少文件被修改了以及被修改过的文件的哪些行被移除或是添加了。 在每次提交的最后还有一个总结。

+ `--pretty`：使用不同于默认格式的方式展示提交历史。 这个选项有一些内建的子选项供你使用。 比如 `oneline` 会将每个提交放在一行显示，在浏览大量的提交时非常有用。

  > 当 `oneline` 或 `format` 与另一个 `log` 选项 `--graph` 结合使用时尤其有用。 这个选项添加了一些 ASCII 字符串来形象地展示你的分支、合并历史。

   另外还有 `short`，`full` 和 `fuller` 选项，它们展示信息的格式基本一致，但是详尽程度不一。

+ `format` ：可以定制记录的显示格式。 这样的输出对后期提取分析格外有用——因为你知道输出的格式不会随着 Git 的更新而发生改变：
  
  ```bash
  $ git log --pretty=format:"%h - %an, %ar : %s"
  ca82a6d - Scott Chacon, 6 years ago : changed the version number
  085bb3b - Scott Chacon, 6 years ago : removed unnecessary test
  a11bef0 - Scott Chacon, 6 years ago : first commit
  ```
  
  [`git log --pretty=format` 常用的选项](https://git-scm.com/book/zh/v2/ch00/pretty_format) 列出了 `format` 接受的常用格式占位符的写法及其代表的意义。

更详细的选项说明可以参考[`git log` 的常用选项](https://git-scm.com/book/zh/v2/ch00/log_options) 。

## 文件

### 文件状态

```bash
# 查看当前分支、分支同远程分支的比较、哪些文件处于什么状态
git status
# 开始跟踪一个文件/将一个文件放到暂存区、
git add 文件名  
```

> 未跟踪的文件意味着 Git 在之前的快照（提交）中没有这些文件；Git 不会自动将之纳入跟踪范围，除非你明明白白地告诉它“我需要跟踪该文件”。 这样的处理让你不必担心将生成的二进制文件或其它不想被跟踪的文件包含进来。  

`git add` 是个多功能命令：可以用它开始跟踪新文件，也可以用它把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。 将这个命令理解为“精确地将内容添加到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。 

> 注意！运行了 `git add` 之后又作了修订的文件，需要重新运行 `git add` 把最新版本重新暂存起来。

如果想缩短状态命令的输出：

```bash
git status -s 
git status --short
```

新添加的未跟踪文件前面有 `??` 标记，新添加到暂存区中的文件前面有 `A` 标记，修改过的文件前面有 `M` 标记。 输出中有两栏，左栏指明了暂存区的状态，右栏指明了工作区的状态。

示例：

```bash
$ git status -s
M README
MM Rakefile
A  lib/git.rb
M  lib/simplegit.rb
?? LICENSE.txt
```

 `README` 文件在工作区已修改但尚未暂存，而 `lib/simplegit.rb` 文件已修改且已暂存。 `Rakefile`文件已修，暂存后又作了修改，因此该文件的修改中既有已暂存的部分，又有未暂存的部分。

### 文件的忽略

总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下可以创建一个名为 `.gitignore` 的文件，列出要忽略的文件的模式。 

```bash
$ cat .gitignore
*.[oa]
*~
```

第一行告诉 Git 忽略所有以 `.o` 或 `.a` 结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的。 第二行告诉 Git 忽略所有名字以波浪符（~）结尾的文件，许多文本编辑软件（比如 Emacs）都用这样的文件名保存副本。 此外，你可能还需要忽略 log，tmp 或者 pid 目录，以及自动生成的文档等等。 

> 要养成一开始就为你的新仓库设置好 .gitignore 文件的习惯，以免将来误提交这类无用的文件。

文件 `.gitignore` 的格式规范如下：

- 所有空行或者以 `#` 开头的行都会被 Git 忽略。
- 可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。
- 匹配模式可以以（`/`）开头防止递归。
- 匹配模式可以以（`/`）结尾指定目录。
- 要忽略指定模式以外的文件或目录，可以在模式前加上叹号（`!`）取反。

所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。 星号（`*`）匹配零个或多个任意字符；`[abc]`匹配任何一个列在方括号中的字符 （这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）； 问号（`?`）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符， 表示所有在这两个字符范围内的都可以匹配（比如 `[0-9]` 表示匹配所有 0 到 9 的数字）。 使用两个星号（`**`）表示匹配任意中间目录，比如 `a/**/z` 可以匹配 `a/z` 、 `a/b/z` 或 `a/b/c/z` 等。

再看一个 `.gitignore` 文件的例子：

```bash
# 忽略所有的 .a 文件
*.a
# 但跟踪所有的 lib.a，即便你在前面忽略了 .a 文件
!lib.a
# 只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO
/TODO
# 忽略任何目录下名为 build 的文件夹
build/
# 忽略 doc/notes.txt，但不忽略 doc/server/arch.txt
doc/*.txt
# 忽略 doc/ 目录及其所有子目录下的 .pdf 文件
doc/**/*.pdf
```

## 仓库

### 将尚未进行版本控制的本地目录转换为 Git 仓库

先cd到该项目目录，然后

```bash
git init
```
该命令将创建一个名为 .git 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。 但是，在这个时候，我们仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪。

> 请记住，工作目录下的每一个文件都不外乎这两种状态：**已跟踪** 或 **未跟踪**。 已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后， 它们的状态可能是未修改，已修改或已放入暂存区。简而言之，已跟踪的文件就是 Git 已经知道的文件。其它所有文件都属于未跟踪文件。

> 编辑过某些文件之后，由于自上次提交后你对它们做了修改，Git 将它们标记为已修改文件。 在工作时可以选择性地将这些修改过的文件放入暂存区，然后提交所有已暂存的修改，如此反复。  

![文件的状态变化周期](lifecycle.png)

如果在一个已存在文件的文件夹（而非空文件夹）中进行版本控制，你应该开始追踪这些文件并进行初始提交。 可以通过 git add 命令来指定所需的文件来进行追踪，然后执行 git commit ：

```bash
git add *.c
git add LICENSE
git commit -m 'initial project version'
```
### 从其它服务器克隆一个已存在的 Git 仓库

Git 克隆的是该 Git 仓库服务器上的几乎所有数据，而不是仅仅复制完成你的工作所需要文件。 当你执行 git clone 命令的时候，默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来。
克隆仓库的命令是 git clone <url> 。 比如，要克隆 Git 的链接库 libgit2，可以用下面的命令：

```bash
git clone https://github.com/libgit2/libgit2
```
这会在当前目录下创建一个名为 “libgit2” 的目录，并在这个目录下初始化一个 .git 文件夹， 从远程仓库拉取下所有数据放入 .git 文件夹，然后从中读取最新版本的文件的拷贝。
```bash
git clone https://github.com/libgit2/libgit2 mylibgit
```

这会执行与上一条命令相同的操作，但目标目录名变为了 `mylibgit`。也就是在克隆远程仓库的时候，自定义了本地仓库的名字。  

### 远程仓库

```bash
# 查看你已经配置的远程仓库服务器
git remote
# 指定选项 -v：显示需要读写远程仓库使用的Git保存的简写与其对应的URL
git remote -v
# 添加远程仓库，同时指定一个方便使用的简写<shortname>
git remote add <shortname> <url>
# 查看某个远程仓库。同样会列出远程仓库的 URL 与跟踪分支的信息。
git remote show <remote>

# 修改一个远程仓库的简写名。这同样也会修改你所有远程跟踪的分支名字。
git remote rename

# 移除一个远程仓库
git remote remove  # 或git remote rm。一旦你使用这种方式删除了一个远程仓库，那么所有和这个远程仓库相关的远程跟踪分支以及配置信息也会一起被删除。
```

> origin ——这是 Git 给你克隆的仓库服务器的默认名字。如果使用 `clone` 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。 

## 拉取、抓取与推送

### 抓取——fetch

```bash
# 从远程仓库中获得数据
git fetch <remote>
```
这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。

> 必须注意 `git fetch` 命令只会将数据下载到你的本地仓库——它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。

### 拉取——pull

如果你的当前分支设置了==跟踪远程分支==，那么可以用 `git pull`命令来自动抓取后合并该远程分支到当前分支。 这或许是个更加简单舒服的工作流程。默认情况下，`git clone` 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 `master` 分支（或其它名字的默认分支）。 运行 `git pull` 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。

### 推送——push

```bash
git push <remote> <branch>
```

> 只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 
>
> 当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先抓取他们的工作并将其合并进你的工作后才能推送。

此外，如果直接使用```git push origin xxx```,“error: 源引用表达式xxx没有匹配”的问题会在关联的代码库远程分支名称与本地（当前）分支的名称不同时出现。如果不相同，就要用```git push origin head:xxx```，或者```git push origin <当前的本地分支名>:xxx```提交代码。
## 分支

### 概述

```bash
# 查看所有分支及当前所在分支【* 表示当前】
git branch
# 查看每一个分支的最后一次提交
git branch -v

# 查看哪些分支已经合并到当前分支。 在这个列表中分支名字前没有 * 号的分支通常可以使用 git branch -d 删除掉，因为已经将它们的工作整合到了另一个分支，所以不会失去任何东西。
git branch --merged
# 查看所有包含未合并工作的分支。因为它包含了还未合并的工作，尝试使用 git branch -d 命令删除它时会失败。可以使用 -D 选项强制删除它。
git branch --no-merged
# 例如，尚未合并到 master 分支的有哪些？
git branch --no-merged master
```
Git怎么知道当前在哪一个分支上呢？ 很简单，它有一个名为 HEAD 的特殊指针指向当前所在的本地分支（译注：将 HEAD 想象为当前分支的别名）。HEAD 分支随着提交操作自动向前移动。

```bash
# 创建一个新的分支。这会在当前所在的提交对象上创建一个指针。
# git branch 命令仅仅创建 一个新分支，并不会自动切换到新分支中去。
git branch xxx 

# 创建一个新分支后立即切换过去
git checkout -b <newbranchname>
# 从当前分支切换到某个分支。HEAD指向切换之后的分支。
git checkout xxx 

# 查看各个分支当前所指的提交对象
git log --oneline --decorate
# 查看提交历史、各个分支的指向以及项目的分支分叉情况
git log --oneline --decorate --graph --all
```
> 分支切换会改变你工作目录中的文件!!
> git 会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。如果 Git 不能干净利落地完成这个任务，它将禁止切换分支。
>
> 要留意你的工作目录和暂存区里那些还没有被提交的修改。最好的方法是，在你切换分支之前，保持好一个干净的状态。

```bash
# 删除某个分支【慎重操作】 注意当前不能在iii分支上,跳出之后,再删除
git branch -d iii
```

### 合并分支——fast-forward

当你试图合并两个分支时， 如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候， 只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”。

### 合并分支——merge

当两个将要合并的分支各自有不同的父提交时发生。比如下面的例子，要合并master和iss53分支：
![](merge.png)
你的开发历史从一个更早的地方开始分叉开来（diverged）。 因为，`master` 分支所在提交并不是 `iss53` 分支所在提交的直接祖先，Git 不得不做一些额外的工作。 出现这种情况的时候，Git 会使用两个分支的末端所指的快照（`C4` 和 `C5`）以及这两个分支的公共祖先（`C2`)，做一个简单的三方合并。和之前将分支指针向前推进所不同的是，Git 将此次三方合并的结果做了一个新的快照并且自动创建一个**新的提交**指向它。 
![](merge2.png)

### 合并分支——rebase

`rebase`（变基） 命令将提交到某一分支上的所有修改都移至另一分支上。
考虑之前提到的merge。开发任务分叉到两个不同分支，又各自提交了更新：
![](rebase1.png)
Merge会把两个分支的最新快照（`C3` 和 `C4`）以及二者最近的共同祖先（`C2`）进行三方合并，合并的结果是生成一个新的快照（并提交)：
![](rebase2.png)
其实，还有一种方法：你可以提取在 `C4` 中引入的补丁和修改，然后在 `C3` 的基础上应用一次。 在这个例子中，你可以检出 `experiment` 分支，然后将它变基到 `master` 分支上：

```bash
git checkout experiment
git rebase master
```

这种操作就叫做 **变基（rebase)**。它的原理是首先找到这两个分支（即当前分支 `experiment`、变基操作的目标基底分支 `master`） 的最近共同祖先 `C2`，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件， 然后将当前分支指向目标基底 `C3`, 最后以此将之前另存为临时文件的修改依序应用。 （译注：写明了 commit id，以便理解，下同)
![将 `C4` 中的修改变基到 `C3` 上](rebase3.png)
现在回到 `master` 分支，进行一次快进合并:

```bash
git checkout master
git merge experiment
```

![`master` 分支的快进合并](rebase4.png)
此时，`C4'` 指向的快照就和merge中 `C5` 指向的快照一模一样了。 这两种整合方法的最终结果没有任何区别，但是变基使得提交历史更加整洁。 

> 你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的， 但它们看上去就像是串行的一样，提交历史是一条直线没有分叉。
>
> 请注意，无论是通过变基，还是通过三方合并，整合的最终结果所指向的快照始终是一样的，只不过提交历史不同罢了。 变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。

> <span style="color:red;font-size:21px">如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基。</span>
>
> 总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史， 从不对已推送至别处的提交执行变基操作，



### 合并分支——冲突

如果在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。Git 会暂停下来，等待你去解决合并产生的冲突。 你可以在合并冲突后的任意时刻使用 `git status` 命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件。
任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。 Git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。 

```bash
# 启动一个合适的可视化合并工具，并带领你一步一步解决这些冲突
git mergetool
```

等你退出合并工具之后，Git 会询问刚才的合并是否成功。 如果回答“是”，Git 会暂存那些文件以表明冲突已解决。可以再次运行 `git status` 来确认所有的合并冲突都已被解决。

### 合并分支——提交

```bash
git commit
```



### 关于分支的几个常见场景：

1.在新的分支上面常规开发【一般是dev分支】

```bash
# 在确保当前分支是上一步git checkout过来的即可【不放心的话可以git branch 确认下】
git add .
git commit -m "yyyy"
git pull       #注意在多人协作push之前,一定先pull下,养成良好的习惯,避免和被人提交的代码冲突,硬合并而照成代码事故】
git push      # 【再上一步，pull之后如无冲突，即可提交代码】
git status    #【查看当前工作空间状态】
```

2.将次分支和并到主分支上【一般是dev分支合并到主分支master上】【dev分支开发完毕,合并到master分支,并推送上线】

```bash
git checkout dev     # 切到dev次分支】
git pull             #【获取dev分支变化,合并冲突,使本地dev次分支最新】
git checkout master  #【先切到主分支master上】
git merge dev        #【一般是git merge dev,将dev开发完的合并到master上】
git push -u origin master     #【提交master分支到线上master】
```

3.将主分支和并到次分支上【一般是主分支master合并到dev分支上】【master分支有变动，需要更新开发分支dev上的代码】

```bash
git checkout master  #【切到主分支】
git pull             #【获取主分支变化,合并冲突,使本地主分支最新】
git checkout dev     #【先切到次分支dev上】
git merge master     #【一般是git merge master,将master开发完的合并到dev上】
git push -u origin dev       #【提交dev分支到线上dev】
```

## 版本回退

### 针对部分文件的撤销操作

1.有时提交完了才发现漏掉了几个文件没有添加，或提交信息写错了。 可以运行带有 `--amend` 选项的提交命令来重新提交：

```console
$ git commit --amend
```

这个命令会将暂存区中的文件提交。 如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令）， 那么快照会保持不变，而你所修改的只是提交信息。文本编辑器启动后，可以看到之前的提交信息。 编辑后保存会覆盖原来的提交信息，也即用一个**新的提交**替换旧的提交。

2.取消暂存的文件

```bash
git reset HEAD 要取消暂存的文件名
```

> `git reset` 确实是个危险的命令，如果加上了 `--hard` 选项则更是如此。 然而在上述场景中，工作目录中的文件尚未修改，因此相对安全一些。

3.撤消对文件的修改

将它还原成上次提交时的样子（或者刚克隆完的样子，或者刚把它放入工作目录时的样子）:

```bash
git checkout -- <file>
```

> 请务必记得 `git checkout -- <file>` 是一个危险的命令。 你对那个文件在本地的任何修改都会消失——Git 会用最近提交的版本覆盖掉它。 除非你确实清楚不想要对那个文件的本地修改了，否则请不要使用这个命令。

### 针对整个版本的回退操作

假设A 和 B 是正常提交， C 和 D 是错误提交，此时HEAD 指针指向 D 提交。现在想把 C 和 D 回退掉。我们只需将 HEAD 指针移动到 B 提交（idCodeB），就可以达到目的。
此时回滚目标B的commitid为idCode1，操作如下：

```bash
# 如果保留修改的撤销->只删掉提交记录：在项目所在目录执行下列操作
git reset HEAD~ # 仓库回滚到上一个版本
git reset XXX  # 仓库回滚到指定版本
git reset --soft idCode1 # 仓库回滚到指定版本

# 如果把修改记录也干掉：在项目所在目录执行下列操作
git reset --hard idCodeB
git reset --hard HEAD^

# 如果是提交到远程仓库上，则在远程仓库上同样执行一次相同的命令
```

然而，由于即使是在本地执行了git reset --hard (B提交的版本号）使得HEAD 指针移动到 B 提交下，但远程仓库的 HEAD 指针依然不变（还在D提交上），故只能使用 -f 选项将提交强制推到远程仓库：```git push -f```。它会使 HEAD 指针往回移动，从而会失去之后的提交信息。    

而git resert则可以既回退代码，又保存错误的提交。(reset和revert的区别详见<span>[这篇博客](https://blog.csdn.net/zzti_erlie/article/details/87189530)</span>，主要是<span style="color:red"> revert是生成一次新的commit冲抵原来的commit， reset直接删除某些commit的内容</span>)

```bash
# 注意有多个提交需要回退的话，要由新到旧进行 revert，即先D后C。会生成两个新有提交：D’ 和 C’，按A B C D D’ C’的先后顺序依次排列在分支上
git revert idCodeD
git revert idCodeC
git revert OLDER_COMMIT^…NEWER_COMMIT # 多个错误提交时批量回退

# 回滚最新一次的提交记录：
git revert HEAD
# 回滚前一次的提交记录：
git revert HEAD^
# 对历史上的commit回滚
git revert 

# 确认生成的新commit编译成功，也没有文件冲突，可以push到服务器，完成回滚。
```

