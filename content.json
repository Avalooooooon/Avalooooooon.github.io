{"meta":{"title":"一之碎片","subtitle":"「宠辱不惊 相由心生」","description":"前端 杂谈","author":"一之碎片","url":"https://avalooooooon.github.io","root":"/"},"pages":[],"posts":[{"title":"JS笔记","slug":"JS笔记","date":"2022-01-17T11:45:34.000Z","updated":"2022-01-17T11:45:34.000Z","comments":true,"path":"2022/01/17/JS笔记/","link":"","permalink":"https://avalooooooon.github.io/2022/01/17/JS%E7%AC%94%E8%AE%B0/","excerpt":"","text":"12345678console.time(&quot;计时器的名字&quot;);console.timeEnd(&quot;计时器的名字&quot;); console.log();document.write(); // 实际上是通过超文本标记语言输出。比如想换行，document.write(1+&quot;\\n&quot;)不行，document.write(1+&quot;&lt;br /&gt;&quot;)才行。var year =prompt(&quot;请输入年份&quot;); //prompt()：弹出一个带文本框的提示框,需要字符串做参数，为提示文字。注意返回类型为String。Math.sqrt(i); //开方 数据类型基本数据类型：String Number Boolean Null Undefined引用数据类型：Object 它们最主要的区别：基本数据类型在栈中保存的是值，引用数据类型在栈中保存的是地址。 使用typeof a查看a的数据类型。转义字符：\\。\\n :换行 \\t:制表符 \\\\:斜杠“\\”。 在字符串中使用转义字符输出Unicode编码：\\u四位编码，如console.log(&quot;\\u2620&quot;)。注意这里的四位编码是16进制。在网页中使用Unicode编码：&amp;#十进制编码，如&lt;p&gt;&amp;#9760;&lt;/p&gt;。 String：双引号和单引号都行，但不要混着用；可以使用\\作为转义字符 引号需要成对出现，不能嵌套！ Number：包括整数和浮点数。 NaN：特殊的数字，表示Not a Number Number.MAX_VALUE：最大数。比它大就是Infinity，都是字面量。 Number.MIN_VALUE：最小正数。 运算：整数基本保证精确。浮点元素运算可能不精确。 千万别用JS进行对精确度要求高的运算！ Boolean Null：专门表示一个为空的对象。使用typeof检查时返回object。 Undefined：声明了但没赋值的变量。使用typeof检查时返回undefined。 强制类型转换类型转换主要指将其他数据类型转换为String Number Boolean。 转换为String： 调用被转换数据类型的toString()方法：a = a.toString()。null和undefined没有toString()方法。该方法不会影响原变量，它会将转换的结果返回。 调用String()函数：a = String(a)。该方法不会影响原变量，它会将转换的结果返回。 转换为Number： 调用Number()函数：a = Number(a)。字符串类型有非数字的转为NaN，空串或者全是空格转为0。Null类型结果为0。Undefined类型、object类型结果为NaN。 局限：对于a = 123px，想要进行a + 10这类情景不友好。 一种专门解决字符串的方法***有效*** 整数拿出。可以用来取整。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485 ```parseFloat()```函数：它可以将一个字符串中的 ***有效*** 小数拿出。 如果是非String，会转换成string再处理。 &gt; 可以在parseInt()中传递一个第二个参数指定进制：```parseInt(a,10)``` 3. 转换为Boolean：```Boolean()```函数 + 数字：除了0和NaN都是```true``` + 字符串：除了空串都是```true``` + null和undefined都是```false``` + 可以对任意数据类型取两次反转换为Boolean:```a = !!a```。### 引用数据类型+ 栈内存和堆内存 + 栈内存：JS中的&lt;span style=&quot;color:red&quot;&gt;变量都保存到栈内存&lt;/span&gt;，基本数据类型的&lt;span style=&quot;color:red&quot;&gt;值&lt;/span&gt;直接在栈内存中存储。值与值之间是独立存在，修改一个变量不会影响其他变量。 + 对象保存到堆内存中，每创建一个新的对象就会在堆内存中创建一个新的空间。这种情况下&lt;span style=&quot;color:red&quot;&gt;变量保存的是对象的内存地址（对象的引用）。&lt;/span&gt; 如果两个变量保存的是同一个对象引用，则当一个通过一个变量修改&lt;span style=&quot;color:red&quot;&gt;属性&lt;/span&gt;时，另一个也会受到影响。如果直接修改变量的&lt;span style=&quot;color:red&quot;&gt;值&lt;/span&gt;，比如```obj2 = null```，那么obj不受影响。 当比较两个基本数据类型的值时，就是比较值；但两个引用数据类型比较的是对象的内存地址。## 运算任何数和NaN运算的结果都是```NaN```。除拼串，对任何非Number的值会转换成Number。### 算术运算+ +：对两个字符串进行相加，是拼串。```var a = &quot;123&quot;+&quot;456&quot;```，结果为```123456```。事实上，***任何值和字符串相加都会转换成字符串并进行拼串操作***。 &gt; 隐式类型转换：可以利用这一特点将一个任意数据类型转换为```String```，只需要任意的数据类型 + 一个&quot;&quot;即可：```a = a + &#x27;&#x27;```。+ \\- \\* /：除了“ + ”的其他运算符号（- * /），在算式中出现的变量都会转化成数字再计算。 &gt; 隐式类型转换：可以利用这一特点将一个任意数据类型转换为```Number```，只需要任意的数据类型 ```-1```;```*1```;```/1```即可。原理和```Number()```一样，使用更简单。+ 一元运算符：全换为Number类型再运算。```+ -```, 正号&quot; + &quot;不会对数字产生任何影响, 负号“-”可以对数字进行符号取反。 &gt; 隐式类型转换：可以利用这一特点将一个任意数据类型转换为```Number```，只需要任意的数据类型 ```a = +a```即可。如```a = 1 + +a + 2```，此时a = 6。### 逻辑运算JS中的&amp;&amp; 和 || 是短路与/或而不是逻辑与/或。对于非布尔值：会先将其转换为布尔值再运算，并且 ***返回原值*** 。+ &amp;&amp;：两值运算，若第一个为true，返回第二个值；第一个为false，直接返回第一个值。+ ||：两值运算，若第一个为true，直接返回第一个值；第一个为false，返回第二个值。+ == 和 !=：（不）相等运算。若两个值类型不同，会转化成相同类型再比较，大部分情况是转化为数字。 + Undefined衍生自null，所以这两个值作相等判断时会返回true + NaN不和包括它本身任何值相等。可以通过```isNaN()```函数判断一个值是否为NaN。+ === 和 !==：（不）全等运算。和相等的区别在于它不会做类型转换。若类型不同直接返回。###关系运算```&gt; &gt;= &lt; &lt;= =```。会转化成数字再比较。任何值和NaN比较都是false。&gt; 若比较符号的两侧都是字符串，不会转换为数字进行比较，而会分别比较字符串中的 ***Unicode编码***，一位一位比较，两位一样就比下一位。&gt; 如果比较两个字符类型的数字时，可能得到不可预期的结果。所以比较两个字符串类型的数字时，***一定要转型***。&gt; 可以利用该特性对英文排序。### 条件运算```条件表达式？语句1:语句2```。先执行条件运算符，判断执行语句1还是2，并返回执行结果。若条件表达式的结果是非布尔值，会将其转化为布尔值再运算。## 函数和代码块一个```&#123;&#125;```中的内容称为一个代码块，一个代码块中的内容要么都执行，要么都不执行。&gt; JS中的代码块 ***只有分组作用***！块中的内容块外也完全可见，并不隔离。### 条件判断/条件分支/switch/for语句```javascript// if语句if(条件表达式)&#123; 语句... &#125;else if&#123; 语句... &#125;else&#123; 语句... &#125;// switch语句。依次将case后的表达式和switch后的条件表达式进行全等比较。switch(条件表达式)&#123; case 表达式； 语句... break; default: 语句... break;&#125;// while。判断一次执行一次。可以使用break终止循环。while(条件表达式)&#123; 语句... &#125;// do...while。执行一次判断一次。也就是while先判断再执行，do...while先执行再判断。do...while可以保证循环体至少执行一次。do&#123; 语句... &#125;while(条件表达式)// for语句。for(初始化表达式；条件表达式；更新表达式)&#123; &#125; break和continue可以为循环语句加上一个label标识当前循环。比如创建一个label为outer的循环：outer:循环语句 break outer：结束循环。立即终止label=outer的循环。默认终止本 层 循环。 只能对循环和switch语句使用! continue outer：跳过当 次 循环，继续下一次循环。其它和break一样。 对象 内建对象：由ES标准中定义的对象。在任何ES的实现中均可使用。如Math String Number Boolean Function Object 宿主对象：由JS的运行环境提供的对象。主要指由浏览器创造的对象。如BOM（浏览器对象模型） DOM（文档对象模型）。console、document也属于这一类。 自建对象：由开发人员自己创建。 属性名和属性值是名值对。名与值之间使用 : 连接，多个名值对之间使用 , 隔开。对象中的最后一个属性之后不要写 , 。 读取对象中没有的属性，不会报错而是会返回undefined。如果使用了特殊的属性名，需要用对象[&quot;属性名&quot;] = 属性值的方式操作。 使用[]操作对象更加灵活。在[]中可以直接传递一个变量，这样变量值是多少，就会读取变量值那个属性： n 1234```javascript 删除属性：delete 对象.属性名。","categories":[],"tags":[]},{"title":"JavaScript笔记","slug":"JavaScript笔记","date":"2022-01-09T13:42:15.000Z","updated":"2022-01-09T13:42:15.000Z","comments":true,"path":"2022/01/09/JavaScript笔记/","link":"","permalink":"https://avalooooooon.github.io/2022/01/09/JavaScript%E7%AC%94%E8%AE%B0/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"HTML/CSS笔记","slug":"HTML-CSS笔记","date":"2022-01-09T13:41:50.000Z","updated":"2022-01-09T13:41:50.000Z","comments":true,"path":"2022/01/09/HTML-CSS笔记/","link":"","permalink":"https://avalooooooon.github.io/2022/01/09/HTML-CSS%E7%AC%94%E8%AE%B0/","excerpt":"","text":"HTML222 w3school的标签文档：tagsMDN的标签文档: tags Vscode安装的扩展：Live Server； 在浏览器中，检查元素的elements窗口显示的是代码在内存中的结构 HTML基本结构 vs code中新建.html文件，输入一个感叹号后直接tab可一键生成一个最简单的HTML模版。 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang = &quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt; &lt;/title&gt; &lt;style&gt; /* css中的注释 */ nav,article,aside&#123; float:left; &#125; ul&#123; margin:0; list-style:none; &#125; &lt;/style&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./css/reset.css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;header&gt; &lt;span&gt;&lt;/span&gt; &lt;/header&gt; &lt;main&gt; &lt;nav&gt;&lt;/nav&gt; &lt;article&gt;&lt;/article&gt; &lt;aside&gt;&lt;/aside&gt; &lt;/main&gt; &lt;footer&gt; &lt;span&gt;&lt;/span&gt; &lt;/footer&gt; &lt;ul&gt; &lt;li&gt; &lt;a href=&quot;javascript:;&quot;&gt; &lt;/a&gt; &lt;li&gt; &lt;li&gt; &lt;li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; &lt;DOCTYPE&gt;:文档声明，用来告诉浏览器当前网页的版本（语法规范）。就是html5的文档声明。 &lt;html&gt;: html的根标签，除了文档声明，所有内容都要写在根元素内；lang = “en”指定网页语言为英语，会触发浏览器的翻译功能，设置为zh则不会触发翻译 &lt;head&gt;: 给搜索引擎看帮助其解析网页，其中的内容不会出现在网页中 &lt;meta&gt;: 用来设置网页的元数据（与生俱来的、不会变的、底层的数据），也是给搜索引擎看的；可以通过该标签设置网页字符集charset(utf-8)；name；keywords是网站关键字，给搜索引擎分类网站的；description，介绍网站，会显示在搜索引擎搜索的结果中；title，作为搜索结果超链接中的文字显示。 &lt;title&gt;: 网页标题，在标题栏出现 &lt;body&gt;: 需要展示的所有内容都在其中 &lt;div&gt;: 没有语义，表示一个区块，是主要的布局元素 &lt;span&gt;: 没有语义，表示一个行内元素，是主要的布局元素 HTML属性属性是一个 名值对（x=y，即color=”red”），属性值应该使用引号引起来，可以是单引号也可以是双引号，但要一致。属性用来设置标签中的内容如何显示， HTML实体（转义）如需要在网页中书写特殊符号（多个连续空格、内容两侧的大于号和小于号），需要使用HTML中的实体（转义字符）。语法：&amp;实体的名字;。如，空格：&amp;nbsp;，多个连续空格可以写成&amp;nbsp;&amp;nbsp;&amp;nbsp;，大于号：&amp;gt;，小于号：&amp;lt; 在w3school:html实体中查询更多。 CSS层叠样式表。声明块中的声明是名值对，名和值用冒号连接。如color:red。注意这里CSS中的名值对用冒号链接；html中的属性值用的则是等号，如color=red。 样式的继承：为一个元素设置样式的同时也会应用到它的后代元素上。但背景相关的、布局相关的等一些样式不会被继承。 内联（行内）样式： 开发时不要使用内联样式！ 内部样式表：将样式全部写到&lt;head&gt;内的&lt;style&gt;标签里。 外部样式表：将样式写到外部的xxx.css文件中，再通过&lt;link&gt;标签引入。 浏览器的默认样式1234*&#123; margin:0; padding:0;&#125; 或者：使用重置样式表：style.css直接全部去除了浏览器的默认样式，normalize.css对不同浏览器的默认样式进行了统一。 长度和颜色单位 长度 像素（px）：根据屏幕不同而不同，像素越小的屏幕越清晰。同样的200px在不同设备下显示效果不同。 百分比：是相对其父属性而言。可以使子元素跟随父元素的改变而改变。 em：相对于当前元素（自身）的font- size。1em=1font-size。一般浏览器默认的字体大小都是16px，所以10em就是160px。会根据字体大小的改变而改变。 rem：相对于根元素（&lt;html&gt;标签）的font- size。 颜色 RGB值：rgb(红色,绿色,蓝色) RGBA值：rgba(红色,绿色,蓝色,.5)，第四个是透明度：1为完全不透，0为完全透明，.5为半透明 16进制值：#FFFFFF。两两重复可以简写。 HSL值：（同理有HSLA，色相：0～360+饱和度：颜色浓度0%～100%+亮度：0%～100%+透明度） 选择器 样式冲突：冲突时由选择器的权重（优先级）决定。比较时要将所有选择器的优先级相加计算。但选择器的累加不会超过其最大的数量级，即类选择器最高也不会超过id选择器的优先级。并集（分组）选择器单独计算。 「选择器越具体，优先级越高」：内联样式 1000 &gt; id选择器 100&gt; 类和伪类选择器 10&gt; 元素选择器 1&gt; 通配选择器 0&gt; 继承的样式 没有优先级；在样式最后加!important直接升为最高优先级。若优先级计算后相等，优先使用靠下的样式。 元素选择器：根据标签名选中指定的元素。语法：标签名&#123;&#125;，如h1&#123;&#125;。 id选择器：根据id选中 一个 元素。语法：#id属性值&#123;&#125;。 类选择器：根据类名选中 一组 元素。语法：.class属性值&#123;&#125;。 一个标签可以有多个class，class中间用空格分开。如&lt;p class=&quot;cla1 cla2&quot;&gt;。 通配选择器：选中页面所有元素。语法：*&#123;&#125;。 复合选择器 交集选择器：选择器1选择器2选择器n&#123;&#125;，如div.cla1&#123;&#125;。 如含有元素选择器，必须使用元素选择器开头。 并集选择器（分组选择器）:选择器1,选择器2,...,选择器n&#123;&#125;。 关系选择器 父元素（ 直接 包含子元素）、子元素（ 直接 被父元素包含）；祖先元素（直接或间接包含后代元素）、后代元素；兄弟元素 子元素选择器：父元素 &gt; 子元素&#123;&#125;。 后代元素选择器：祖先 后代&#123;&#125; 兄弟元素选择器： 1. 选择 下一个 兄弟，前一个 + 下一个&#123;&#125;。 2. 选择 下面所有 兄弟，前一个 ～ 下一个&#123;&#125;。 属性选择器 选择含有指定属性的元素：[属性名] 选择含有指定属性和属性值的元素：[属性名=属性值] 选择属性值以指定值开头的元素：[属性名^=指定值] 选择属性值以指定值结尾的元素：[属性名$=指定值] 选择属性值中含有指定值的元素：[属性名*=指定值] 伪类选择器伪类，一般使用:开头，是一种特殊的类，是不存在的类，用于描述一个元素的特殊 状态 。如第一个子元素、被点击的元素、鼠标移入的元素… 排序伪类语法：:first-child，第一个子元素；:nthchild()，选中第n个子元素，具体n值写在括号内； :nthchild()，括号内的特殊值括号内写n则为全选，2n或even为选中偶数位元素，2n+1或odd为选中奇数位元素； 以上的伪类都是根据所有的子元素进行的排序！想要在同类型元素中进行排序，需要使用形如:first-of-type的伪类，用法相似。 否定伪类如:not(): 将符合条件的元素从选择器中去除。eg:.cla1 li:not(:last-child)。 超链接伪类没访问过的链接：可用:link访问过的链接：:visited。由于隐私原因，只能修改链接颜色鼠标状态：:hover为鼠标移入的状态。 :active为鼠标点击的状态。 事实上，“ :link ” 可以表示一切正常的链接。 伪元素选择器伪元素，一般使用::开头，是一种特殊的元素，是不存在的元素。类似伪类。 如::first-letter。默认是行内元素！ ::before、::after：必须结合content属性使用。 content中的内容是通过css添加的，是不能选中的！ 示例：1234div::before&#123; content:&#x27;abc&#x27;; color:red;&#125; 盒模型 计算盒子整体 可见 大小时需要把内容区content、内边框padding、边框border都计算在内！ 内容区：content width和height设置的是内容区（content）的大小。 内边距：padding， 影响盒大小；背景颜色会延伸到内边距（默认时）。 边框：border。需要至少设置3个样式——宽度（border-width）、颜色（border- color）、样式（border-style，设置为none则无边框）。 简写属性：border: solid 10px red，无顺序要求。 关于border-width、border- color和border-style1.都可以省略（有默认值）；都有```border-xxx-width/color/style```的形式 2.四个值：上，右，下，左；三个值：上，左右，下；两个值：上下，左右 外边框：margin，不影响盒子可见框大小，但影响盒子的实际大小和位置。 注意，margin-top和margin-left移动自己，margin-bottom挤别人，margin-right经常没用。可以设置为负值。 轮廓：outline，用来设置元素的轮廓线，用法和border一摸一样。唯一和border不一样的点就是轮廓不会影响可见框的大小。 阴影：box-shadow，用来设置元素的阴影效果，不会影响页面布局。起始位置和元素本身的位置完全重合。 box-shadow: 2px 5px 10px rgba(0,0,0,.3) 第一个值：水平偏移，正值向右，负值向左。 第二个值：垂直偏移，正值向下，负值向上。 第三个值：模糊半径。即使前两个值都为0，设置了模糊半径也能看到阴影。 第四个值：颜色，常用带透明度的rgba。 圆角：border-radius，可以分别指定四个角的圆角。 对某个角同时指定两个半径：椭圆圆角。border-top-left-radius:10px 20px 四个值：左上 右上 右下 左下 三个值：左上 右上/左下 右下 两个值：左上/右下 右上/左下 不到四个值，缺哪个找哪个的对角值，这个值代表了两个角的半径。 将元素设置为圆形： border-radius:50% 水平布局一个元素在其父元素的内容区中存在，该元素的水平布局 必须满足： 左外边距+左边框+左内边距+width+右内边距+右边框+右外边距 = 其父元素内容区的宽度但元素设置浮动float后，该等式不需要强制成立！ 等式中的宽度width，左外边距margin-left，左内边距padding-left可以设置为auto。 如果不满足，如何调整？（注意margin可以为负） 如果这7个值没有auto，浏览器会自动调整margin-right。 如果这7个值有一个auto，浏览器会自动调 整auto。width的默认值即为auto。 如果这7个值有两个auto，且一个是width一个是margin，则宽度会调整到最大，设置为auto的外边距自动为0。 如果三个都是auto，则padding为0，width最大。（全屏） 如果将两个外边距auto，宽度固定，则会将外边距设置为相同的值。（元素在父元素居中） 经常利用这个特点使元素在子元素内居中 垂直布局 默认情况下父元素的高度会被内容撑开如果子元素的大小超过了父元素，则子元素会从父元素溢出 使用overflow属性设置父元素如何处理溢出的子元素，可选值如下： visible：默认值，子元素会从父元素中溢出，在父元素外部的位置显示 hidden：溢出内容会被裁剪，不会显示（“一剪没”） scroll：生成垂直和水平两个滚动条，通过滚筒条查看完整内容 auto：根据需要生成滚动条（水平还是垂直） overflow-x：单独处理水平方向的 overflow-y：单独处理垂直方向的 相邻的垂直方向外边距的折叠（重叠） 相邻 且 垂直才适用这种情况。 兄弟元素 两者都是正值：会取两者之间的较大值 特殊情况：一正一负：取两者的和；两负：取两者绝对值较大的 兄弟元素外边距的重叠对开发是有利的，不需要处理 父子元素 子元素的会传递给父元素（上外边距） 父子元素外边距的重叠会影响到页面布局，必须处理！解决方法：要么不用外边距（给父元素padding），要么别相邻（给父元素border，隔开外边距） 解决方案：::before伪元素 + display:table 1234.box1::before&#123; content:&#x27;&#x27;; display:table&#125; table既可以解决高度塌陷，又可以解决外边框重叠。 行内元素的盒模型 文字的垂直居中：要让一个文字在父元素中垂直居中，只需让父元素的line-height和父元素height相等。 行内元素不支持设置宽度和高度，因为行内元素没有内容区，宽高是对内容区而言的 行内元素支持设置padding、border和margin，但垂直方向的这些属性不会影响页面的布局 display，用来设置元素显示的类型 inline：将元素设置为行内元素 block：将元素设置为块元素 inline-block：将元素设置为行内块元素（既可以设置宽高，又不会独占一行，有点像替换元素的特点） 行内块元素同时具备行内元素和块元素的优点和缺点。尽量避免使用行内块元素！ table：将元素设置为一个表格 none：元素不在页面中显示 不占据页面的位置！ visibility，用来设置元素的显示状态 visible：默认值，元素在页面中正常显示 hidden：元素在页面中隐藏不显示 依然占据页面的位置！ 浮动 元素设置浮动后会完全从文档流中脱离，不再占用文档流的位置！脱离后，元素的一些特点也会发生变化。脱离文档流的特点如下： 块元素不再独占一行，且宽度和高度默认都被内容撑开 行内元素会变成块元素。 脱离文档流后，不需要再去区分块元素和行内元素! 设置浮动后，元素会向其父元素的左侧或右侧移动。默认值为none。 浮动元素不会从父元素中移出。 水平上，浮动元素向左或向右移动时， 不会超过 它前面的其他浮动元素。 垂直上，浮动元素不会超过它上边的浮动的兄弟元素，最多和它一样高。 若浮动元素的上边是一个没浮动的块元素，则浮动元素无法上移。 浮动元素不会盖住文字，文字会自动环绕在浮动元素周围。所以可以利用浮动设置文字环绕图片的效果。 浮动的高度塌陷问题在布局中，父元素的高度默认是被子元素撑开的。但是若子元素浮动后，其会完全脱离文档流，子元素从文档流中脱离将会无法撑起父元素的高度，导致父元素的高度丢失。其下一个元素会自动上移。页面布局混乱。 解决方案： 如果塌陷了的元素样式可以写死，可以直接给塌陷了的元素设置一个height。 BFC（Block Formatting Context）、clear和clearfix。 BFCBFC：CSS中的一个隐含属性，可以为一个元素开启BFC。开启BFC后，该元素会变成一个独立的布局区域。元素开启BFC后的特点如下： 开启BFC的元素不会被浮动元素覆盖 开启BFC的元素子元素和父元素的外边距不会重叠 开启BFC的元素可以包含浮动的子元素（解决高度塌陷） 由于BFC是一种隐含属性，不能直接开启，可以通过一些特殊的方式开启元素的BFC： （不推荐）设置元素的浮动（给想要包含浮动子元素的元素开启）。副作用：从文档流中脱离，宽度丢失。可能影响布局。 （不推荐）将元素设置为行内块元素。不会从文档流中脱离。副作用：宽度丢失。 （推荐）将元素的overflow设置为一个不是visible的属性：overflow：hidden或overflow：auto。 clear作用：清除浮动元素对当前元素产生的影响原理：设置清除浮动后，浏览器会自动为元素添加一个上外边距，以使其位置不受其他元素的影响。可选值：left：清除左侧浮动元素对当前元素产生的影响；right：清除右侧浮动元素对当前元素产生的影响；both：清除两侧中最大影响的那侧（最常用）。 高度塌陷的最终解决方案：用::after伪类 12345.box1::after&#123; content:&#x27;&#x27;; clear:both; display:block/table; &#125; 解决高度塌陷和外边框重叠的最终方案（灵活，推荐）给存在这两种问题的元素直接添加一个clearfix类名： 12345.clearfix::before,.clearfix::after&#123; content:&#x27;&#x27;; display:table; clear:both;&#125; 定位1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&gt; 关于层级：&gt; 如果元素的层级一样，则优先显示靠下的元素。&gt; 祖先元素的层级再高也不会盖住后代元素。#### 绝对定位：absolute&lt;span style=&quot;color:red&quot;&gt;相对于其包含块（containing block）定位&lt;/span&gt;&gt; 关于包含块（正常情况下，包含块就是当前元素**最近**的祖先**块**元素）&gt; 绝对定位的包含块：当前元素最近的开启了定位的祖先元素；若所有祖先元素都没开启定位，则根元素就是它的包含块。+ 若不设置偏移量，***元素位置***不会发生变化+ 开启绝对定位的元素会 **从文档流中脱离** ，性质发生变化：行内变成块，块的宽高被内容撑开+ 会使元素提升一个层级+ 水平方向的布局等式需要添加left和right两个值。规则还和以前一样。+ 当发生过度约束时： 1. 如果9个值中没auto，则自动调整right 2. 如果有auto（margin width left right），则自动调整auto的值 + 由于left和right的值默认是auto，所以当未设置它们的值且等式不满足时会自动调整这两个值。所以如果想通过margin设置居中的话必须要设置left和right为0。 + 即水平居中：```left: 0；right:0; margin-left:auto;margin-right:auto```+ 绝对定位后，垂直方向的等式也必须满足：top+margin-top/bottom+padding-top/bottom+height=包含块的高度 1. 垂直居中：```top:0;bottom:0;margin-top:0;margin-bottom:0``` 2. 在 ***父元素*** 中垂直且水平居中：```top:0;bottom:0;left: 0；right:0; margin:auto```#### 相对定位：relative“灵魂出窍：移出来的是魂，肉体还在之前的位置”偏移量：```top```,```bottom```,```left```,```right```，是定位元素和定位位置上下左右的距离。&lt;span style=&quot;color:red&quot;&gt;参照 ***元素自身在文档流*** 中的位置。而且， ***没有脱离文档流***。&lt;/span&gt;相对定位的特点：+ 开启后，若不设置偏移量，元素不会发生任何变化+ 会提升元素的层级+ 不会改变元素性质：块还是块，行内还是行内#### 固定定位：fixed也是一种绝对定位，大部分特点和绝对定位一样。唯一不同：固定定位永远参照浏览器的视口进行定位。不会随网页的滚动条滚动。#### 粘滞定位：sticky兼容性较差。一般不采用。（完全不兼容IE）+ 和相对定位的特点基本一致+ 不同的是粘滞定位可以在元素到达某个位置时进行固定，参照包含块。### 文字font可以设置字体相关的所有属性。字体大小和字体族必须有。会覆盖单独设置的值。```cssfont: 样式（font-style） 字重（font-weight） 字体大小/行高（lineheight） 字体族font：italic bold 50px/2 微软雅黑，‘Times New Roman’,Times,serif; 行高lineheight和字体框行高lineheight指的是文字占有的实际高度。可以任意指定一个大小（px em），也可以设置为整数，整数的意义是字体的指定的倍数。 注意行高指的是 单行 的行高！ 字体框是字体存在的格子，设置font-size字体大小实际就是设置字体框的高度。 行高会在字体框上下平均分配。 可以将行高设置为和高度一样的值，使 单行 文字在父元素中垂直居中 行高经常还用来设置文字的行间距。css没有行间距的属性，利用公式行间距=行高-字体大小来间接控制行间距。 文本的水平和垂直对齐水平对齐：text-align，默认值left ；right ；居中对齐center ；两端对齐justify垂直对齐：vertical-align，默认值基线对齐baseline；顶部对齐top；底部对齐bottom；居中对齐middle（中线对齐）。还可以直接指定值vertical-align:100px。 用img标签引入图片时，由于图片作为替换元素性质很像行内元素，默认是基线对齐，导致图片和它父元素的border之间有一条缝隙，这个缝隙就是图片的 基线 。想消除这个缝隙：将图片的vertical-align设置为除baseline外的任意值即可。 其他文本样式123456789101112可选：none ；overline ；underline ；line-through。```white-space```：设置网页如何处理空白。可选：normal ；nowrap ；pre保留空白（预处理文本，保留html文件中写的格式）；&gt; 如何实现文字显示不全，有省略号的效果？&gt; ```css&gt; .box&#123;&gt; width:200px;&gt; white-space:nowrap;&gt; overflow:hidden;&gt; text-decoration:ellipsis;&gt; &#125; 其中width设置文本包含框宽度；white-space:nowrap; overflow:hidden; text-decoration:ellipsis;三者缺一不可。 背景123456+ background- size必须写在background-position后面，并且使用/隔开。即```background-position/background-size```。+ background-origin必须在background-clip前面。```cssbackground: url(&quot;./1.png&quot;) #bfa center center/contain no-repeat； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950```background-repeat:no-repeat```：背景重复方式。```background-position:top left```：背景图片的位置。使用方位词时必须同时指定两个，如果只写一个另一个默认为center。也可以通过偏移量指定背景图片的位置。```background-size：100% auto```：背景图片大小。第一个值宽度，第二个值高度，如果只写一个则另一个默认为auto（图片比例不变）。cover：图片比例不变，将元素铺满contain：图片比例不变，将图片在元素中完整显示```background-origin:content-boc```：背景图的偏移量background-position的计算原点padding-box：默认值，background-position从内边距（左上角）开始计算content-box：从内容区处计算border-box：从边框处计算```background-clip:padding-box```：背景范围。border-box：默认值，背景会出现在边框的下面（内容区内边框和边框）padding-box：背景只到内边距（内容区和内边距出现），不会出现在边框content-box：背景只到内容区```background-attachment:scroll```：背景图片是否跟随元素移动。scroll：默认值，背景图片会跟随元素移动fixed：背景会固定在页面中#### 渐变色&gt; 需要通过backgroud-image设置！+ 线性渐变：```backgroud-image:linear-gradient(to right,red,yellow,#bfa)```。开头可以指定渐变方向，多个颜色默认平均分布。 + 可以平铺的线性渐变：```backgroud-image:repeating-linear-gradient(to right,red,yellow,#bfa)```+ 径向渐变（放射渐变）：```backgroud-image:radial-gradient(100px 100px at top left,red,yellow)``` + 语法：```radial-gradient(大小at位置,颜色 位置,颜色 位置,...)``` + 大小：circle、ellipse、closet/fasthest-side/corner + 位置：top、right、left、center、bottom### 表格table中，使用tr表示表格的一行，有几个\\&lt;tr\\&gt;就有几行。tr中，使用td表示一个单元格，有几个\\&lt;td\\&gt;就有几个单元格。```rowspan```：指定行宽。即纵向合并单元格。```colspan```：指定列宽。下面是一个两行四列的表格。```html &lt;table border=&quot;1&quot; width=&quot;50%&quot; align=&quot;center&quot;&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt;a1&lt;/td&gt; &lt;td&gt;c1&lt;/td&gt; &lt;td rowspan=&quot;2&quot;&gt;d1&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;a2&lt;/td&gt; &lt;td&gt;b2&lt;/td&gt; &lt;td&gt;c2&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 可以将一个表格分成三部分：头部thead，主体tbody，底部tfoot。还有&lt;th&gt;标签，表示头部部分的单元格，会有加粗效果。 若表格中没有使用tbody而是直接使用tr，那么浏览器会自动创建一个tbody，并且将tr全部放入tbody。因此 tr不是table的子元素 ！ 表格样式1234567891011121314151617```border-collapse:collapse```：设置边框的合并。```tr:nth-child(odd)&#123;backgroundcolor:gray;&#125;```：设置隔行变色效果。默认情况下元素在td中垂直居中。也可以通过```vertical-align```设置垂直对齐方式。。```text-align```设置水平对齐方式。（top bottom center）&gt; 利用这个特性，可以通过将父元素```display:table```和```vertical-align```让子元素垂直居中。注意水平居中仍需要用```margin:0 auto```实现，不能直接使用```text-align```。### 表单&gt; 数据要提交到服务器中，必须要为元素指定一个name属性！```html&lt;form action=&quot;target.html&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;这是一个文本框&quot; autocomplete=&quot;off&quot;&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; value=&quot;这是一个密码框&quot; disabled&gt; &lt;br&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;注册&quot; value=&quot;这是一个提交按钮&quot; readonly&gt;&lt;/form&gt; 123456```autocomplete```：是否开启自动补全。单选框：同一个“name”字段即可划分到同一组单选按钮中，“value”属性会作为用户填写的值发给服务器。“checked”可以将单选按钮设置为默认选中。```html&lt;input type=&quot;radio&quot; name=&quot;group1&quot; value=&quot;a&quot;&gt;&lt;input type=&quot;radio&quot; name=&quot;group1&quot; value=&quot;b&quot; checked&gt; 还有多选框（type=”checkbox”）、下拉列表（&lt;select&gt;&lt;option&gt;)等。","categories":[],"tags":[]},{"title":"Vue教程","slug":"Vue教程","date":"2022-01-08T14:33:40.000Z","updated":"2022-01-08T14:33:40.000Z","comments":true,"path":"2022/01/08/Vue教程/","link":"","permalink":"https://avalooooooon.github.io/2022/01/08/Vue%E6%95%99%E7%A8%8B/","excerpt":"","text":"参考：Vue中文官网 安装环境：Windows10 简介Vue是一套用于构建用户界面的渐进式JS框架，渐进指Vue可以根据应用的复杂程度自底向上逐层的应用，对于简单应用它只需要一个清凉小巧的核心库，对于复杂应用则可以引入各式各样的Vue插件。它有以下特点： 采用组件化模式，提高代码复用率且更好维护。 声明式编码，让编码人员直接操作dom，提高开发效率。 使用虚拟dom+优秀的diff算法，尽量复用dom节点。 安装环境：Windows10安装node和npm环境 安装脚手架vue-cli123npm install webpack -gnpm install --global vue-clivue -V 其中webpack是一个包管理工具，也是vue-cli的构建工具。上述命令可以完成webpack的全局安装。如果用nvs工具，可以在C:\\Program Files\\nodejs\\node_global中查看全局安装的vue-cli。 构建工程文件cd到工具区。在工作区中vue init webpack testproj以生成webpack脚手架。回车后可能会出现一些提示问题： 项目名称（注意名称中不要出现大写字母，否则会报错） 项目描述（可写可不写，看个人需要） 作者（可写可不写，看个人需要） vue编译，这个选默认即可，运行加编译Runtime + Compiler 是否安装vue-router是否安装vue路由工具 是否使用代码管理工具ESLint管理你的代码 后面几个是测试的工具，需要自己自行了解 可以选择在testproj工程新建好后系统自动进行初始化，安装package.json中描述的依赖。初始化完成后，cd进入项目文件夹。npm run dev运行项目。运行完成后打开浏览器，输入http://localhost:8080/ ，看到Welcome to Your Vue.js APP页面就可以说明项目脚手架已经初始化完成。 若出现报错&#39;webpack-dev-server&#39; 不是内部或外部命令，也不是可运行的程序或批处理文件，运行npm install webpack-dev-server --save-dev即可解决。","categories":[],"tags":[]},{"title":"gcc配置C++环境（Mingw-w64）","slug":"gcc配置C-环境（Mingw-w64）","date":"2022-01-06T11:13:53.000Z","updated":"2022-01-06T11:13:53.000Z","comments":true,"path":"2022/01/06/gcc配置C-环境（Mingw-w64）/","link":"","permalink":"https://avalooooooon.github.io/2022/01/06/gcc%E9%85%8D%E7%BD%AEC-%E7%8E%AF%E5%A2%83%EF%BC%88Mingw-w64%EF%BC%89/","excerpt":"","text":"官方文档 VS Code下 cmake 配置C++环境（windows） 下载 Mingw-w64下载MinGW-w64 - for 32 and 64 bit Windows。往下翻一翻，选择最新版本的x86_64-posix-seh。 解压下载下来的压缩包即可。这里我的解压路径为C: \\mingw64。 配置环境变量进入控制面板-&gt;系统和安全-&gt;系统-&gt;高级系统设置-&gt;环境变量，在系统变量的PATH中添加C:\\mingw64\\bin，保存；接下来cmd中以管理员身份运行gcc -v，验证是否配置好环境变量。 在VS Code中配置这一部分最好参考官方文档：使用Mingw-w64。 创建工作区比如在C盘创建一个空文件夹VSCode-C，然后在该文件夹下面再新建空文件夹“workspace”作为工作区，用于存放各种代码。再在workspace文件夹下创建一个test项目和它的配置文件“.vscode”。 安装扩展 C / C ++ IntelliSense配置按Ctrl + Shift + P打开命令面板，键入“ C / C ++”，从建议列表中选择“ 编辑配置（UI）”（Edit Configurations（UI））。VS Code会将在此处进行的更改写入c_cpp_properties.json.vscode文件夹中的文件中。主要修改的是配置集、编译器路径和IntelliSense模式。 C / C ++ IntelliSense配置 写入之后，可以看到 .vscode下添加了c_cpp_properties.json文件，然后按照官方给出的配置进行拷贝就可以了。 12345678910111213141516171819&#123; &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;Win32&quot;, &quot;includePath&quot;: [], &quot;defines&quot;: [ &quot;_DEBUG&quot;, &quot;UNICODE&quot;, &quot;_UNICODE&quot; ], &quot;windowsSdkVersion&quot;: &quot;10.0.17763.0&quot;, &quot;compilerPath&quot;: &quot;C:/mingw64/bin/g++.exe&quot;,//根据个人安装位置修改 &quot;cStandard&quot;: &quot;c17&quot;, &quot;cppStandard&quot;: &quot;c++17&quot;, &quot;intelliSenseMode&quot;: &quot;$&#123;default&#125;&quot; &#125; ], &quot;version&quot;: 4&#125; 创建tasks.json创建构建任务，即创建一个tasks.json文件来告诉VS Code如何构建（编译）程序。该任务将调用g ++编译器以基于源代码创建可执行文件。 任务：配置默认生成任务”（Configure Default Build Task)。在下拉列表中，选择```使用模板创建Tasks.json文件```，然后选择```Others```。VS Code创建一个最小tasks.json文件，并在编辑器中将其打开。1234567891011121314151617181920212223使用以下代码片段替换整个文件内容：```json&#123; &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ &#123; &quot;label&quot;: &quot;build hello world&quot;,//这里可以随意命名 &quot;type&quot;: &quot;shell&quot;, &quot;command&quot;: &quot;g++&quot;, &quot;args&quot;: [ &quot;-g&quot;, &quot;-o&quot;, &quot;HelloWorld&quot;, &quot;HelloWorld.cpp&quot; ], &quot;group&quot;: &#123; &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true &#125; &#125; ]&#125; 配置调试设置配置VS Code以在按F5键时启动GCC调试器（gdb.exe）。首次调试.cpp代码时，会弹出选择环境的下拉菜单。选择GDB / LLDB环境。选择“g++.exe-生成和调试活动文件”。vs code会自动打开launch.json文件。 123456789101112131415161718192021222324252627282930&#123; // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;g++.exe - 生成和调试活动文件&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;C:/VS-Code-C/workspace/HelloWorld/HelloWorld.exe&quot;,//按照个人工作区名字配置 &quot;args&quot;: [], &quot;stopAtEntry&quot;: true, //&quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;, &quot;cwd&quot;: &quot;C:/mingw64/bin&quot;, &quot;environment&quot;: [], &quot;externalConsole&quot;: true, &quot;MIMode&quot;: &quot;gdb&quot;, &quot;miDebuggerPath&quot;: &quot;C:\\\\mingw64\\\\bin\\\\gdb.exe&quot;,//按照个人路径配置 &quot;setupCommands&quot;: [ &#123; &quot;description&quot;: &quot;为gdb启用整齐打印&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true &#125; ], &quot;preLaunchTask&quot;: &quot;C/C++: g++.exe 生成活动文件&quot; &#125; ] &#125; VS Code现在已配置为使用Mingw-w64。该配置适用于当前工作空间。要重用配置，只需将三个JSON文件复制到新工作区中的.vscode子文件夹，然后根据需要更改源文件和可执行文件的名称。 运行HelloWorld.cpp运行结束后，打开工作区，可以看到新生成了一些文件： 如果你在workspace下再次创建一个Hello文件夹，并在它下面写c++文件，会导致程序无法运行，因为我们配置的工作区为workspace，而在其下面的文件夹里的文件无法生成.exe文件，导致程序 运行报错[errror]Id returned 1 exit status。因此我们最好在workspace下直接创建c++文件。","categories":[],"tags":[]},{"title":"node版本管理（macOS和windows）","slug":"node版本管理（macOS）","date":"2021-12-26T07:53:53.000Z","updated":"2021-12-26T07:53:53.000Z","comments":true,"path":"2021/12/26/node版本管理（macOS）/","link":"","permalink":"https://avalooooooon.github.io/2021/12/26/node%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%EF%BC%88macOS%EF%BC%89/","excerpt":"","text":"安装的npm全局模块不会在各个版本的node.js之间共享。还有可能有些npm包不支持当前使用的node版本 不要使用单数的node版本！ macOS：使用 n 版本管理工具检查node及npm环境12node -vnpm -v 安装node版本管理模块n12sudo npm i -g n n -V 安装和切换node版本可能要求权限，在命令前加sudo即可。 1234567891011121314# 列出所有node版本n ls # 安装某个版本n xx.xx.x (版本号)# 切换node版本(通过上下键盘加回车选择)n# 删除某个版本n rm xx.xx.x# 使用某个版本来运行脚本n use xx.xx.x a.js Windows/macOS：使用 nvs 版本管理工具安装nvs nvs的设置参考官方说明 在nvs/releases 下载最新版本的 nvs.msi，双击安装。添加环境变量： 1NVS_HOME=%LOCALAPPDATA%\\nvs 下面是一些基本命令。 12345678# 初始化并使用 NVSnvs install # 从 profile 和 environment 中移除 NVSnvs uninstall # 展示 NVS 版本nvs --version 如果想要把lts设置为系统默认的node版本： 1nvs link lts 注意，nvs use 是改变当前shell窗口的node版本，不是全局环境（nvm的区别）；nvs link是改变全局环境的node版本。 配置镜像地址国内需要把对应的镜像地址修改为淘宝的镜像地址。 12nvs remote node https://npm.taobao.org/mirrors/node/nvs remote nvs remote命令允许配置多个命名的下载位置。NVS 分别管理来自不同远程位置的版本，因此没有版本冲突的风险。默认情况下，只有一个远程指向 Node.js 官方版本： 123$ nvs remotedefault nodenode https://npm.taobao.org/mirrors/node/ 这样就可以从其他来源获得构建。以下命令为 nightly 添加了一个远程 remote，列出了 nightly ，并添加了一个构建： 12345$ nvs remote add nightly https://nodejs.org/download/nightly/$ nvs lsr nightly/13nightly/13.1.1-nightly20191120c7c566023f...$ nvs add nightly/13 安装和切换node版本12345678910111213141516171819# 展示本地的Node.js列表nvs ls [filter] # 切换Node版本nvs use node/[version]/x64# 更新当前环境的 Node.js 至最新版本nvs upgrade [fromver]# 列出可下载的 Node.js 版本nvs ls-remote [filter]nvs lsr [filter]# 下载某个版本的 Node.jsnvs add [version] # 移除某个版本的 Node.jsnvs rm &lt;version&gt; 根据目录自动切换版本在 Bash 或 PowerShell 中，NVS 可以在更改目录时自动切换当前 Shell 中的 Node.js 版本。默认情况下，此功能处于禁用状态。使它运行nvs auto on。之后，无论何时cd或pushd在包含.node-version或.nvmrc文件的目录下，NVS 都会相应地自动切换 Node.js 版本，并在必要时下载新版本。当您cd到达目录上方没有目录.node-version或.nvmrc文件的目录时，将还原默认（链接）版本（如果有）。 Windows 命令提示符中不提供此功能。请用 PowerShell。 1234567891011~$ nvs link 6.9.1~/.nvs/default -&gt; ~/.nvs/node/6.9.1/x64~$ nvs usePATH += ~/.nvs/default/bin~$ nvs auto on~$ cd myprojectPATH -= ~/.nvs/default/binPATH += ~/.nvs/node/4.6.1/x64/bin~/myproject$ cd ..PATH -= ~/.nvs/node/4.6.1/x64/binPATH += ~/.nvs/default/bin 如果您的外壳与自动切换不兼容，或者您 ​​ 希望手动切换但仍利用其中的任何一个.node-versionor.nvmrc文件，则可以nvs use auto使用该版本运行，也可以直接运行nvs auto。 1nvs use auto 或 nvs auto VS Code 支持nvs 这部分参考官方说明 VS Code可以使用 NVS 选择启动或调试时要使用的 Node.js 版本。在launch.json（位于项目根目录的.vscode文件夹中）添加一个“runtimeArgs”属性，该属性包含一个NVS可识别的版本字符串，以及一个“runtimeExecutable”属性，该属性指向nvs.cmd（Windows）或nvs（Mac, Linux）。对于多平台开发，可以为每个平台自定义配置。如果 NVS 不在 VS Code 的 PATH 环境变量中，则可能需要指定一个绝对路径，例如”${env:HOME}/.nvs/nvs”)配置示例：配置launch.json，以便VS Code使用NVS启动节点版本6.10： 12345678910111213&quot;configurations&quot;: [ &#123; &quot;type&quot;: &quot;node&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;name&quot;: &quot;Launch Program&quot;, &quot;program&quot;: &quot;$&#123;file&#125;&quot;, &quot;args&quot;: [ ], &quot;runtimeArgs&quot;: [ &quot;6.10&quot; ], &quot;windows&quot;: &#123; &quot;runtimeExecutable&quot;: &quot;nvs.cmd&quot; &#125;, &quot;osx&quot;: &#123; &quot;runtimeExecutable&quot;: &quot;nvs&quot; &#125;, &quot;linux&quot;: &#123; &quot;runtimeExecutable&quot;: &quot;nvs&quot; &#125; &#125;,] “runtimeArgs”中的NVS版本字符串值由完整或部分语义版本号或版本标签（“lts”、“latest”、“Argon”等）组成，可选前跟远程名称，可选后跟处理器架构或位数（“x86”、“x64”、“32”、“64”），用斜杠分隔。当部分版本与多个可用版本匹配时，会自动选择最新版本。示例：“节点/lts”、“4.6.0”、“6/x86”、“节点/6.7/x64”。NVS别名也可以代替版本字符串。 或者”runtimeArgs”中的版本字符串可能会被省略（相当于“auto”），在这种情况下，NVS搜索项目目录或父目录中最近的.node-version文件。如果找到，则下载（如有必要）并启动文件中指定的版本。如果没有找到.node-version文件，则将启动默认（链接）版本（如果有的话）。 当不将自动模式与.node-version文件一起使用时，launch.json中指定的节点版本必须已经使用nvs add命令下载。否则，启动将失败，NVS打印错误信息“未找到指定版本”。 有关更多详细信息，请参见NVS VS Code文档。或者执行命令nvs help vscode。 Windows：使用 nvm 版本管理工具查看nvm版本1nvm version 安装和切换node版本1234567891011121314151617# 列出所有node版本。* 代表当前版本。末尾输入 available 显示可供下载的所有版本列表。nvm list [available]# 安装某个版本。version：版本号 例如 8.9.0 或者 latest（最新稳定版）,[arch]可选、指定是否安装32位或64位版本（默认为系统架构），将[arch]设置为 all 安装32和64位版本。nvm install &lt;version&gt; [arch]# 切换node版本。可选[arch]32和64位版本nvm use &lt;version&gt; [arch]# 卸载指定的node版本nvm uninstall &lt;version&gt;# 设置nvm存放不同版本的node.js的目录。 如果没有设置 path ，则显示当前的根目录nvm root &lt;path&gt;# 设置node是以32还是64位模式运行。 指定32或64来覆盖默认操作系统版本。nvm arch [32|64]","categories":[],"tags":[{"name":"node","slug":"node","permalink":"https://avalooooooon.github.io/tags/node/"}]},{"title":"gitbook使用教程","slug":"gitbook使用教程","date":"2021-12-26T06:39:24.000Z","updated":"2021-12-27T04:34:54.000Z","comments":true,"path":"2021/12/26/gitbook使用教程/","link":"","permalink":"https://avalooooooon.github.io/2021/12/26/gitbook%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","excerpt":"","text":"参考了这篇文章 检查node环境1node -v 安装gitbook环境安装gitbook-cli工具gitbook-cli是一个在同一系统上安装和使用多个版本的GitBook的实用程序。它将自动安装所需版本的GitBook来构建一本书。打开终端输入npm install gitbook-cli -g进行全局安装： 12npm install gitbook-cli -g gitbook --version 可能遇到的问题:TypeError: cb.apply is not a function解决方案：降低node版本。10.xx.xx是可行的。 Gitbook使用初始化一本书（笔记文件夹）在想要的位置创建一个项目目录，cd到该目录，执行 1gitbook init 可以看到该目录下出现了README.md和SUMMARY.md两个文件。 编辑目录如果SUMMARY.md文件有已经编辑好的目录，gitbook init时会根据目录内容创建文件。下面是SUMMARY.md的一个实例： 12345678* [Introduction](README.md)* [第一章](part1/README.md) * [1.1](part1/1.md) * [1.2](part1/2.md) * [1.2.1](part1/2/1.md)* [第二章](part2/README.md) * [2.1](part2/1.md)* [第三章](part3/README.md) 它生成的文件结构如下： 写笔记根据喜好选择编辑器即可。 启动gitbook服务1gitbook serve 启动服务后，项目文件夹中会生成一个_book文件夹，此文件夹就是最终生成的项目。 生成电子书浏览器打开地址” http://localhost:4000&quot;即可预览。 部署到github首先在项目中创建一个.gitignore文件（和README.md、SUMMARY.md）同级，内容如下： 12# 忽略gitbook生成的项目目录_book 此外，由于gitbook生成的项目跟文档的源码是两个部分，所以可以把文档放到master分支上，部署的网站放到gh-pages 分支。 在github上创建一个仓库自行创建即可。 本地项目提交到github仓库12345git initgit add .git commit -m # 初始化gitbook本地项目&#x27;git remote add origin &lt;git仓库地址&gt;git push -u origin main # 推送到远程仓库的main分支 生成项目并上传到github仓库的gh-pages分支由于打包命令太多，为了简单化，现在写一个脚本命令来自动执行。当然你也可以终端自己执行这些命令。 为了部署方便，可以创建一个脚本文件deploy.sh,内容如下： 123456789101112131415161718192021222324252627282930#!/usr/bin/env shecho &#x27;开始执行命令&#x27;# 生成静态文件echo &#x27;执行命令：gitbook build .&#x27;gitbook build .# 进入生成的文件夹echo &quot;执行命令：cd ./_book\\n&quot;cd ./_book# 初始化一个仓库，仅仅是做了一个初始化的操作，项目里的文件还没有被跟踪echo &quot;执行命令：git init\\n&quot;git init# 保存所有的修改echo &quot;执行命令：git add -A&quot;git add -A# 把修改的文件提交echo &quot;执行命令：commit -m &#x27;deploy&#x27;&quot;git commit -m &#x27;deploy&#x27;# 如果发布到 https://&lt;USERNAME&gt;.github.io/&lt;REPO&gt;echo &quot;执行命令：git push -f git@github.com:Avalooooooon/ING_leetcode_2201.git head:gh-pages&quot;git push -f git@github.com:Avalooooooon/ING_leetcode_2201.git head:gh-pages# 返回到上一次的工作目录echo &quot;回到刚才工作目录&quot;cd - 注意脚本文件代码中仓库地址要替换成你自己的地址。文件保存后，在终端执行如下命令，把生成的项目推送到github仓库上的gh-pages分支： 123bash deploy.sh # macos# windows中，确保已经安装了git工具后直接双击deploy.sh即可运行 执行成功后，打开你的github仓库，然后选择branch分支，会发现多了一个gh-pages分支，打开这个分之后，里面会有一个index.html文件。说明部署的代码上传成功了。注意：如果没有gh-pages分支说明没有部署成功请查看刚才执行的终端看哪里报错了，解决报错直到成功部署。 配置GitHub Pages显示网站在github网站上的仓库里面点击Settings -&gt; GitHub Pages选项中 -&gt; Source里面选择gh-pages branch 然后点击Save按钮，然后在GitHub Pages下面就会看见一个网址，这个网址就是最终的网站。 gitbook多终端使用需要一台已经配置好gitbook环境且有完整gitbook文件夹的终端作为条件。在另一台设备上，git clone仓库的master分支，运行deploy.sh文件。 在Windows端，如果出现报错”Error:ENOENT:no such file or directory, stat ‘C:\\Users\\Lenovo\\www\\mdspg\\md\\mybook_book\\gitbook\\gitbook-plugin-fontsettings\\fontsettings.js’”，在C:\\Users\\username.gitbook\\versions\\3.2.3\\lib\\output\\website\\copyPluginAssets.js，将confirm:true全部替换为confirm:false。共两处。 多终端发布不论是在哪台终端，修改了书籍文件后按下列步骤进行操作： git pull origin main，先pull完成本地与远端的融合 修改书籍内容 git add - A ，添加本地所有文件到仓库 git commit -m 修改说明，提交修改； git push origin main，更新至main分支； 运行deploy.sh文件，生成项目并上传到github仓库的gh-pages分支； gitbook serve，启动gitbook服务。启动服务后，项目文件夹中会生成一个_book文件夹，此文件夹就是最终生成的项目。 gitbook的配置文件讲解如果想对你的网站有更详细的个性化配置或使用插件，那么需要使用配置文件。配置文件写完后，需要重启服务或者重新打包才能应用配置。gitbook的配置文件名是book.json，首先在项目的根目录中创建book.json文件。book.json主要内容： 123456789101112131415161718192021222324252627282930313233&#123; &quot;title&quot;: &quot;我的一本书&quot;, &quot;author&quot; : &quot;yu&quot;, &quot;description&quot; : &quot;我第一本书的描述，很好&quot;, &quot;language&quot; : &quot;zh-hans&quot;, &quot;structure&quot;: &#123; &quot;readme&quot;: &quot;introduction.md&quot; &#125;, &quot;plugins&quot;: [ &quot;-lunr&quot;, &quot;-search&quot;, &quot;search-pro&quot;, &quot;back-to-top-button&quot; ], &quot;pluginsConfig&quot;: &#123; &quot;anchor-navigation-ex&quot;: &#123; &quot;isShowTocTitleIcon&quot;: true &#125; &#125;, &quot;links&quot; : &#123; &quot;sidebar&quot; : &#123; &quot;个性链接1&quot; : &quot;https://www.baidu.com&quot;, &quot;个性链接2&quot; : &quot;https://www.baidu.com&quot; &#125; &#125;, &quot;styles&quot;: &#123; &quot;website&quot;: &quot;styles/website.css&quot;, &quot;ebook&quot;: &quot;styles/ebook.css&quot;, &quot;pdf&quot;: &quot;styles/pdf.css&quot;, &quot;mobi&quot;: &quot;styles/mobi.css&quot;, &quot;epub&quot;: &quot;styles/epub.css&quot; &#125;&#125; book.json中一些主要参数说明 title：标题 author：作者 description：描述，对应gitbook网站的description language：使用的语言，zh-hans是简体中文，会对应到页面的&lt;html lang=”zh-hans” &gt; structure：指定 Readme、Summary、Glossary 和 Languages 对应的文件名，下面是这几个文件对应变量以及默认值： Variable Description structure.readme Readme file name (defaults to README.md) structure.summary Summary file name (defaults to SUMMARY.md) structure.glossary Glossary file name (defaults to GLOSSARY.md) structure.languages Languages file name (defaults to LANGS.md) 比如想把readme文件换个名字，则可以使用如下配置 123&quot;structure&quot;: &#123; &quot;readme&quot;: &quot;introduction.md&quot;&#125;, 使用这个配置后，gitbook服务就不会找readme文件，而去找introduction文件当项目说明，这样就可以把readme文件完全当成代码仓库说明文档了。 plugins：使用的插件列表，所有的插件都在这里写出来，然后使用gitbook install来安装。 pluginsConfig：插件的配置信息，如果插件需要配置参数，那么在这里填写。 links：目前可以给侧导航栏添加链接信息12345&quot;links&quot; : &#123; &quot;sidebar&quot; : &#123; &quot;个性链接1&quot; : &quot;https://www.baidu.com&quot; &#125;&#125; styles：自定义页面样式，各种格式对应各自的css文件1234567&quot;styles&quot;: &#123; &quot;website&quot;: &quot;styles/website.css&quot;, &quot;ebook&quot;: &quot;styles/ebook.css&quot;, &quot;pdf&quot;: &quot;styles/pdf.css&quot;, &quot;mobi&quot;: &quot;styles/mobi.css&quot;, &quot;epub&quot;: &quot;styles/epub.css&quot;&#125; 配置默认主题默认的主题可以通过配置来做一下效果。比如侧边栏菜单显示标题数字，可以在配置文件的pluginsConfig参数中写入如下字段： 1234567&#123; &quot;pluginsConfig&quot;: &#123; &quot;theme-default&quot;: &#123; &quot;showLevel&quot;: true &#125; &#125;&#125; 效果如图： gitbook的一些实用插件 gitbook插件可以解决一些网站不太方便的地方，如侧边栏导航不能收缩，自带搜索不支持中文等。用了插件书籍网站会更灵活和美观。 由于插件很多，请参考另一篇文章：https://segmentfault.com/a/1190000019806829","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://avalooooooon.github.io/tags/git/"}]},{"title":"git笔记","slug":"git笔记","date":"2021-12-20T07:40:59.000Z","updated":"2021-12-20T07:40:59.000Z","comments":true,"path":"2021/12/20/git笔记/","link":"","permalink":"https://avalooooooon.github.io/2021/12/20/git%E7%AC%94%E8%AE%B0/","excerpt":"","text":"查看完整教程：Git-scm 查看版本/日志123# 项目所在目录git log：查看提交日志（查看版本号）git log git reflog # 查看版本号 不传入任何参数的默认情况下，git log 会按时间先后顺序列出所有的提交，最近的更新排在最上面。git log 有许多选项可以帮助你搜寻你所要找的提交，下面是最常用的几个： -p 或 ``–patch` ：显示每次提交所引入的差异（按补丁的格式输出） -&lt;n&gt; :仅显示最近的 n 条提交。 --since 和 --until ：按照时间作限制。12# 列出最近两周的所有提交$ git log --since=2.weeks 该命令可用的格式十分丰富——可以是类似 &quot;2008-01-15&quot; 的具体的某一天，也可以是类似 &quot;2 years 1 day 3 minutes ago&quot; 的相对日期。 --author : 指定作者 --grep : 搜索提交说明中的关键字 --stat：显示每次提交的简略统计信息。--stat 选项在每次提交的下面列出所有被修改过的文件、有多少文件被修改了以及被修改过的文件的哪些行被移除或是添加了。 在每次提交的最后还有一个总结。 --pretty：使用不同于默认格式的方式展示提交历史。 这个选项有一些内建的子选项供你使用。 比如 oneline 会将每个提交放在一行显示，在浏览大量的提交时非常有用。 当 oneline 或 format 与另一个 log 选项 --graph 结合使用时尤其有用。 这个选项添加了一些 ASCII 字符串来形象地展示你的分支、合并历史。 另外还有 short，full 和 fuller 选项，它们展示信息的格式基本一致，但是详尽程度不一。 format ：可以定制记录的显示格式。 这样的输出对后期提取分析格外有用——因为你知道输出的格式不会随着 Git 的更新而发生改变： 1234$ git log --pretty=format:&quot;%h - %an, %ar : %s&quot;ca82a6d - Scott Chacon, 6 years ago : changed the version number085bb3b - Scott Chacon, 6 years ago : removed unnecessary testa11bef0 - Scott Chacon, 6 years ago : first commit git log --pretty=format 常用的选项 列出了 format 接受的常用格式占位符的写法及其代表的意义。 更详细的选项说明可以参考git log 的常用选项 。 文件文件状态1234# 查看当前分支、分支同远程分支的比较、哪些文件处于什么状态git status# 开始跟踪一个文件/将一个文件放到暂存区、git add 文件名 未跟踪的文件意味着 Git 在之前的快照（提交）中没有这些文件；Git 不会自动将之纳入跟踪范围，除非你明明白白地告诉它“我需要跟踪该文件”。 这样的处理让你不必担心将生成的二进制文件或其它不想被跟踪的文件包含进来。 git add 是个多功能命令：可以用它开始跟踪新文件，也可以用它把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。 将这个命令理解为“精确地将内容添加到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。 注意！运行了 git add 之后又作了修订的文件，需要重新运行 git add 把最新版本重新暂存起来。 如果想缩短状态命令的输出： 12git status -s git status --short 新添加的未跟踪文件前面有 ?? 标记，新添加到暂存区中的文件前面有 A 标记，修改过的文件前面有 M 标记。 输出中有两栏，左栏指明了暂存区的状态，右栏指明了工作区的状态。 示例： 123456$ git status -sM READMEMM RakefileA lib/git.rbM lib/simplegit.rb?? LICENSE.txt README 文件在工作区已修改但尚未暂存，而 lib/simplegit.rb 文件已修改且已暂存。 Rakefile文件已修，暂存后又作了修改，因此该文件的修改中既有已暂存的部分，又有未暂存的部分。 文件的忽略总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下可以创建一个名为 .gitignore 的文件，列出要忽略的文件的模式。 123$ cat .gitignore*.[oa]*~ 第一行告诉 Git 忽略所有以 .o 或 .a 结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的。 第二行告诉 Git 忽略所有名字以波浪符（~）结尾的文件，许多文本编辑软件（比如 Emacs）都用这样的文件名保存副本。 此外，你可能还需要忽略 log，tmp 或者 pid 目录，以及自动生成的文档等等。 要养成一开始就为你的新仓库设置好 .gitignore 文件的习惯，以免将来误提交这类无用的文件。 文件 .gitignore 的格式规范如下： 所有空行或者以 # 开头的行都会被 Git 忽略。 可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。 匹配模式可以以（/）开头防止递归。 匹配模式可以以（/）结尾指定目录。 要忽略指定模式以外的文件或目录，可以在模式前加上叹号（!）取反。 所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。 星号（*）匹配零个或多个任意字符；[abc]匹配任何一个列在方括号中的字符 （这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）； 问号（?）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符， 表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。 使用两个星号（**）表示匹配任意中间目录，比如 a/**/z 可以匹配 a/z 、 a/b/z 或 a/b/c/z 等。 再看一个 .gitignore 文件的例子： 123456789101112# 忽略所有的 .a 文件*.a# 但跟踪所有的 lib.a，即便你在前面忽略了 .a 文件!lib.a# 只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO/TODO# 忽略任何目录下名为 build 的文件夹build/# 忽略 doc/notes.txt，但不忽略 doc/server/arch.txtdoc/*.txt# 忽略 doc/ 目录及其所有子目录下的 .pdf 文件doc/**/*.pdf 仓库将尚未进行版本控制的本地目录转换为 Git 仓库先cd到该项目目录，然后 1git init 该命令将创建一个名为 .git 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。 但是，在这个时候，我们仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪。 请记住，工作目录下的每一个文件都不外乎这两种状态：已跟踪 或 未跟踪。 已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后， 它们的状态可能是未修改，已修改或已放入暂存区。简而言之，已跟踪的文件就是 Git 已经知道的文件。其它所有文件都属于未跟踪文件。 编辑过某些文件之后，由于自上次提交后你对它们做了修改，Git 将它们标记为已修改文件。 在工作时可以选择性地将这些修改过的文件放入暂存区，然后提交所有已暂存的修改，如此反复。 如果在一个已存在文件的文件夹（而非空文件夹）中进行版本控制，你应该开始追踪这些文件并进行初始提交。 可以通过 git add 命令来指定所需的文件来进行追踪，然后执行 git commit ： 123git add *.cgit add LICENSEgit commit -m &#x27;initial project version&#x27; 从其它服务器克隆一个已存在的 Git 仓库Git 克隆的是该 Git 仓库服务器上的几乎所有数据，而不是仅仅复制完成你的工作所需要文件。 当你执行 git clone 命令的时候，默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来。克隆仓库的命令是 git clone 。 比如，要克隆 Git 的链接库 libgit2，可以用下面的命令： 1git clone https://github.com/libgit2/libgit2 这会在当前目录下创建一个名为 “libgit2” 的目录，并在这个目录下初始化一个 .git 文件夹， 从远程仓库拉取下所有数据放入 .git 文件夹，然后从中读取最新版本的文件的拷贝。 1git clone https://github.com/libgit2/libgit2 mylibgit 这会执行与上一条命令相同的操作，但目标目录名变为了 mylibgit。也就是在克隆远程仓库的时候，自定义了本地仓库的名字。 远程仓库1234567891011121314# 查看你已经配置的远程仓库服务器git remote# 指定选项 -v：显示需要读写远程仓库使用的Git保存的简写与其对应的URLgit remote -v# 添加远程仓库，同时指定一个方便使用的简写&lt;shortname&gt;git remote add &lt;shortname&gt; &lt;url&gt;# 查看某个远程仓库。同样会列出远程仓库的 URL 与跟踪分支的信息。git remote show &lt;remote&gt;# 修改一个远程仓库的简写名。这同样也会修改你所有远程跟踪的分支名字。git remote rename# 移除一个远程仓库git remote remove # 或git remote rm。一旦你使用这种方式删除了一个远程仓库，那么所有和这个远程仓库相关的远程跟踪分支以及配置信息也会一起被删除。 origin ——这是 Git 给你克隆的仓库服务器的默认名字。如果使用 clone 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。 拉取、抓取与推送抓取——fetch12# 从远程仓库中获得数据git fetch &lt;remote&gt; 这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。 必须注意 git fetch 命令只会将数据下载到你的本地仓库——它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。 拉取——pull如果你的当前分支设置了==跟踪远程分支==，那么可以用 git pull命令来自动抓取后合并该远程分支到当前分支。 这或许是个更加简单舒服的工作流程。默认情况下，git clone 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（或其它名字的默认分支）。 运行 git pull 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。 推送——push1git push &lt;remote&gt; &lt;branch&gt; 只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先抓取他们的工作并将其合并进你的工作后才能推送。 此外，如果直接使用git push origin xxx,“error: 源引用表达式xxx没有匹配”的问题会在关联的代码库远程分支名称与本地（当前）分支的名称不同时出现。如果不相同，就要用git push origin head:xxx，或者git push origin &lt;当前的本地分支名&gt;:xxx提交代码。 分支概述1234567891011# 查看所有分支及当前所在分支【* 表示当前】git branch# 查看每一个分支的最后一次提交git branch -v# 查看哪些分支已经合并到当前分支。 在这个列表中分支名字前没有 * 号的分支通常可以使用 git branch -d 删除掉，因为已经将它们的工作整合到了另一个分支，所以不会失去任何东西。git branch --merged# 查看所有包含未合并工作的分支。因为它包含了还未合并的工作，尝试使用 git branch -d 命令删除它时会失败。可以使用 -D 选项强制删除它。git branch --no-merged# 例如，尚未合并到 master 分支的有哪些？git branch --no-merged master Git怎么知道当前在哪一个分支上呢？ 很简单，它有一个名为 HEAD 的特殊指针指向当前所在的本地分支（译注：将 HEAD 想象为当前分支的别名）。HEAD 分支随着提交操作自动向前移动。 12345678910111213# 创建一个新的分支。这会在当前所在的提交对象上创建一个指针。# git branch 命令仅仅创建 一个新分支，并不会自动切换到新分支中去。git branch xxx # 创建一个新分支后立即切换过去git checkout -b &lt;newbranchname&gt;# 从当前分支切换到某个分支。HEAD指向切换之后的分支。git checkout xxx # 查看各个分支当前所指的提交对象git log --oneline --decorate# 查看提交历史、各个分支的指向以及项目的分支分叉情况git log --oneline --decorate --graph --all 分支切换会改变你工作目录中的文件!!git 会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。如果 Git 不能干净利落地完成这个任务，它将禁止切换分支。 要留意你的工作目录和暂存区里那些还没有被提交的修改。最好的方法是，在你切换分支之前，保持好一个干净的状态。 12# 删除某个分支【慎重操作】 注意当前不能在iii分支上,跳出之后,再删除git branch -d iii 合并分支——fast-forward当你试图合并两个分支时， 如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候， 只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”。 合并分支——merge当两个将要合并的分支各自有不同的父提交时发生。比如下面的例子，要合并master和iss53分支：你的开发历史从一个更早的地方开始分叉开来（diverged）。 因为，master 分支所在提交并不是 iss53 分支所在提交的直接祖先，Git 不得不做一些额外的工作。 出现这种情况的时候，Git 会使用两个分支的末端所指的快照（C4 和 C5）以及这两个分支的公共祖先（C2)，做一个简单的三方合并。和之前将分支指针向前推进所不同的是，Git 将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它。 合并分支——rebaserebase（变基） 命令将提交到某一分支上的所有修改都移至另一分支上。考虑之前提到的merge。开发任务分叉到两个不同分支，又各自提交了更新：Merge会把两个分支的最新快照（C3 和 C4）以及二者最近的共同祖先（C2）进行三方合并，合并的结果是生成一个新的快照（并提交)：其实，还有一种方法：你可以提取在 C4 中引入的补丁和修改，然后在 C3 的基础上应用一次。 在这个例子中，你可以检出 experiment 分支，然后将它变基到 master 分支上： 12git checkout experimentgit rebase master 这种操作就叫做 **变基（rebase)**。它的原理是首先找到这两个分支（即当前分支 experiment、变基操作的目标基底分支 master） 的最近共同祖先 C2，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件， 然后将当前分支指向目标基底 C3, 最后以此将之前另存为临时文件的修改依序应用。 （译注：写明了 commit id，以便理解，下同)现在回到 master 分支，进行一次快进合并: 12git checkout mastergit merge experiment 此时，C4&#39; 指向的快照就和merge中 C5 指向的快照一模一样了。 这两种整合方法的最终结果没有任何区别，但是变基使得提交历史更加整洁。 你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的， 但它们看上去就像是串行的一样，提交历史是一条直线没有分叉。 请注意，无论是通过变基，还是通过三方合并，整合的最终结果所指向的快照始终是一样的，只不过提交历史不同罢了。 变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。 如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基。 总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史， 从不对已推送至别处的提交执行变基操作， 合并分支——冲突如果在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。Git 会暂停下来，等待你去解决合并产生的冲突。 你可以在合并冲突后的任意时刻使用 git status 命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件。任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。 Git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。 12# 启动一个合适的可视化合并工具，并带领你一步一步解决这些冲突git mergetool 等你退出合并工具之后，Git 会询问刚才的合并是否成功。 如果回答“是”，Git 会暂存那些文件以表明冲突已解决。可以再次运行 git status 来确认所有的合并冲突都已被解决。 合并分支——提交1git commit 关于分支的几个常见场景：1.在新的分支上面常规开发【一般是dev分支】 123456# 在确保当前分支是上一步git checkout过来的即可【不放心的话可以git branch 确认下】git add .git commit -m &quot;yyyy&quot;git pull #注意在多人协作push之前,一定先pull下,养成良好的习惯,避免和被人提交的代码冲突,硬合并而照成代码事故】git push # 【再上一步，pull之后如无冲突，即可提交代码】git status #【查看当前工作空间状态】 2.将次分支和并到主分支上【一般是dev分支合并到主分支master上】【dev分支开发完毕,合并到master分支,并推送上线】 12345git checkout dev # 切到dev次分支】git pull #【获取dev分支变化,合并冲突,使本地dev次分支最新】git checkout master #【先切到主分支master上】git merge dev #【一般是git merge dev,将dev开发完的合并到master上】git push -u origin master #【提交master分支到线上master】 3.将主分支和并到次分支上【一般是主分支master合并到dev分支上】【master分支有变动，需要更新开发分支dev上的代码】 12345git checkout master #【切到主分支】git pull #【获取主分支变化,合并冲突,使本地主分支最新】git checkout dev #【先切到次分支dev上】git merge master #【一般是git merge master,将master开发完的合并到dev上】git push -u origin dev #【提交dev分支到线上dev】 版本回退针对部分文件的撤销操作1.有时提交完了才发现漏掉了几个文件没有添加，或提交信息写错了。 可以运行带有 --amend 选项的提交命令来重新提交： 1$ git commit --amend 这个命令会将暂存区中的文件提交。 如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令）， 那么快照会保持不变，而你所修改的只是提交信息。文本编辑器启动后，可以看到之前的提交信息。 编辑后保存会覆盖原来的提交信息，也即用一个新的提交替换旧的提交。 2.取消暂存的文件 1git reset HEAD 要取消暂存的文件名 git reset 确实是个危险的命令，如果加上了 --hard 选项则更是如此。 然而在上述场景中，工作目录中的文件尚未修改，因此相对安全一些。 3.撤消对文件的修改 将它还原成上次提交时的样子（或者刚克隆完的样子，或者刚把它放入工作目录时的样子）: 1git checkout -- &lt;file&gt; 请务必记得 git checkout -- &lt;file&gt; 是一个危险的命令。 你对那个文件在本地的任何修改都会消失——Git 会用最近提交的版本覆盖掉它。 除非你确实清楚不想要对那个文件的本地修改了，否则请不要使用这个命令。 针对整个版本的回退操作假设A 和 B 是正常提交， C 和 D 是错误提交，此时HEAD 指针指向 D 提交。现在想把 C 和 D 回退掉。我们只需将 HEAD 指针移动到 B 提交（idCodeB），就可以达到目的。此时回滚目标B的commitid为idCode1，操作如下： 12345678910# 如果保留修改的撤销-&gt;只删掉提交记录：在项目所在目录执行下列操作git reset HEAD~ # 仓库回滚到上一个版本git reset XXX # 仓库回滚到指定版本git reset --soft idCode1 # 仓库回滚到指定版本# 如果把修改记录也干掉：在项目所在目录执行下列操作git reset --hard idCodeBgit reset --hard HEAD^# 如果是提交到远程仓库上，则在远程仓库上同样执行一次相同的命令 然而，由于即使是在本地执行了git reset –hard (B提交的版本号）使得HEAD 指针移动到 B 提交下，但远程仓库的 HEAD 指针依然不变（还在D提交上），故只能使用 -f 选项将提交强制推到远程仓库：git push -f。它会使 HEAD 指针往回移动，从而会失去之后的提交信息。 而git resert则可以既回退代码，又保存错误的提交。(reset和revert的区别详见这篇博客，主要是 revert是生成一次新的commit冲抵原来的commit， reset直接删除某些commit的内容) 12345678910111213# 注意有多个提交需要回退的话，要由新到旧进行 revert，即先D后C。会生成两个新有提交：D’ 和 C’，按A B C D D’ C’的先后顺序依次排列在分支上git revert idCodeDgit revert idCodeCgit revert OLDER_COMMIT^…NEWER_COMMIT # 多个错误提交时批量回退# 回滚最新一次的提交记录：git revert HEAD# 回滚前一次的提交记录：git revert HEAD^# 对历史上的commit回滚git revert # 确认生成的新commit编译成功，也没有文件冲突，可以push到服务器，完成回滚。","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://avalooooooon.github.io/tags/git/"}]},{"title":"Typora使用指南","slug":"Typora使用指南","date":"2021-12-20T06:14:27.000Z","updated":"2021-12-20T06:14:27.000Z","comments":true,"path":"2021/12/20/Typora使用指南/","link":"","permalink":"https://avalooooooon.github.io/2021/12/20/Typora%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","excerpt":"","text":"文章参考网址官方文档 关于Typora主要使用Github制定的GFM标准。可以在文件 - 偏好设置 - Markdown 语法偏好 - 严格模式 中将标准设置为「更严格地遵循 GFM 标准」。 主题美化在 Typora 中 CSS 被称为「主题」，但其本质仍是 CSS 文件。可以在文件 - 偏好设置 - 主题 - 打开主题文件夹看到这些 CSS 文件。也可以自己修改、新建适合使用需求的 CSS 文件。 Typora 自带了若干主题，可以在 官网 下载更多的主题。 常用写作设置通过打开文件 - 偏好设置定制适合自己编辑习惯的设置。 实时预览通过视图 - 源代码模式或左下角的 &lt;/&gt; 按钮或用快捷键command+ /(Mac)进入源代码模式（Source Mode）。 打字机模式&amp;专注模式在视图 - 专注模式 / 打字机模式中勾选使用这两个模式。「打字机模式」使得你所编辑的那一行永远处于屏幕正中。「专注模式」使你正在编辑的那一行保留颜色，而其他行的字体呈灰色。 智能标点可以自动将不是很美观的直引号 “ ‘ 转化为更美观的弯引号 “ ‘ ’ ”。详情见官方文档。 换行在 Markdown 语法中，换行（line break）与换段是不同的。且换行分为软换行和硬换行。 软换行：在 Typora 中可以通过Shift + Enter完成一次软换行。软换行只在编辑界面可见，当文档被导出时换行会被省略。硬换行：通过空格 + 空格 + Shift + Enter完成一次硬换行，或直接插入HTML标签&lt;br/&gt;。这也是许多 Markdown 编辑器所原生支持的。硬换行在文档被导出时将被保留，且没有换段的段后距。 换段：通过 Enter 完成一次换段。Typora 会自动帮你完成两次 Shift + Enter 的软换行，从而完成一次换段。这也意味着在 Markdown 语法下，换段是通过在段与段之间加入空行来实现的。 Windows 风格（CR+LF）与 Unix 风格（CR）的换行符CR 表示回车 \\r,即回到一行的开头，而 LF 表示换行\\n ,即另起一行。所以 Windows 风格的换行符本质是「回车 + 换行」，而 Unix 风格的换行符是「换行」。这也是为什么 Unix / Mac 系统下的文件，如果在 Windows 系统直接打开会全部在同一行内。 可以在文件 - 偏好设置 - 编辑器 - 默认换行符中对此进行切换。 表格插入不需要按传统的md语法要求的操作，只需要在行内鼠标右键 - 插入 - 表格(注意不能在源代码模式下操作），并输入行数和列数，Typora 就会自动生成一张样式不错的空表格。 图片插入Markdown 原生不太注重图片插入的功能，但可以在 Typora 中： 直接使用右键 - 复制+ Ctrl + V将网络图片、剪贴板图片复制到文档中。 拖动本地图片到文档中 Typora 会自动帮你插入符合 Markdown 语法的图片语句，并给它加上标题。你也完全可以使用图床来保证文档在分享后图片仍能正常显示。 更强大的是，Typora 支持在拖动或 Ctrl + V 网络图片后自动将其保存到本地。可以在文件 - 偏好设置 - 编辑器 - 图片插入中选择复制到哪个路径，什么情况下需要复制。 空格已经把设置改了，现在导出也会保留连续空格。输入连续空格后，会在编辑器视图里保留这些空格，但打印或导出时，这些空格会被省略成一个。在源代码模式下，为每个空格前加一个 \\ 转义符，或者直接使用 HTML 风格的 &amp;nbsp;(No-Break Space) 来保持连续的空格。 表情插入emoji：用:emoji:的形式打出。 链接引用和脚注链接引用类似于我们常在论文末尾看到的「参考文献」的写法，你可以通过[]: 的语法来为你的文档加上链接引用。 脚注即某段话结尾右上角标有数字标记，页面底部进行注释的写法。你可以在需要插入脚注标号的位置写 [^ number ] ，再在下方通过 [^ number ]: 在文档中插入脚注。 注意: 不要遗漏了脚注编号 number 前后的空格 ! 示例[^ 这是一个脚注 ][^ 这是一个脚注 ][^ 这是一个脚注 ]:脚注内容 YAML front-matterTypora 支持在文档头部加上基于 YAML 的 front-matter 信息，这一特性适用于把 Markdown 文档分类归档上传到用 Hexo 框架搭建的博客中。 LaTeXTypora 原生支持 LaTeX 语法，有两种方式输入 LaTeX 风格的数学公式：行内公式（inline）：用$…$ 括起公式，公式会出现在行内。块间公式（display）：用$$…$$ 括起公式（注意 $$ 后需要换行），公式会默认显示在行中间。 其它使用范例typora 画流程图、时序图(顺序图)、甘特图1、横向流程图源码格式：横向流程图 123456graph LRA[方形] --&gt;B(圆角) B --&gt; C&#123;条件a&#125; C --&gt;|a=1| D[结果1] C --&gt;|a=2| E[结果2] F[横向流程图] 2、竖向流程图源码格式： 竖向流程图 123456graph TDA[方形] --&gt; B(圆角) B --&gt; C&#123;条件a&#125; C --&gt; |a=1| D[结果1] C --&gt; |a=2| E[结果2] F[竖向流程图] 3、标准流程图源码格式：标准流程图 123456789st=&gt;start: 开始框op=&gt;operation: 处理框cond=&gt;condition: 判断框(是或否?)sub1=&gt;subroutine: 子流程io=&gt;inputoutput: 输入输出框e=&gt;end: 结束框st-&gt;op-&gt;condcond(yes)-&gt;io-&gt;econd(no)-&gt;sub1(right)-&gt;op 4、标准流程图源码格式（横向）：横向标准流程图 123456789st=&gt;start: 开始框op=&gt;operation: 处理框cond=&gt;condition: 判断框(是或否?)sub1=&gt;subroutine: 子流程io=&gt;inputoutput: 输入输出框e=&gt;end: 结束框st(right)-&gt;op(right)-&gt;condcond(yes)-&gt;io(bottom)-&gt;econd(no)-&gt;sub1(right)-&gt;op 5、UML时序图源码样例：UML时序图 12345对象A-&gt;对象B: 对象B你好吗?（请求）Note right of 对象B: 对象B的描述Note left of 对象A: 对象A的描述(提示)对象B--&gt;对象A: 我很好(响应)对象A-&gt;对象B: 你真的好吗？ 6、UML时序图源码复杂样例：复杂UML 1234567891011Title: 标题：复杂使用对象A-&gt;对象B: 对象B你好吗?（请求）Note right of 对象B: 对象B的描述Note left of 对象A: 对象A的描述(提示)对象B--&gt;对象A: 我很好(响应)对象B-&gt;小三: 你好吗小三--&gt;&gt;对象A: 对象B找我了对象A-&gt;对象B: 你真的好吗？Note over 小三,对象B: 我们是朋友participant CNote right of C: 没人陪我玩 7、UML标准时序图样例：标准UML 123456789101112%% 时序图例子,-&gt; 直线，--&gt;虚线，-&gt;&gt;实线箭头 sequenceDiagram participant 张三 participant 李四 张三-&gt;王五: 王五你好吗？ loop 健康检查 王五-&gt;王五: 与疾病战斗 end Note right of 王五: 合理 食物 &lt;br/&gt;看医生... 李四--&gt;&gt;张三: 很好! 王五-&gt;李四: 你怎么样? 李四--&gt;王五: 很好! 8、甘特图样例：甘特图 12345678910111213141516171819%% 语法示例 gantt dateFormat YYYY-MM-DD title 软件开发甘特图 section 设计 需求 :done, des1, 2014-01-06,2014-01-08 原型 :active, des2, 2014-01-09, 3d UI设计 : des3, after des2, 5d 未来任务 : des4, after des3, 5d section 开发 学习准备理解需求 :crit, done, 2014-01-06,24h 设计框架 :crit, done, after des2, 2d 开发 :crit, active, 3d 未来任务 :crit, 5d 耍 :2d section 测试 功能测试 :active, a1, after des3, 3d 压力测试 :after a1 , 20h 测试报告 : 48h","categories":[],"tags":[]},{"title":"Markdown笔记","slug":"Markdown笔记","date":"2021-12-20T06:12:19.000Z","updated":"2021-12-20T06:12:19.000Z","comments":true,"path":"2021/12/20/Markdown笔记/","link":"","permalink":"https://avalooooooon.github.io/2021/12/20/Markdown%E7%AC%94%E8%AE%B0/","excerpt":"","text":"typora快捷键 标题#一级标题：## 二级标题### 三级标题#### 四级标题 段落在 Markdown 语法中，换行（line break）与换段是不同的。且换行分为软换行和硬换行。换行：两个以上空格加回车，或直接插入HTML标签&lt;br/&gt; 软换行：在 Typora 中可以通过 Shift + Enter 完成一次软换行。软换行只在编辑界面可见，当文档被导出时换行会被省略。硬换行：通过 空格 + 空格 + Shift + Enter 完成一次硬换行，或直接插入HTML标签&lt;br/&gt;。这也是许多 Markdown 编辑器所原生支持的。硬换行在文档被导出时将被保留，且没有换段的段后距。 换段：通过在段与段之间加入空行来实现。在段落后面使用一个空行来表示重新开始一个段落。 分隔线：在一行中用三个以上的星号、减号、下划线来建立一个分隔线，行内不能有其他东西。效果如下： 在星号或是减号中间插入空格没有影响。下面每种写法都可以建立分隔线：***---___* * * 文本~~要删除的文字~~: 要删除的文字&lt;u&gt;带下划线文本&lt;/u&gt;: 带下划线文本**演示粗体**: 演示粗体*演示斜体* : 演示斜体 脚注：创建脚注格式为： 主段落[^ 脚注01 ] [^ 脚注01 ]: 这是脚注内容。效果如下： 主段落^ 脚注01 。 代码段内插入代码片段`代码内容` ，效果为 代码内容 整段插入代码片段1. 用一对``` 包裹一段代码，并指定一种语言（也可以不指定）：``` pythonprint``` 1print 2. 用段落前缩进(4 个空格或者一个制表符（Tab ）)的方式显示代码块。注意代码要在一个新段开始，否则无法正确显示为代码格式。 区块引用在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号。一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推：&gt; 区块引用&gt;&gt; 第一层嵌套&gt;&gt;&gt; 第二层嵌套&gt; 这个位置，这样是无效的 区块引用 第一层嵌套 第二层嵌套这个位置，尝试用一个&gt;是无效的 在列表内添加区块需要在 &gt; 前添加四个空格的缩进。 列表无序列表使用*、+或-作为列表标记，这些标记后面要添加一个空格，然后再填写内容：+ 第一项+ 第二项 显示为： 第一项 第二项 有序列表使用数字并加上 . 号来表示：1. 第一项2. 第二项3. 第三项 显示为： 第一项 第二项 第三项 列表嵌套只需在子列表中的选项前面添加四个空格即可1. 第一项： - 第一项嵌套的第一个元素 - 第一项嵌套的第二个元素 显示为： 第一项： 第一项嵌套的第一个元素 第一项嵌套的第二个元素 链接和图片插入链接[链接名称](链接地址)或者&lt;链接地址&gt;链接名称或者https://avalooooooon.github.io/index 高级链接: 可以通过变量来设置一个链接，变量赋值在文档末尾进行：这个链接用 1 作为网址变量 [Google][1]: Google这个链接用avalon作为网址变量[mygithub][avalon]: mygithub然后在文档的结尾为变量赋值（网址） 插入图片可以是本地图片也可以是网络图片。格式：![alt 属性文本](图片地址 “可选标题”) Markdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 &lt;img&gt; 标签&lt;img src=”图片链接” width=”50%”&gt; 表格表格格式使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行| First Header | Second Header || ————- | ————- || Content Cell | Content Cell || Content Cell | Content Cell | First Header Second Header Content Cell Content Cell Content Cell Content Cell 对齐方式可以设置表格的对齐方式：-: 设置内容和标题栏居右对齐。:- 设置内容和标题栏居左对齐。:-: 设置内容和标题栏居中对齐。实例如下：| 左对齐 | 右对齐 | 居中对齐 || :—–| —-: | :—-: || 单元格 | 单元格 | 单元格 || 单元格 | 单元格 | 单元格 | 左对齐 右对齐 居中对齐 单元格 单元格 单元格 单元格 单元格 单元格 公式使用两个美元符$$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如：显示效果为：$$\\mathbf{V}_1 \\times \\mathbf{V}_2 = \\begin{vmatrix}\\mathbf{i} &amp; \\mathbf{j} &amp; \\mathbf{k} \\\\frac{\\partial X}{\\partial u} &amp; \\frac{\\partial Y}{\\partial u} &amp; 0 \\\\frac{\\partial X}{\\partial v} &amp; \\frac{\\partial Y}{\\partial v} &amp; 0 \\\\end{vmatrix}${$tep1}{\\style{visibility:hidden}{(x+1)(x+1)}}$$ 转义Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符：文本加粗** 正常显示星号 ** 使用HTML元素不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。目前支持的 HTML 元素有：&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;等 ，如：&lt;kbd&gt;Command&lt;/kbd&gt;+&lt;kbd&gt;C&lt;/kbd&gt; :使用 Command+C 组合键进行复制","categories":[],"tags":[]},{"title":"建站记录","slug":"建站记录","date":"2021-12-19T06:53:04.000Z","updated":"2022-01-08T17:11:29.536Z","comments":true,"path":"2021/12/19/建站记录/","link":"","permalink":"https://avalooooooon.github.io/2021/12/19/%E5%BB%BA%E7%AB%99%E8%AE%B0%E5%BD%95/","excerpt":"","text":"Part1 环境搭建安装nodejs12node -v npm -v #查看版本 安装git1git --version #查看版本 创建博客文件夹并安装hexo自己在想要的位置创建文件夹blog，在该文件夹中新建终端并运行以下命令： 12npm install -g hexo-clihexo -v 在Windows中，如果出现”‘hexo’不是内部或外部命令，也不是可运行的程序”，需要找到电脑中新安装的hexo的位置，并将hexo.cmd所在文件夹的路径添加到系统变量的PATH中。 可能出现的问题运行npm install -g hexo-cli时，可能提示没有权限。这里强烈建议不要用sudo方式强行获得权限。解决方法：第一步，赋予目录权限；第二步，安装hexo: 12sudo chown -R `whoami` /usr/local/lib/node_modules #这里不用改路径npm install hexo-cli -g 至此安装部分已经结束。下面对hexo进行初始化，给自己准备存放hexo主要内容的文件夹取一个名字（比如myblog），运行下列命令： 123hexo init myblogcd myblognpm install 可以看到，myblog目录下出现了：–node_modules: 依赖包–public：存放生成的页面–scaffolds：生成文章的一些模板–source：用来存放你的文章–themes：主题–_config.yml：博客的配置文件 运行下列命令打开hexo的服务，在浏览器输入localhost:4000就可以看到生成的博客了： 12hexo ghexo server 创建Github库并绑定SSH首先在自己的github下new一个和自己注册github时的用户名xxx同名的仓库，后面加.github.io。也就是新仓库的名字叫xxx.github.io。接下来生成SSH。依次运行下列命令： 12345git config --global user.name &quot;yourname&quot; #github用户名git config --global user.email &quot;youremail&quot; #github绑定的邮箱git config user.namegit config user.email #检查一下输对没有ssh-keygen -t rsa -C &quot;youremail&quot; #创建SSH，一路回车 找到～/.ssh文件夹。（Mac显示隐藏文件夹，同时按下三个组合键：Shift + Command + . ）在自己GitHub的setting中找到SSH keys，点击New SSH key。将id_rsa.pub里面的信息全部复制进去并保存。查看是否成功： 1ssh -T git@github.com 将hexo托管到个人Github先安装deploy-git ，也就是部署的命令，这样才能用命令部署到GitHub: 1npm install hexo-deployer-git --save 在myblog文件夹下打开站点配置文件*_config.yml*，翻到最后，修改为 1234deploy: type: git repo: git@github.com:xxx/xxx.github.io.git branch: master 准备就绪后, 123hexo clean #清除了之前生成的东西，也可以不加。hexo g #生成静态文章，hexo generate的缩写hexo d #部署文章，hexo deploy的缩写,,可与hexo g合并为 hexo d -g 过一会儿就可以在http://xxx.github.io 这个网站看到博客了。 写文章使用指令新建一篇文章： 1hexo new [layout] &lt;title&gt; 写完后，运行下列代码以部署更新。 123hexo cleanhexo ghexo d #可与hexo g合并为 hexo d -g 关于[layout]Hexo 有三种默认布局：post、page 和 draft，它们分别对应不同的路径。自己自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹。可以通过 publish 命令将草稿移动到 source/_posts 文件夹： 1hexo publish [layout] &lt;title&gt; 草稿默认是不会显示在页面中的，可在执行时加上 –draft 参数，或是把 render_drafts 参数设为 true来预览草稿。也可以编辑现有的layout，比如post的layout默认是hexo\\scaffolds\\post.md比如想添加categories（文章分类目录），以免每次手工输入，只需要修改这个文件添加一行，如下： 1234title: &#123; &#123; title &#125; &#125; #文章页面上的显示名称，可以任意修改，不会出现在URL中date: &#123; &#123; date &#125; &#125; #文章生成时间，一般不改，当然也可以任意修改categories: #文章分类目录，可以为空tags: #文章标签，可空，多标签请用格式[tag1,tag2,tag3]， 请注意，大括号与大括号之间多加了个空格，否则会被转义，不能正常显示。 注意，所有文件：后面都必须有个空格，不然会报错。 写作时可能用到的插件1.插入图片 12cd blog/myblog # 进入本地博客文件夹npm install https://github.com/CodeFalling/hexo-asset-image --save 接下来打开hexo的配置文件_config.yml，找到 post_asset_folder，把这个选项从false改成true。最后打开/node_modules/hexo-asset-image/index.js，将内容更换为下面的代码（参考了这篇博客)。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&#x27;use strict&#x27;;var cheerio = require(&#x27;cheerio&#x27;);// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) &#123; return str.split(m, i).join(m).length;&#125;var version = String(hexo.version).split(&#x27;.&#x27;);hexo.extend.filter.register(&#x27;after_post_render&#x27;, function(data)&#123; var config = hexo.config; if(config.post_asset_folder)&#123; var link = data.permalink; if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3) var beginPos = getPosition(link, &#x27;/&#x27;, 1) + 1; else var beginPos = getPosition(link, &#x27;/&#x27;, 3) + 1; // In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;. var endPos = link.lastIndexOf(&#x27;/&#x27;) + 1; link = link.substring(beginPos, endPos); var toprocess = [&#x27;excerpt&#x27;, &#x27;more&#x27;, &#x27;content&#x27;]; for(var i = 0; i &lt; toprocess.length; i++)&#123; var key = toprocess[i]; var $ = cheerio.load(data[key], &#123; ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false &#125;); $(&#x27;img&#x27;).each(function()&#123; if ($(this).attr(&#x27;src&#x27;))&#123; // For windows style path, we replace &#x27;\\&#x27; to &#x27;/&#x27;. var src = $(this).attr(&#x27;src&#x27;).replace(&#x27;\\\\&#x27;, &#x27;/&#x27;); if(!/http[s]*.*|\\/\\/.*/.test(src) &amp;&amp; !/^\\s*\\//.test(src)) &#123; // For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed. // In addition, to support multi-level local directory. var linkArray = link.split(&#x27;/&#x27;).filter(function(elem)&#123; return elem != &#x27;&#x27;; &#125;); var srcArray = src.split(&#x27;/&#x27;).filter(function(elem)&#123; return elem != &#x27;&#x27; &amp;&amp; elem != &#x27;.&#x27;; &#125;); if(srcArray.length &gt; 1) srcArray.shift(); src = srcArray.join(&#x27;/&#x27;); $(this).attr(&#x27;src&#x27;, config.root + link + src); console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+config.root + link + src); &#125; &#125;else&#123; console.info&amp;&amp;console.info(&quot;no src attr, skipped...&quot;); console.info&amp;&amp;console.info($(this)); &#125; &#125;); data[key] = $.html(); &#125; &#125;&#125;); 现在就可以插入图片了，比如hexo new post photo之后就在source/_posts生成photo.md文件和photo文件夹，我们把要插入的图片复制到photo文件夹内，在photo.md文件里面按markdown的标准写,（我的文件名是head.jpeg）比如 Part2 基本配置hexo基本配置——_config.yml在文件根目录下的_config.yml，就是整个hexo框架的配置文件了。可以在里面修改大部分的配置。详细可参考官方的配置描述。 网站参数 描述title 网站标题subtitle 网站副标题description 主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。author 用于主题显示文章的作者language 网站使用的语言timezone 网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。 网址参数 描述url 你的网站域名root 网站根目录permalink 文章的永久链接格式permalink_defaults 用于主题显示文章的作者 permalink，也就是你生成某个文章时的那个链接格式。比如我新建一个文章叫temp.md，那么这个时候他自动生成的地址就是http://yoursite.com/2018/09/05/temp。以下是官方给出的示例，关于链接的变量还有很多，需要的可以去官网上查找永久链接 。 参数 描述:year/:month/:day/:title/ 2013/07/14/hello-world:year-:month-:day-:title.html :year-:month-:day-:title.html:category/:title foo/bar/hello-world 再往下翻，中间这些都默认就好了。 12345678theme: landscape # Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: &lt;repository url&gt; branch: [branch] theme：主题名deploy：网站部署。repo就是仓库(Repository)的简写。branch选择仓库的哪个分支。这个在之前进行github page部署的时候已经修改过了，不再赘述。而这个在后面进行双平台部署的时候会再次用到。 Front-matterFront-matter 是文件最上方以 — 分隔的区域，用于指定个别文件的变量，举例来说： 123title: Hello Worlddate: 2013/7/13 20:46:25--- 下面是预先定义的参数，在模板中使用这些参数值并加以利用。参数 描述layout 布局title 标题date 建立日期updated 更新日期comments 开启文章的评论功能tags 标签（不适用于分页）。标签没有顺序和层次。categories 分类（不适用于分页）。具有顺序性和层次性，也就是说 Foo, Bar不等于 Bar, Foo。permalink 覆盖文章网址 Layout使用命令 1hexo new [layout] &lt;title&gt; 它默认使用的是post这个布局，也就是在source文件夹下的_post里面。Hexo 有三种默认布局：post、page 和 draft，它们分别对应不同的路径。自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹。 page如果想另起一页，那么可以使用 1hexo new page board draft如果想写文章，又不希望被看到，那么可以 1hexo new draft newpage 这样会在source/_draft中新建一个newpage.md文件。如果你的草稿文件写的过程中想要预览一下，那么可以使用 1hexo server --draft 在本地端口中开启服务预览。 如果你的草稿文件写完了，想要发表到post中， 1hexo publish draft newpage 就会自动把newpage.md发送到post中。 Part3 个性化官网上的主题们我用的是Volantis。在github下载并放到theme文件夹下，然后根目录下的_config.yml中把theme换成那个主题文件夹的名字，它就会自动在theme文件夹中搜索你配置的主题。volantis官方文档-主题配置进入volantis这个文件夹，可以看到里面也有一个配置文件_config.xml，这个配置文件是修改整个主题的配置文件。主题目录下的 _config.yml 文件通常负责主题相关配置，我们强烈建议您使用代替的主题配置文件以防止自己的配置丢失。如何操作呢–参见volantis官方文档-代替主题配置文件 。（以后补： default info cdn） menu其中，“关于”是找不到网页的，因为文章中没有about这个东西。如果想要的话，可以执行命令 1hexo new page about 它就会在根目录下source文件夹中新建一个about文件夹，以及index.md，在index.md中写上你想要写的东西，就可以在网站上展示出来了。如果你想要自己再自定义一个菜单栏的选项，那么就 1hexo new page yourdiy 然后在主题配置文件的menu菜单栏里按照其他菜单项的格式添加一个，注意把url改了且格式保持整齐（比如有时候直接回车会出错，要删掉多余的空间然后按空格键调整格式）。然后在languages文件夹中，找到zh-CN.yml，在index中添加yourdiy: ‘中文意思’就可以显示中文了。启用搜索功能用到的插件在主题的config.yml文件中，搜索search关键字，可以看到 12# To use hexo search, you need to install the following plugins:# npm i hexo-generator-json-content Part4 hexo附加功能评论系统在主题的config.yml文件中，搜索comment关键字，可以看到一些相关内容。 Part5 git分支进行多终端工作场景：现在在自己的笔记本上写的博客，部署在了网站上。那么在家里或者实验室的台式机，发现电脑里面没有博客的文件，或者要换电脑了，最后不知道怎么移动文件，怎么办？在这里我们就可以利用git的分支系统进行多终端工作了，这样每次打开不一样的电脑，只需要进行简单的配置和在github上把文件同步下来，就可以无缝操作了。 1 原理hexo本地文件夹中的public和.deploy.git文件夹存放的是根据.md生成的html文件，也就是博客的静态文件。对比GitHub上博客仓库的master分支也可以看到该分支的文件结构和这两个文件夹中的文件一致。也就是说，执行hexo d就是把public和.deploy.git文件夹下的文件同步到github。 我们之前在GitHub创建好的仓库默认只有master分支，这个分支存放的是静态文件。所以，可以在该仓库另外创建一个hexo分支以存放Hexo网站文件，这个分支的文件就是不同电脑需要同步的文件。 2 创建新分支在GitHub创建一个新分支hexo。该分支是由master拉取，所以其中的文件一开始和master是一样的。因为我们只需要手动管理Hexo网站文件，故可以把hexo分支设置为默认分支。这样操作后，当每次修改主题或者新增博文后，先将修改的主题文件（在themes文件夹中）或新增的博客（在source文件夹中)同步到远程仓库的hexo分支，然后再通过hexo d -g发布博文，也就是将新增的博文的静态页面同步到master分支，即可实现多台终端的同步管理。 注意！这里应进入username.github.io的settings-&gt;pages，确保是由master分支提交到了博客网站。可能会被系统变为hexo分支。 3 原主机操作：初始化分支在原主机安装了hexo的目录中，该目录包含所有博客文件，进行以下操作： git init，重新初始化仓库，对代码进行版本控制 git add - A， 添加本地所有文件到仓库 git commit -m “提交说明”，添加commit； git branch hexo，添加本地分支hexo git remote add origin &lt;server&gt;，添加远程仓库，&lt;server&gt;是在线仓库的地址 git push origin hexo，将本地仓库的源文件推送到远端hexo；此时博客的源文件就同步到github的hexo分支上了。 注意！如果当前使用的theme是使用git clone下载下来的话，由于git不能嵌套，会导致主题无法push到远程仓库，导致博客出现404页面。这种情况下，若是有自己fork的主题仓库，可以删除themes文件夹中的原主题文件夹，clone自己修改后的主题仓库地址到该文件夹。 4 新主机操作：同步分支在PC2上创建文件夹Blog，在Blog文件夹下面还行以下操作： git clone 仓库地址，把远端仓库的hexo分支clone到本地 cd yourname.github.io，切换到上一步clone的文件夹中 npm install，在clone下来的仓库文件夹中安装所需要的必要组件，不需要再init 5 发布博文后续不管是PC1还是PC2，如果修改了主题或者新增了博文，按照以下步骤即可： git pull origin hexo，先pull完成本地与远端的融合 hexo new post test.md，新建一个.md文件进行测试 git add source ，经测试只要更新source即可，因为只是修改了博客。如果修改的是主题文件，则更新theme文件夹 git commit -m “修改说明”，提交修改； git push origin hexo，更新至hexo分支； hexo d -g，将博文静态页面发布至maser分支。 参考链接原文链接：https://blog.csdn.net/sinat_37781304/article/details/82729029","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://avalooooooon.github.io/tags/hexo/"}]}],"categories":[],"tags":[{"name":"node","slug":"node","permalink":"https://avalooooooon.github.io/tags/node/"},{"name":"git","slug":"git","permalink":"https://avalooooooon.github.io/tags/git/"},{"name":"hexo","slug":"hexo","permalink":"https://avalooooooon.github.io/tags/hexo/"}]}