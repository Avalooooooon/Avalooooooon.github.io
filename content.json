{"meta":{"title":"一之碎片","subtitle":"「宠辱不惊 相由心生」","description":"前端 杂谈","author":"一之碎片","url":"https://avalooooooon.github.io","root":"/"},"pages":[],"posts":[{"title":"搭建L2TP-IPsec","slug":"搭建L2TP-IPsec","date":"2022-02-20T07:20:43.000Z","updated":"2022-02-20T07:20:43.000Z","comments":true,"path":"2022/02/20/搭建L2TP-IPsec/","link":"","permalink":"https://avalooooooon.github.io/2022/02/20/%E6%90%AD%E5%BB%BAL2TP-IPsec/","excerpt":"","text":"1. 前言虚拟专用网络（VPN，Virtual Private Network）是一种网络底层协议，主机开启 VPN 后，所有网络请求都会先发送到 VPN 服务器，然后 VPN 服务器作为代理帮我们访问敏感资源。本文介绍如何在 Linux（Ubuntu 18.04）服务器上搭建 L2TP/IPsec VPN。 2. IPSec互联网安全协议（IPsec，Internet Protocol Security）是 OSI 第三层的安全协议，工作分传输模式和隧道模式，传输模式为自己传输信息，隧道模式为给上层协议提供安全隧道。此处使用隧道模式给上层 VPN 协议提供安全隧道。软件使用开源的 libreswan。 安装： 1sudo apt-get install libreswan 验证安装成功： 1ipsec --version 新建软件配置文件： 1sudo vim /etc/ipsec.d/l2tp-ipsec.conf 写入： 1234567891011121314151617conn L2TP-PSK-NAT rightsubnet=vhost:%priv also=L2TP-PSK-noNATconn L2TP-PSK-noNAT authby=secret pfs=no auto=add keyingtries=3 rekey=no ikelifetime=8h keylife=1h type=transport left=&lt;服务器公网 IP&gt; leftprotoport=17/1701 right=%any rightprotoport=17/%any 新建预共享密钥文件： 1sudo vim /etc/ipsec.d/l2tp-ipsec.secrets 写入： 1&lt;服务器公网 IP&gt; %any : PSK &quot;&lt;IPSec 密钥&gt;&quot; 编辑系统配置文件： 1sudo vim /etc/sysctl.d/99-ipsec.conf 末尾添加： 12345678910net.ipv4.ip_forward = 1net.ipv4.conf.default.rp_filter = 0net.ipv4.conf.all.send_redirects = 0net.ipv4.conf.default.send_redirects = 0net.ipv4.conf.all.log_martians = 0net.ipv4.conf.default.log_martians = 0net.ipv4.conf.default.accept_source_route = 0net.ipv4.conf.all.accept_redirects = 0net.ipv4.conf.default.accept_redirects = 0net.ipv4.icmp_ignore_bogus_error_responses = 1 更新系统配置： 1sudo sysctl -p 试运行： 12sudo systemctl start ipsecipsec verify 可添加至开机启动： 1sudo systemctl enable ipsec 3. PPPL2TP 协议基于 PPP 协议，因此需先确保 PPP 协议正常运行。 安装： 1sudo apt-get install ppp 新建配置文件： 1sudo vim /etc/ppp/options.xl2tpd 写入： 1234567891011121314require-mschap-v2ms-dns 8.8.8.8ms-dns 8.8.4.4asyncmap 0authcrtsctslockhide-passwordmodemdebugname l2tpdproxyarplcp-echo-interval 30lcp-echo-failure 4 编辑 PPP 用户名及密码文件： 1sudo vim /etc/ppp/chap-secrets 末尾添加： 1&lt;用户名&gt; * &lt;密码&gt; * 4. L2TP第二层隧道协议（L2TP，Layer 2 Tunneling Protocol）顾名思义是一个OSI 第二层协议。软件使用开源的 xl2tpd。 安装： 1sudo apt-get install xl2tpd 编辑配置文件： 1sudo vim /etc/xl2tpd/xl2tpd.conf 末尾添加： 1234567891011[global]ipsec saref = yes[lns default]ip range = 10.1.2.2-10.1.2.254local ip = 10.1.2.1refuse chap = yesrefuse pap = yesrequire authentication = yesppp debug = yespppoptfile = /etc/ppp/options.xl2tpdlength bit = yes 试运行： 1sudo systemctl start xl2tpd 然后在用户机上尝试连接 VPN，协议选择 L2TP，密钥、用户名和密码分别为刚才设置的 IPSec 密钥、PPP 用户名和 PPP 密码。应该能够连接成功，但还不能访问互联网。 可添加至开机启动： 1sudo systemctl enable xl2tpd 查看l2tp日志： 1systemctl status xl2tpd 5. 系统防火墙使用系统自带的 iptables 软件管理系统防火墙。 向 iptables 缓存添加策略，在其 NAT 表的 POSTROUTING 链中设置 IP 伪装： 1sudo iptables -t nat -A POSTROUTING -s 10.1.2.0/24 -o eth0 -j MASQUERADE -m comment --comment &quot;xl2tp&quot; 将当前策略保存至配置文件，然后应用策略： 12sudo iptables-save &gt; /etc/network/iptablessudo iptables-apply -w /etc/network/iptables ptables-persistant netfilter-persistant然后netfilter-persistant save就能持久化 centos7:/etc/sysconfig/iptables 重启 xl2tpd 服务： 1sudo systemctl restart xl2tpd 此时用户机应该就能通过 VPN 访问互联网了。 可修改网络配置文件，使连接网络时自动加载 iptables 配置： 1sudo vim /etc/network/interfaces 末尾添加： 1pre-up iptables-restore &lt; /etc/network/iptables 6. 参考资料 centos7 搭建 xl2tpd 服务 Ubuntu iptables 配置","categories":[],"tags":[{"name":"vpn","slug":"vpn","permalink":"https://avalooooooon.github.io/tags/vpn/"}]},{"title":"OpenVPN","slug":"OpenVPN","date":"2022-02-20T06:10:04.000Z","updated":"2022-02-20T06:10:04.000Z","comments":true,"path":"2022/02/20/OpenVPN/","link":"","permalink":"https://avalooooooon.github.io/2022/02/20/OpenVPN/","excerpt":"","text":"简介 OpenVPN 是基于 TLS 加密层实现 VPN 的开源项目。 安装Linux 服务端(debian10)登录服务端：除了ssh方式，也可以通过用户名密码方式。参考了这篇文章。端口号可以在服务器后台查阅ssh server。 1ssh -p port user@IP 安装软件包（包含客户端与服务端）： 12sudo apt-get update &amp;&amp; sudo apt-get install openvpnopenvpn --version # 验证 生成自签 CA、服务器证书及额外所需密钥： 123456789101112131415161718192021222324252627282930313233343536373839404142434445cd /etc/openvpnsudo cat &lt;&lt;EOF | sudo tee openvpn.cnf[ v3_ca ]basicConstraints = critical, CA:TRUEsubjectKeyIdentifier = hashauthorityKeyIdentifier = keyid:always, issuer:alwayskeyUsage = critical, cRLSign, digitalSignature, keyCertSign[ v3_ica ]basicConstraints = critical, CA:TRUE, pathlen:1subjectKeyIdentifier = hashauthorityKeyIdentifier = keyid:always, issuer:alwayskeyUsage = critical, cRLSign, digitalSignature, keyCertSign[ v3_server ]basicConstraints = critical, CA:FALSEsubjectKeyIdentifier = hashauthorityKeyIdentifier = keyid:always, issuer:alwayskeyUsage = critical, nonRepudiation, digitalSignature, keyEncipherment, keyAgreement extendedKeyUsage = critical, serverAuth[ v3_client ]basicConstraints = critical, CA:FALSEsubjectKeyIdentifier = hashauthorityKeyIdentifier = keyid:always, issuer:alwayskeyUsage = critical, nonRepudiation, digitalSignature, keyEnciphermentextendedKeyUsage = critical, clientAuthEOFsudo openssl genrsa -out ca.key 4096sudo openssl rand -writerand ~/.rndsudo openssl req -new -key ca.key -subj &quot;/CN=US/ST=NewYork/L=New York City/O=DigitalOcean/OU=Community/CN=ca/emailAddress=admin@example.com&quot; -out ca.csrsudo openssl x509 -req -days 36500 -signkey ca.key -extfile openvpn.cnf -extensions v3_ca -in ca.csr -out ca.crtsudo rm ca.csrsudo openssl genrsa -out server.key 4096sudo openssl rand -writerand ~/.rndsudo openssl req -new -key server.key -subj &quot;/C=US/ST=NewYork/L=New York City/O=DigitalOcean/OU=Community/CN=server/emailAddress=admin@example.com&quot; -out server.csrsudo openssl x509 -req -days 36500 -CA ca.crt -CAkey ca.key -CAcreateserial -extfile openvpn.cnf -extensions v3_server -in server.csr -out server.crtsudo rm server.csrsudo openssl dhparam -out dh.key 2048 # 此步将耗时数分钟sudo openvpn --genkey --secret ta.key # 用于 OpenVPN TLS-auth 功能的密钥 从例子拷贝配置文件： 123cd /etc/openvpnsudo cp /usr/share/doc/openvpn/examples/sample-config-files/server.conf.gz .sudo gzip -d server.conf.gz 由于版本不同，server.conf的路径也可能不同。如果上述路径找不到server.conf文件，可以尝试路径/etc/openvpn/server/server.conf。比如openvpn版本为2.4.11时，可以将命令修改如下：cp -p /usr/share/doc/openvpn-2.4.11/sample/sample-config-files/server.conf /etc/openvpn/cat /etc/openvpn/server.conf 修改配置文件： 1vim server.conf 修改 port(默认为1194，可以出现问题再修改，但要和客户端保持一致）。 修改协议为 UDP。 检查 ca：ca.crt、cert：server.crt、key：server.key、dh：dh.key、tls-auth：ta.key相对于配置文件夹的相对路径（或绝对路径）。注意检查每种证书只在一行出现，否则后面的行会覆盖掉前面行的值(tls-auth：ta.key的位置较为靠后）。 注释掉explicit-exit-notify 1（该功能仅用于 UDP 模式）。 启动服务： 1sudo systemctl start openvpn@server 开启系统转发功能： 1234cat &lt;&lt;EOF | sudo tee /etc/sysctl.d/99-openvpn.confnet.ipv4.ip_forward = 1EOFsudo sysctl --system 配置 iptables 转发： 1sudo iptables -t nat -A POSTROUTING -s 10.8.0.0/24 -o eth0 -j MASQUERADE -m comment --comment &quot;openvpn&quot; 查看服务器日志： 1systemctl status openvpn@server Linux 客户端 安装软件包同服务端。 生成密钥文件client.key及证书请求文件client.csr： 1234cd /etc/openvpnsudo openssl genrsa -out client.key 4096sudo openssl rand -writerand ~/.rndsudo openssl req -new -key client.key -subj &quot;/C=US/ST=NewYork/L=New York City/O=DigitalOcean/OU=Community/CN=client/emailAddress=admin@example.com&quot; -out client.csr OpenVPN 服务器会将 CN 名作为多个客户端时的区分标志，客户端应各自使用不同的 CN 名。 将client.csr拷贝至 CA 端： 123cd /etc/openvpnrm client.csr vim client.csr 由 CA 端签发证书client.crt： 1sudo openssl x509 -req -days 36500 -CA ca.crt -CAkey ca.key -CAcreateserial -extfile openvpn.cnf -extensions v3_client -in client.csr -out client.crt 将client.crt及ca.crt、ta.key拷贝至客户端，直接复制文本内容即可： 123cat client.crtcat ca.crtcat ta.key CA 端可清除文件： 1sudo rm client.csr client.crt client 端可清除文件： 1sudo rm client.csr 复制配置文件： 12cd /etc/openvpnsudo cp /usr/share/doc/openvpn/examples/sample-config-files/client.conf . 修改配置文件： 修改 remote 为服务器地址及 port。 修改协议为 UDP！。 检查 ca：ca.crt、cert：client.crt、key：client.key、tls-auth：ta.key相对于配置文件夹的相对路径。 末尾添加：auth-nocache以避免在内存中缓存认证信息（否则会报 warning）。 末尾添加：redirect-gateway def1 bypass-dhcp，将系统默认路由网关改为 OpenVPN 虚拟对端网卡。 末尾添加：dhcp-option DNS 8.8.8.8，设置连接 OpenVPN 后使用的 DNS 服务器。 启动服务： 1sudo systemctl start openvpn@client ping VPN 网关进行测试： 1ping 10.8.0.1 Windows 客户端 去官网-&gt;Community-&gt;Downloads 下载 OpenVPN GUI 安装器并安装。 配置方法与 Linux 几乎一致。只是配置文件夹为%USERPROFILE%/OpenVPN/config，客户端配置模版文件为C:/Program Files/OpenVPN/sample-config/client.ovpn。 生成密钥文件client.key及证书请求文件client.csr： 1234cd C:\\Users\\28422\\OpenVPN\\configopenssl genrsa -out client.key 4096openssl rand -writerand .rnd # 配置文件夹就地新建.rnd随机数种子openssl req -new -key client.key -subj &quot;/C=US/ST=NewYork/L=New York City/O=DigitalOcean/OU=Community/CN=client2/emailAddress=admin@example.com&quot; -out client.csr # gitbash会报错，需要在powershell中运行 OpenVPN 服务器会将 CN 名作为多个客户端时的区分标志，客户端应各自使用不同的 CN 名。 将client.csr拷贝至 CA 端： 123cd /etc/openvpnrm client.csr vim client.csr 由 CA 端签发证书client.crt： 1sudo openssl x509 -req -days 36500 -CA ca.crt -CAkey ca.key -CAcreateserial -extfile openvpn.cnf -extensions v3_client -in client.csr -out client.crt 将client.crt及ca.crt、ta.key拷贝至客户端，直接复制文本内容即可： 123cat client.crtcat ca.crtcat ta.key CA 端可清除文件： 1sudo rm client.csr client.crt client 端可清除文件： 1rm client.csr 修改配置文件C:/Program Files/OpenVPN/sample-config/client.ovpn： 修改 remote 为服务器地址及 port。 修改协议为UDP。 检查 ca：ca.crt、cert：client.crt、key：client.key、tls-auth：ta.key相对于配置文件夹的相对路径。 末尾添加：auth-nocache以避免在内存中缓存认证信息（否则会报 warning）。 末尾添加：redirect-gateway def1 bypass-dhcp，将系统默认路由网关改为 OpenVPN 虚拟对端网卡。 末尾添加：dhcp-option DNS 8.8.8.8，设置连接 OpenVPN 后使用的 DNS 服务器。 在可视化界面中启动服务即可。 Mac 客户端 安装软件OpenVPN Connect。 生成密钥文件client.key及证书请求文件client.csr： 12345cd /Applicationscd &quot;OpenVPN Connect&quot;sudo openssl genrsa -out client.key 4096sudo openssl rand -out .rnd 1sudo openssl req -new -key client.key -subj &quot;/C=US/ST=NewYork/L=New York City/O=DigitalOcean/OU=Community/CN=client/emailAddress=admin@example.com&quot; -out client.csr OpenVPN 服务器会将 CN 名作为多个客户端时的区分标志，客户端应各自使用不同的 CN 名。 将client.csr拷贝至 CA 端： 123cd /etc/openvpnrm client.csr vim client.csr 由 CA 端签发证书client.crt： 1sudo openssl x509 -req -days 36500 -CA ca.crt -CAkey ca.key -CAcreateserial -extfile openvpn.cnf -extensions v3_client -in client.csr -out client.crt 将client.crt及ca.crt、ta.key拷贝至客户端，直接复制文本内容即可： 123cat client.crtcat ca.crtcat ta.key CA 端可清除文件： 1sudo rm client.csr client.crt client 端可清除文件： 1sudo rm client.csr 修改配置文件client.ovpn： 修改 remote 为服务器地址及 port。 修改协议为 UDP。 检查 ca：ca.crt、cert：client.crt、key：client.key、tls-auth：ta.key相对于配置文件夹的相对路径。 末尾添加：auth-nocache以避免在内存中缓存认证信息（否则会报 warning）。 末尾添加：redirect-gateway def1 bypass-dhcp，将系统默认路由网关改为 OpenVPN 虚拟对端网卡。 末尾添加：dhcp-option DNS 8.8.8.8，设置连接 OpenVPN 后使用的 DNS 服务器。 在OpenVPN Connect启动服务。 使用系统服务开机自启 开机自启脚本/etc/init.d/openvpn会扫描/etc/openvpn/xxx.conf并为每个配置文件启动一个同名的 openvpn@xxx 系统服务。可编辑/etc/default/openvpn文件的 AUTOSTART 项，选择性地开启配置自启。 客户端 IP 分配 服务端配置文件的 ifconfig-pool-persist 项设置了客户端 IP 持久化记录文件，默认为/var/log/openvpn/ipp.txt，但此文件仅用于 OpenVPN 自己回写动态分配给各客户端的 IP，并不应通过该文件配置。正确方法是为服务端配置文件添加 client-config-dir ccd，然后新建/etc/openvpn/ccd客户端静态 IP 配置文件夹，在其中新建以客户端 CN 命名的配置文件。 12345cd /etc/openvpnsudo mkdir ccdsudo cat &lt;&lt;EOF | sudo tee ccd/clientifconfig-push 10.8.0.5 10.8.0.6EOF 其中 ifconfig-push 第一个参数为分配给客户端的 IP，第二个参数为隧道对端 IP。为了与 Windows 客户端的 TAP-Windows 驱动兼容，两 IP 应位于统一/30子网，且各客户端应分属不同/30子网，例如此处 IP 为10.8.0.5 10.8.0.6，下个客户端 IP 就至少为10.8.0.9 10.8.0.10。 客户端互访 注释掉服务端配置文件的 client-to-client，即可实现连接到同一 OpenVPN 服务端的客户端通过 VPN IP 互访。 参考资料 OpenVPN 官网 OpenSSL 添加 x509 扩展 OpenVPN KeyUsage 扩展 https://superuser.com/questions/738612/openssl-ca-keyusage-extension/)","categories":[],"tags":[{"name":"vpn","slug":"vpn","permalink":"https://avalooooooon.github.io/tags/vpn/"}]},{"title":"JS笔记","slug":"JS笔记","date":"2022-01-17T11:45:34.000Z","updated":"2022-01-17T11:45:34.000Z","comments":true,"path":"2022/01/17/JS笔记/","link":"","permalink":"https://avalooooooon.github.io/2022/01/17/JS%E7%AC%94%E8%AE%B0/","excerpt":"","text":"Chrome内运行 开发者工具-&gt;Console 窗口调试 JavaScript 代码 开发者工具-&gt;Sources-&gt;Snippets选项卡-&gt; Creat new snippet 来新建一个脚本文件 JS没有任何打印或者输出的函数，只能：使用 window.alert() 弹出警告框；document.write() 方法将内容写到 HTML 文档中；innerHTML 写入到 HTML 元素； console.log() 写入到浏览器的控制台。 使用 document.getElementById(id) 方法：使用 “id” 属性来标识/查找 HTML 元素，并 innerHTML 来获取或插入元素内容，下面例子里id1234567891011```document.getElementById(&quot;demo&quot;).innerHTML = &quot;段落已修改。&quot;;``````javascriptconsole.time(&quot;计时器的名字&quot;);console.timeEnd(&quot;计时器的名字&quot;); console.log();document.write(); // 实际上是通过超文本标记语言(html)输出。比如想换行，document.write(1+&quot;\\n&quot;)不行，document.write(1+&quot;&lt;br /&gt;&quot;)才行。var year = prompt(&quot;请输入年份&quot;); //prompt()：弹出一个带文本框的提示框,需要字符串做参数做为提示文字。注意返回类型为String。Math.sqrt(i); //开方 数据类型基本数据类型：String Number Boolean Null Undefined引用数据类型：Object 主要区别：基本数据类型在栈中保存的是值，引用数据类型在栈中保存的是地址。 使用typeof a查看a的数据类型。转义字符：\\。\\n :换行 \\t:制表符 \\\\:斜杠“\\”。 在字符串中使用转义字符输出Unicode编码：\\u四位编码，如console.log(&quot;\\u2620&quot;)。注意这里的四位编码是16进制。在网页中使用Unicode编码：&amp;#十进制编码，如&lt;p&gt;&amp;#9760;&lt;/p&gt;。 String：双引号和单引号都行，但不要混用；可以使用\\作为转义字符 引号需要成对出现，不能嵌套！ Number：包括整数和浮点数。 NaN：特殊的数字，表示Not a Number Number.MAX_VALUE：最大数。比它大就是Infinity，都是字面量。 Number.MIN_VALUE：最小正数。 运算：整数基本保证精确。浮点元素运算可能不精确。 千万别用JS进行对精确度要求高的运算！ Boolean Null：专门表示一个为空的对象。使用typeof检查时返回object。 Undefined：声明了但没赋值的变量。使用typeof检查时返回undefined。 强制类型转换类型转换主要指将其他数据类型转换为String Number Boolean。 转换为String： 调用被转换数据类型的toString()方法：a = a.toString()。null和undefined没有toString()方法。 调用String()函数：a = String(a)。 toString()方法和String()函数都不会影响原变量，返回的只是转换结果。 转换为Number： Number()函数：a = Number(a)。字符串类型有非数字的转为NaN，空串或者全是空格转为0。Undefined类型、object类型结果为NaN。Null类型结果为0。 局限：对于a = 123px，想要进行a + 10这类情景不友好。 一种专门解决字符串的方法函数parseInt()：将一个字符串中的 有效 整数拿出。可以用来取整。函数parseFloat()：将一个字符串中的 有效 小数拿出。如果是非String，会转换成string再处理。 可以在parseInt()中传递第二个参数指定进制：parseInt(a,10) 转换为Boolean：Boolean()函数 数字：除了0和NaN都是true；字符串：除了空串都是true；null和undefined都是false 总之，除了0、-0、NaN、‘’、null和Undefined都为true。 可以对任意数据类型取反两次转换为Boolean:a = !!a。!!是一种强制类型转换，作用为把变量转换成“等价”的布尔值。 引用数据类型 栈内存和堆内存 栈内存：JS中的变量都保存到栈内存，基本数据类型的值直接在栈内存中存储。值与值之间独立存在，修改一个变量不会影响其他变量。 堆内存：JS中的对象都保存到堆内存，每创建一个新的对象就会在堆内存中创建一个新的空间。这种情况下变量保存的是对象的内存地址（对象的引用）。如果两个变量保存的是同一个对象引用，则当一个通过一个变量修改属性时，另一个也会受到影响。如果直接修改变量的值，比如obj2 = null，那么obj不受影响。 当比较两个基本数据类型的值时，就是比较值；但两个引用数据类型比较的是对象的内存地址。 作用域全局作用域全局作用域在页面打开时创建，在页面关闭时销毁。直接编写在script标签中的JS代码都在全局作用域。全局作用域中有一个全局对象window，它由浏览器创建，代表浏览器窗口，我们可以直接使用。全局作用域中创建的变量都会作为window对象的属性保存，创建的函数都会作为window对象的方法保存。全局作用域中的变量都是全局变量，在页面的任意部分都可以访问到。 函数作用域调用函数时创建函数作用域，函数执行完毕以后函数作用域销毁。每调用一次函数就会创建一个新的函数作用域，他们之间互相独立。当在函数作用域操作变量时，会优先在自身作用域中寻找，如果有就直接使用。如果自身作用域没有，按照就近原则使用上级作用域中的同名变量。如果全局作用域中依然没有就会报错。要在函数中精确访问全局变量可以使用window对象。 定义形参就相当于在函数作用域中声明了变量。函数中定义形参a就相当于var一个a。 在函数中，不使用var声明的变量都会成为全局变量！前提是这个函数先被调用了。 变量和函数的声明提前（提升）变量的声明提前：使用var关键字声明的变量，会在所有代码执行之前被声明（但不会赋值，使用的时候再复制），也就是预编译先找到var a，让变量a=undefined。但如果声明变量不是用的var关键字，则变量就不会被声明提前。 函数的声明提前：使用函数声明形式创建的函数function 函数()&#123;&#125;会在所有的代码执行之前就被创建，所以我们可以在函数声明前就调用函数。这样的函数声明写在哪里都一样。但使用函数表达式创建的函数var 函数名 = function()&#123;&#125;不会被声明提前，所以不能在声明前调用。因为根据变量的声明提前原理，由于使用了var关键字，所以函数名被赋值为undefined，只有在使用时才会被赋予具体值。 在函数作用域中也有声明提前的特性，使用var关键字声明的变量会在函数中所有代码执行之前被声明。使用函数声明形式创建的函数也会在函数中所有的代码执行之前执行。 this解释器在调用函数每次都会向函数内部传递一个隐含参数，这个隐含的参数就是this。this指向的是一个对象，该对象称为函数执行的上下文对象。根据函数 调用方式 的不同，this会指向不同的对象： 以函数形式调用时，this永远都是window 以方法形式调用时，this就是调用方法的对象 以构造函数形式调用时，this就是新创建的对象 在事件的响应函数中，响应函数是给谁绑定的this就是谁 总之就是this指向当前调用函数的对象。 运算任何数和NaN运算的结果都是NaN。除拼串，对任何非Number的值会转换成Number。 算术运算 +：对几个字符串使用是拼串操作。var a = &quot;123&quot;+&quot;456&quot;，结果为123456。事实上，任何值和字符串相加都会转换成字符串并进行拼串操作。 隐式类型转换：可以利用这一特点将一个任意数据类型转换为String，只需要任意的数据类型 + 一个””即可：a = a + &#39;&#39;。 - * /：除了“ + ”的其他运算符号（- * /），在算式中出现的变量都会转化成数字再计算。 隐式类型转换：可以利用这一特点将一个任意数据类型转换为Number，只需要任意的数据类型 -0;*1;/1即可。原理和Number()一样，使用更简单。 一元运算符：全换为Number类型再运算。+ -, 正号” + “不会对数字产生任何影响, 负号“-”可以对数字进行符号取反。 隐式类型转换：可以利用这一特点将一个任意数据类型转换为Number，只需要任意的数据类型 a = +a即可。如a = 1 + +a + 2。 逻辑运算JS中的&amp;&amp; 和 || 是短路与/或而不是逻辑与/或。对于非布尔值：会先将其转换为布尔值再运算，并且 返回原值 。 &amp;&amp;：两值运算，若第一个为true，返回第二个值；第一个为false，直接返回第一个值。 ||：两值运算，若第一个为true，直接返回第一个值；第一个为false，返回第二个值。 == 和 !=：（不）相等运算。若两个值类型不同，会转化成相同类型再比较，大部分情况是转化为数字。 Undefined衍生自null，所以这两个值作相等判断时会返回true NaN不和包括它本身任何值相等。可以通过isNaN()函数判断一个值是否为NaN。 === 和 !==：（不）全等运算。和相等的区别在于它不会做类型转换。若类型不同直接返回。 ###关系运算指&gt; &gt;= &lt; &lt;= =。会转化成数字再比较。任何值和NaN比较都是false。 若比较符号的两侧都是字符串，不会转换为数字，而会分别比较字符串中的 Unicode编码，一位一位比较，两位一样就比下一位。如果比较两个字符类型的数字时，可能得到不可预期的结果。所以比较两个字符串类型的数字时，一定要转型。可以利用该特性对英文排序。 条件运算123456789101112131415161718192021222324252627282930若条件表达式的结果是非布尔值，会将其转化为布尔值再运算。## 函数和代码块调用函数时 **解释器不会检查实参的类型** ，实参可以是任意数据类型。所以要注意如果有可能接收到非法的参数就需要对参数进行类型检查。同样， **解释器不会检查实参的数量** ，多余实参不会被赋值，如果实参数量少，则没有对应实参的形参将是undefined。### 普通函数和箭头函数```data:function()&#123;&#125;```和 ```data:()=&gt;&#123;&#125;```。一般在对象里写方式会删掉function，删掉冒号：```data()&#123;&#125;```区别：箭头函数没有自己的this，只会向外找，找到的是window。### 函数中的**return**在函数中，```return```后可以跟任意类型的值。```return```后的语句都不会执行；如果```return```语句后不跟任何值或者函数中不写```return```就相当于返回一个undefined。&gt; 注意```my fun()```和```fun```的区别：&gt; ```my fun()```：是调用函数，相当于使用了函数 **返回值** &gt;```myfun```：是函数对象，相当于直接使用了函数 **对象** ### 函数声明、立即执行函数和代码块使用**函数声明**或**函数表达式**来创建函数：```javascript// 函数声明function 函数名(形参1,形参2,...,形参n)&#123; 语句...&#125;// 函数表达式：创建一个匿名函数,再将这个匿名函数对象赋值给一个变量// 此时，语句本质上是一个赋值语句，因此最好在末尾加分号。var 函数名 = function(形参1,形参2,...,形参n)&#123; 语句...&#125;; 使用 立即执行函数 使函数定义完立即被调用。立即执行函数往往只会执行一次。 12345(function(a,b)&#123; // 如果外围不加括号，解释器会将大括号中的内容识别为一个代码块而无视前面的声明 console.log(&quot;a=&quot; + a); console.log(&quot;b=&quot; + b);&#125;)(123,456) 一个&#123;&#125;中的内容称为一个代码块，一个代码块中的内容要么都执行，要么都不执行。 JS中的代码块 只有分组作用！块中的内容块外也完全可见，并不隔离。 条件判断/条件分支/switch/for语句12345678910111213141516171819202122// if语句if(条件表达式)&#123; 语句... &#125;else if&#123; 语句... &#125;else&#123; 语句... &#125;// switch语句。依次将case后的表达式和switch后的条件表达式进行全等比较。switch(条件表达式)&#123; case 表达式； 语句... break; default: 语句... break;&#125;// while。判断一次执行一次。可以使用break终止循环。while(条件表达式)&#123; 语句... &#125;// do...while。执行一次判断一次。也就是while先判断再执行，do...while先执行再判断。do...while可以保证循环体至少执行一次。do&#123; 语句... &#125;while(条件表达式)// for语句。for(初始化表达式；条件表达式；更新表达式)&#123; &#125; break和continue（和return）可以为循环语句加上一个label标识当前循环。比如创建一个label为outer的循环：outer:循环语句 break outer：结束循环。立即终止label=outer的循环。默认终止本 层 循环。 只能对循环和switch语句使用! continue outer：跳过当 次 循环，继续下一次循环。其它和break一样。 return：结束整个函数。 函数的方法：call()和apply()——修改函数对象的this这两个方法都是函数对象的方法，需要通过函数对象（不加()）来调用。当对函数调用call()和apply()时都会使函数执行。在调用call()和apply()时，可以将一个对象指定为第一个参数，此时这个对象将会成为函数执行时的this。 call()方法可以将实参在对象后依次传递：fun.call(obj,3,4) // a=3，b=4apply()方法需要将实参封装到一个数组中统一传递：fun.apply(obj,[3,4]) // a=3，b=4 arguments在调用函数时，浏览器每次都会传递进两个隐含的参数：函数的上下文对象this和封装 实参 的对象arguments。arguments是一个类数组对象，它也可以通过索引来操作数据，也可以获取长度。在调用函数时我们传递的实参都会在arguments中保存，arguments.length可以用来获取实参的长度。即使不定义形参也可以通过arguments来使用实参，只不过比较麻烦；arguments[0]表示第一个实参，以此类推。 不管定不定义形参，实参都会在arguments中保存！ 123456function fun()&#123; console.log(arguments); // [object arguments] // 是类数组对象，不是数组对象 console.log(arguments instanceof Array); // false console.log(Array.isArray(arguments)); // false&#125; 12345678910111213141516171819202122## 数组也是对象，不同的是普通对象使用字符串作为属性名，数组使用数字作为索引操作元素。数组的存储性能比普通对象好，在开发中经常使用数组来存储一些数据。```javascript// 可以在创建时就指定数组中的元素。使用```typeof```检查数组时返回object。// 创建数组对象————使用构造函数和使用字面量创建数组：var arr = new Array(1,20,30); // 只传一个正整数时创建的是长度为指定值的空数组。var arr1 = [1，2，3，10]; // 常用// 向数组中添加元素。语法：数组[索引] = 值// 读取数组中的元素：数组[索引]。如果读取不存在的索引返回undefined。arr[0]=10;// 获取数组长度。对于连续数组返回元素个数，非连续数组返回最大索引 + 1。console.log(arr.length);// 修改length。修改的length大于原长，多出的部分会空出来；小于时多出的元素会被删除。arr.length = 5;// 技巧：向数组的最后添加元素arr[arr.length] = 66; 数组的遍历通常都是用for循环。 JS还提供了一个方法：forEach()。需要注意该方法只支持IE8以上的浏览器。forEach()方法需要一个函数作为参数，通常不会为了它去专门创建一个全局变量，而是使用匿名函数（像这种函数，由我们创建但不是由我们调用的，称为回调函数。）。 数组中有几个元素就会执行几次，每次执行时浏览器会将遍历到的元素以实参的形式传递进来，我们可以定义形参来读取这些内容。浏览器会在回调函数中传递三个参数：第一个是当前正在遍历的元素，第二个是当前正在遍历的元素的索引，第三个是当前正在遍历的数组。 1arr.forEach(function(value,index,obj)&#123; &#125;) 增减开头/末尾元素：push()和pop() unshift()和shift()push()方法向数组的末尾添加一个或多个元素，可以将要添加的元素作为方法的参数传递，这样这些元素将会自动添加到数组的末尾。同时将新数组的长度作为返回值返回。pop()方法删除数组的最后一个元素，同时将被删除的元素作为返回值返回。 unshift()方法向数组开头添加一个或多个元素，同时将新数组的长度作为返回值返回。向前面插入元素后，其他元素的索引会依次调整。shift()方法删除数组的第一个元素，同时将被删除的元素作为返回值返回。 提取元素：slice() splice()slice()方法用来从数组中提取指定元素。该方法不会改变原数组，而是将截取到的元素封装到一个新数组中返回。参数：1.截取开始的位置的索引；2.截取结束的位置的索引（左闭右开）。索引可以传递一个负值，表示从后往前计算（-1是倒数第一个，-2倒数第二个）。第二个参数可以省略不写，此时会截取从开始索引往后的所有元素。 splice()用来从数组中删除（并替换/插入）指定元素。该方法会改变原数组：将指定元素从原数组中删除，并将被删除的元素作为返回值返回。参数：1.截取开始的位置的索引（包含）；2.删除的数量；3.第三个及以后的参数可以传递新元素，将它们按顺序插入到开始位置索引的前面。 连接数组：concat()concat()方法用来连接两个或多个数组，该方法不会影响原数组，并将新数组返回。 转换为字符串：join()join()方法用来将数组转换为一个字符串，该方法不会影响原数组，并将转换后的字符串作为结果返回。可以指定一个字符串作为参数，这个字符串将会成为数组中元素的连接符。如果不指定则默认使用逗号作为连接符。 反转数组：reverse()reverse()方法用来反转数组，该方法会直接修改原数组。 排序：sort()sort()方法用来对数组中的元素进行排序，该方法会直接修改原数组。默认按照Unicode编码进行排序。即使对纯数字数组，sort()方法也会按照Unicode编码进行排序。所以对数字排序时可能会得到错误结果。 浏览器不同可能导致结果相反 可以在sort()中添加一个回调函数指定排序规则。回调函数需要定义两个形参，浏览器将会分别使用数组中的元素作为实参去调用回调函数，使用哪个元素调用不确定，但肯定的是在数组中a一定在b前面，浏览器会根据回调函数的返回值决定元素的顺序，如果返回一个大于0的值，则元素会交换位置；返回一个小于或等于零的值，元素位置不变。如果需要升序排列，返回a-b；如果需要降序排列，返回b-a。 1arr.sort(function(a,b)&#123; return a-b;&#125;) // 升序排列 对象 内建对象：由ES标准中定义的对象。在任何ES的实现中均可使用。如Math String Number Boolean Function Object 宿主对象：由JS的运行环境提供的对象。主要指由浏览器创造的对象。如BOM（浏览器对象模型） DOM（文档对象模型）。console、document也属于这一类。 自建对象：由开发人员自己创建。 属性名和属性值是名值对。名与值之间使用 : 连接，多个名值对之间使用 , 隔开。对象中的最后一个属性之后不要写 ‘, ’。读取对象中的属性值可以使用对象.属性名的方式。 读取对象中没有的属性，不会报错而是会返回undefined。如果使用了特殊的属性名，需要用对象[&quot;属性名&quot;] = 属性值的方式操作。中括号[ ]的特点就是可以传递一个变量。 使用[ ]操作对象更加灵活。在[ ]中可以直接传递一个变量，这样变量值是多少，就会读取变量值那个属性： n 1234567891011121314+ 删除属性：```delete 对象.属性名```。 + 使用```in```检查对象中是否含有某个属性时，如果对象中没有但原型中有，也会返回true。+ 可以使用对象的```hasOwnProperty()```方法检查对象自身中是否含有该属性，只有当对象自身含有属性时才会返回true。### 方法如果一个函数作为一个对象的属性保存，我们称这个函数为对象的**方法**。使用```for ... in```语句枚举对象中的属性。对象中有几个属性循环体就执行几次。每次执行时，会将对象中的一个属性的 **名字** 赋值给变量。语法：```for(变量 in 对象)&#123;&#125;```。```javascriptfor(var n in obj)&#123; console.log(“属性名” + n); // 属性名：name 属性名：age console.log(“属性值” + obj[n]); // 属性值：Bob 属性值：18&#125; 使用工厂方法创建对象：可以大批量地创建对象，尤其是具有相同属性名、不同属性值的。1234567891011121314function createPerson(name,age,gender)&#123; // 创建一个新的对象 var obj = new Object(); // 向对象中添加属性 obj.name = name; obj.age = age; obj.gender = gender; obj.sayName = function()&#123; alert(this.name); &#125;; // 将新的对象返回 return obj;&#125;var obj2 = createPerson(&quot;张三&quot;，18，“男”)； 构造函数使用工厂方法创造的对象使用的构造函数都是Object，所以创建的对象都是Object这个类型，导致无法区分多种不同类型的对象。 构造函数就是一个普通函数，创建方式和普通函数一样，不同的是构造函数习惯首字母大写。构造函数和普通函数的区别：调用方式不同。普通函数是直接调用，而构造函数需要使用new关键字调用。 使用同一个构造函数创建对象称为一类对象，也将一个构造函数称为一个类。将通过同一个构造函数创建的对象称为该类的实例。使用instanceof可以检查一个对象是否是一个类的实例，语法：对象 instanceof 构造函数。如果是，返回true，否则返回false。 所有对象都是Object的后代，因此任何对象和Object做instanceof检查时都会返回true。 12345678910function Person(name,age)&#123; this.name = name; this.age = age; this.sayName = function()&#123; alert(this.name); &#125;&#125;var per = new Person(&quot;Bob&quot;,18);per.sayName();console.log(per.sayName); 构造函数的执行流程： 立刻 创建一个新的函数对象。一出现new，就会在堆内存开辟出一个新的内存空间。这片空间保存Person()函数中的内容。 将新建的对象设置为构造函数中的this。在构造函数中可以使用this来引用新建的对象。也就是新开辟出的堆内存空间的地址赋值给变量per，this保存着per的地址，指向per这块对象内存。(this 是保存在栈中的, 执行构造函数的时候, this也保存了那片区域的地址) 逐行执行函数中的代码。（只有这一步是我们写的，其他都是浏览器干的） 将新建的对象作为返回值返回。 垃圾回收（Garbage Collection，GC）当一个对象没有任何的变量或属性对它进行引用，将永远无法操作该对象，这种对象就是垃圾，存在过多会占用大量的内存空间，必须进行清理。 JS中有自动的垃圾回收机制，会自动将这些垃圾对象从内存中销毁，我们不需要也不能进行垃圾回收的操作。我们需要做的只是要将不再使用的对象设置为null。 原型对象在上面的Person()构造函数中为每一个对象都添加了一个sayName方法，而且这个方法是在构造函数内部创建的，也就是构造函数每执行一次就会创建一个新的sayName方法，（说到底每次执行构造函数在堆空间中开辟的内存都不同），也就是所有实例的sayName都是唯一的。如果像这样将sayName方法在全局作用域中定义（这里叫它fun）：function fun()&#123;alert(this.name);&#125;，则会污染全局作用域的命名空间，而且定义在全局作用域中也很不安全。 显式原型prototype和隐式原型__proto__显式原型：我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype（例外：通过Function.prototype.bind方法构造出来的函数没有prototype属性）。这个属性指向函数的原型对象。其主要作用是实现基于原型的继承与属性的共享。隐式原型：可以通过__proto__（两边都是两个下划线）访问对象的内置属性prototype。其主要作用是构成原型链，同样用于实现基于原型的继承。比如访问obj对象中的x属性时，如果在obj中找不到就会沿着__proto__依次查找。__proto__指向创建这个对象的函数的显式原型。显式原型prototype和隐式原型__proto__的区别在于，prototype是构造函数的属性，而__proto__是对象的属性。 如果函数作为普通函数调用，prototype没有任何作用；当函数以构造函数的形式调用时，它所创建的对象中都有一个隐含的属性指向该构造函数的原型对象。也就是构造函数.prototype == 所有该构造函数的实例._proto_。 原型对象就相当于一个公共的区域，所有一个类的实例都可以访问到这个原型对象。我们可以将对象中共有的内容统一设置到原型对象中。当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果没有则会去原型对象中寻找，找到了就直接使用。 以后我们创建构造函数时可以将这些对象共有的属性和方法统一添加到构造函数的原型对象中，这样不用为每一个对象添加，也不会影响到全局作用域，就可以使每个对象都具有这些属性和方法了。 123456789// 向Person的原型中添加属性aPerson.prototype.a = 123;// 向Person的原型中添加一个方法Person.prototype.sayName = function()&#123; alert(this.name);&#125;var per = new Person(&quot;Bob&quot;,18)per.sayName(); 原型对象的原型原型对象也是对象，所以它也有原型。当我们使用一个对象的属性或方法时，会先在自身中寻找，自身中如果有，则直接使用；如果没有则去原型对象中寻找，如果原型对象中有，则使用；如果没有则去原型的原型中寻找。直到找到Object对象的原型——Object对象的原型没有原型，但它也有一个__proto__属性，这个属性对应的值就是null。如果在Object中依然没有找到，则该对象.属性返回undefined。（null是没找到原型，undefined是没找到原型的属性） 123456789// 原型。实例._proto_=构造函数.prototype，即Person的prototypeconsole.log(per.__proto__);// 原型的原型。Person.prototype的_proto_，是Object的prototypeconsole.log(per.__proto__.__proto__); //[Object Object]console.log(per.__proto__.__proto__.hasOwnProperty(&quot;hasOwnProperty&quot;)); //true// 原型的原型的原型。Object的原型没有原型。console.log(per.__proto__.__proto__.__proto__); // null toString()当我们直接在页面中打印一个对象时（console.log)，实际上是输出的对象的toString()方法的返回值。如果我们希望在输出对象时不输出[Object Object]，可以为对象（或原型）添加一个toString()方法。 把prototype写在构造方法前面才能覆盖toString()方法！ 123456789// 它们的输出都是[Object Object]（除了Chrome）console.log(per);console.log(per.toString());// 修改per对象原型的toStringPerson.prototype.toString = function()&#123; return &quot;Person[name=&quot; + this.name + &quot;,age=&quot; + this.gender + &quot;]&quot;;&#125;console.log(per); // 现在的输出是&quot;Person[name=Bob,age=18]&quot; Date对象使用var d = new Date()创建Date对象。如果直接使用构造函数创建一个Date对象，则会封装为当前代码执行的时间使用var d2 = new Date(月/日/年 时：分：秒)创建指定时间的Date对象。需要在构造函数中传递一个表示时间的字符串作为参数。 getdate()，getday()，getmonth()，getFullyear()使用getdate()获取当前日期对象的日是多少，getFullyear()同理。getday()获取当前日期对象是周几。getmonth()获取当前日期对象的月份，返回一个0-11的值，0表示一月。 时间戳：getTime()和Date.now()使用getTime()获取当前日期对象的时间戳，即从格林威治标准时间的1970年1月1日0时0分0秒到当前日期所花费的毫秒数。 时区不同，计算结果也不同。在CN，1970年1月1日0时0分0秒的时间戳并不为0。计算机底层在保存时间时使用的都是时间戳。 使用Date.now()获取当前时间的时间戳。 Math对象Math和其他的对象不同，它不是一个构造函数！它属于工具类，不用创建对象，它里面封装了数学运算相关的属性和方法。 123456789Math.ceil() // 向上取整Math.floor() // 向下取整Math.round() // 四舍五入取整Math.random() // 生成[0，1)的随机数，可以乘x生成[0，x)的随机数Math.round(Math.random()*(y-x)+x) // 生成[x，y )的随机数Math.pow(x,y) // 返回x的y次幂Math.sqrt() // 返回平方根 包装类JS中提供了三个包装类，可以将基本数据类型的数据转换为对象。 String()：可以将基本数据类型的字符串转换为String对象 Number()：可以将基本数据类型的字符串转换为Number对象 Boolean()：可以将基本数据类型的字符串转换为Boolean对象 但是注意，实际应用中不会使用基本数据类型的对象（如var num = new Number(3)），因为使用它们可能在比较时带来不可预期的结果。 方法和属性只能添加给对象，不能添加给基本数据类型。但var s = 10;s = s.toString();s.hello = &quot;11&quot;不会报错，原因在于当我们对一些基本数据类型的值去调用属性和方法时，浏览器会临时使用包装类将其转换为对象，再调用对象的属性和方法。调用完后还是基本数据类型。 String对象的相关方法字符串在底层是以字符数组的形式保存的。比如它也有length属性，可以用来获取字符串的长度。 除非特殊说明，字符串的大部分方法都不会改变原字符串。 charAt()：根据索引返回字符串中指定位置的字符。作用同中括号[ ]。 charCodeAt()：获取指定位置字符的Unicode编码。 formCharCodeAt()：根据字符编码去获取字符。需要用构造函数去调用：String.formCharCodeAt()。 concat()：连接两个或多个字符串，作用同加号。 indexOf()：检索一个字符串中是否含有指定内容。如果含有该内容，会将其第一次出现的索引作为返回值返回。如果没找到则返回-1。可以指定第二个参数指定开始查找的位置。 lastIndexOf()：用法同上，不同的是上一个从前往后，这个从后往前找。返回最后出现的下标。也可以指定开始查找的位置。 slice()：从字符串截取指定内容并将截取到的内容返回。第一个参数是开始位置的索引，第二个是结束位置的索引，左闭右开。省略第二个参数就会截取后面所有的。传递负数将会从后边计算，-1是倒数第一个，以此类推。 subString()：和slice()完全一样，不同的是这个方法不能接受负值作为参数，如果传了负值自动按0处理，而且他还自动调整参数的位置，如果第二个参数小于第一个就自动交换。 split()：将字符串拆分为数组。需要一个字符串作为参数，将会根据该字符串去拆分数组。如果传递空串作为参数，则会将每个字符都拆分为数组中的一个元素。 正则表达式 一些处理常见任务的正则表达式可以直接去网上搜索。 正则表达式（reg，Regular Expression，又称规则表达式）用于定义一些字符串的规则，计算机可以根据正则表达式检查一个字符串是否符合规则，将字符串中符合规则的内容提取出来。通过var 变量 = new RegExp(&quot;正则表达式&quot;，&quot;匹配模式&quot;);创建正则表达式的对象。还可以使用字面量创建正则表达式var 变量 = /正则表达式/匹配模式。使用字面量方式创建更加简单，使用构造函数创建更加灵活。使用typeof检查正则对象返回object。使用test()方法检查一个字符串是否符合正则表达式的规则，如果符合返回true。 使用竖线|表示或者的意思，中括号[]里的内容也是或的意思，[ab]==a|b。[a-z]表示任意小写字母，大写字母同理。[A-z]表示任意字母（严格来说ASCII标里A-z中间有六个其他字符）。可以使用/a[bde]c/检查一个字符串中是否含有abc或adc或aec。[^ ]表示除了，只要有除了中括号内符号的其他符号就是true。 在正则表达式中使用\\作为转义字符，用\\.表示.，用\\\\表示\\。正则表达式中的.，\\等特殊字符需要在前面加上\\进行转义。 注意使用构造函数时，由于它的参数是一个字符串，而\\是字符串中的转义字符，如果要使用\\也需要使用\\\\代替。 还有一些带转义字符的元字符。1.\\w：任意字母数字下划线，相当于[A-z0-9_]。\\W：和\\w相反，表示[^A-z0-9_]。（word）2.\\d：任意数字。\\D：除了数字。（digital）3.\\s：空格。\\S：除了空格。（space）4.\\b：单词边界。B同理。（bound）比如检查一个字符串中是否含单词child可以使用reg = /\\bchild\\b/。 其实\\b的作用不只是检查空格，实际上是检查以“半角英数字+下划线”构成的词汇前后存在“非词汇构成元素”（即\\W）的情况，比如“hello%child#”，“hello【child】”这些都能排查出来。 在构造函数中可以传递一个匹配模式作为第二个参数。i：忽略大小写；g：全局匹配模式。可以为一个正则表达式设置多个匹配模式，顺序无所谓。 1234var reg = new RegExp(&quot;a&quot;，&quot;i&quot;); // 检查一个字符串中是否含a/Avar reg = /a/i; // 和上面一行效果相同var str = &quot;a&quot;;console.log(reg.test(&quot;a&quot;)); 正则相关的字符串方法使用split()：将字符串拆分为数组。需要一个字符串作为参数，将会根据该字符串去拆分数组。如果传递空串作为参数，则会将每个字符都拆分为数组中的一个元素。可以传递一个正则表达式作为参数，这样方法将会根据正则表达式去拆分字符串。该方法即使不指定全局匹配也会全部拆分。 使用search()：搜索字符串中是否含有指定内容。如果搜索到指定内容，返回第一次出现的索引；如果没有搜索到就返回-1。可以接受一个正则表达式为参数，根据正则表达式去检索字符串。str = [hello abc afc]; result = str.search(/a[bef]c/)。该方法即使指定全局匹配也只查找第一个。 使用match()：根据正则表达式从一个字符串中将符合条件的内容提取出来。默认情况下match只会找到第一个符合要求的内容，找到以后就停止检索。可以设置正则表达式为全局匹配模式，这样就会匹配到所有的内容。match会将匹配到的内容封装到一个数组中返回，即使只查询到一个结果。 使用replace()：将字符串中的指定内容替换为新的内容。第一个参数：被替换的内容，可以接受一个正则表达式作为参数；第二个参数：新的内容。默认只会替换第一个，指定匹配模式含g可以实现全部替换。第二个参数指定为空串则会删除指定内容。 利用replace()方法去除字符串 he llo 的空格去掉开头的空格：str = str.replace(/^\\s*/,&quot;&quot;);去掉结尾的空格：str = str.replace(/\\s*$/,&quot;&quot;);去掉开头和结尾的空格：str = str.replace(/^\\s*｜\\s*$/g,&quot;&quot;);。其中的两个星号换成加号也可。 量词使用量词设置一个内容出现的次数。需要注意的是量词只对它前边的一个内容起作用，通过括号指定需要重复的组合。{n}，如&#123;(ab)n&#125;，ab正好出现n次。{m,n}，如&#123;ab&#123;m,n&#125;c&#125;，b出现m到n次。{m,}，出现m次以上。+，至少一个。相当于{1,}。*，0个或多个，相当于{0,}。？，0个或一个，相当于{0,1}。^，表示开头。如&#123;^a&#125;，以a开头。$，表示结尾。如&#123;a$&#125;，以a结尾。如果在正则表达式中同时使用^和$则要求字符串必须完全满足正则表达式。 比如创建一个用来检查字符串是否为合法手机号的正则表达式。规则：以1开头+第二位为3-9的任意数字+含第三位的九个任意数字。^1[3-9][0-9]&#123;9&#125;$ 邮件的正则例如&#x68;&#101;&#x6c;&#108;&#x6f;&#46;&#110;&#x69;&#104;&#97;&#111;&#64;&#97;&#98;&#99;&#46;&#99;&#111;&#x6d;&#x2e;&#99;&#110; 注意量词的使用！ 规则：任意字母数字下划线(3位以上) .任意字母下划线(可选) @ 任意字母数字 .任意字母（2-5位） .任意字母（2-5位）。分别对应：/\\w&#123;3,&#125;/ /(\\.\\w+)*/ /@/ /[A-z0-9]/+ /\\.[A-z]&#123;2,5&#125;/ /\\.[A-z]&#123;2,5&#125;/组合起来：/\\w&#123;3,&#125;(\\.\\w+)*@[A-z0-9]+(\\.[A-z]&#123;2,5&#125;)&#123;1,2&#125;/。但这样写存在问题，还需要加开始和结束符号做严格的限制：/^\\w&#123;3,&#125;(\\.\\w+)*@[A-z0-9]+(\\.[A-z]&#123;2,5&#125;)&#123;1,2&#125;$/。 DOMDocument Object Model，文档对象模型。用处就是可以让人用JS对HTML文档进行操作。文档：整个HTML网页文档对象：网页中的每一个部分都转换成了一个对象。（转换为对象后就可以使用纯面向对象的方式操作网页）模型：使用模型表示对象间的关系，方便获取对象。 节点Node，是构成网页的最基本的组成部分，网页中的每个部分都可以称为是节点，如html标签、属性、文本、注释、整个文档等。虽然都是节点但具体类型不同。节点类型不同属性和方法也不尽相同。常用节点分为四类： “文档节点”：整个HTML文档 “元素节点”：HTML文档中的HTML标签（元素就是标签） “属性节点”：元素的属性 “文本节点”：HTML标签中的文本内容可以使用innerHTML获取元素内部的HTML内容；innerText获取元素内部的文本内容，它和innerHTML类似，不同的是它会自动将HTML标签去除。 123456789101112![节点属性](shuxing.png)浏览器已经为我们提供了文档节点对象，文档节点代表的是整个网页。这个对象是window属性，可以在页面中直接使用。```html&lt;button id=&quot;btn&quot; onclick=&quot;alert(&#x27;按钮已点击&#x27;)&quot;&gt;我是一个按钮&lt;/button&gt;&lt;script&gt; // 获取到button对象 var btn = document.getElementById(&quot;btn&quot;); console.log(btn); // [object HTMLButtonElement] // 修改按钮的文字 btn.innerHTML = &quot;新的文字内容&quot;&lt;/script&gt; 文档的加载浏览器加载页面时按照自上而下的顺序，读取到一行运行一行。如果将script标签写到页面的上边，那么在代码执行时页面还没有加载，页面没加载那么DOM对象也没加载，会导致无法获取到DOM对象。将js代码编写到页面下部就是为了可以在页面加载完毕后再执行js代码。 onload事件对应的响应函数会在整个页面加载完成后才会触发。可以为window绑定一个onload事件window.onload = function9)&#123;&#125;以确保代码执行时所有的DOM对象已经加载完毕了，不会出现获取不到的情况。如果把js代码写在html文档的head中可以把它们都放在onload事件内。 事件文档或浏览器窗口中发生的一些特定交互瞬间。可以在事件对应的属性中编写一些js代码。类似上文中&lt;button id=&quot;btn&quot; onclick=&quot;alert(&#39;已点击&#39;)&quot;&gt;我是按钮&lt;/button&gt;的写法称为结构和行为耦合，不方便维护，不推荐使用。可以为按钮的对应事件绑定处理函数的形式来响应事件。当事件被触发时，其对应的函数将会被调用。像onclick这种为单机事件绑定的函数称为单机响应函数。 12345678910111213141516171819&lt;button id=&quot;btn&quot;&gt;我是一个按钮&lt;/button&gt;&lt;script&gt;// idStr：要绑定单机响应函数的对象的id属性值；fun：事件的回调函数function.myClick(idStr,fun)&#123; // 获取到button对象 var btn = document.getElementById(idStr); btn.onclick = fun;&#125;;myClick(mybtn,function()&#123; // 获取id为element1的元素 var ele1 = document.getElementById(&quot;element1&quot;); // 返回#element1的前一个兄弟节点（如果HTML文档内有换行，也可能获取到空白文本） var ps = ele1.previousSibling; alert(ps.innerHTML); // 使用previousElementSibling获取前一个兄弟元素，IE8以下不支持 var pe = ele1.previousElementSibling; &#125;);&lt;/script&gt; 常用的函数还有onscroll，该函数会在元素的滚动条滚动时触发；onmousemove，该事件会在鼠标在元素移动时触发； 事件对象在IE8及以下浏览器中，响应函数被触发时浏览器不会传递事件对象，而是将事件对象作为window对象的属性保存的。需要用var x = window.event.clientX;的形式调用。 event中的属性target表示触发事件的对象，用event.target.xxx的形式调用。 当事件的响应函数被触发时，浏览器每次都会将一个事件对象作为实参传递给响应函数。在事件对象中封装了当前事件相关的一切信息，比如鼠标的坐标、键盘哪个案件按下、鼠标滚轮的方向等。 1234567891011areaDiv.onmousemove = function(event)&#123; /*可以使用这种方法兼容IE if(!event)&#123; event = window.event; &#125;*/ //解决事件对象兼容性问题的方法:利用JS中的或语句，前者为true直接赋值，前者为false返回第二个值。 event = event || window.event; var x = event.clientX; var y = event.clientY; showMsg.innerHTML = &quot;x=&quot; + x + &quot;, y=&quot; + y;&#125; DOM查询的常见方法 元素节点，通过document对象调用方法getElementById()、getElementsByTagName()、getElementsByName()分别是通过id属性、标签名和name属性获取元素节点对象。其中通过id属性一定是获取唯一的对象，其他方法可以获取一组对象。方法getElementsByClassName()会返回一个 类数组 对象，返回当前节点的指定class属性值查询一组元素节点对象，但不支持IE8及以下。方法getElementsByTagName()会返回一个 类数组 对象，所有查询到的元素都会封装到对象中。主要用来操作表单。（类数组就是HTMLCollection）方法getElementsByName()应该注意，由于innerHTML用于获取元素内部的HTML代码，所以对于自结束标签没有意义。 读取元素节点的属性：直接使用元素.属性名。但读取class属性不能使用这种方式，而应该使用元素.className。（class是js中的保留字） 元素节点的子节点，通过具体的元素节点调用方法getElementsByTagName()，返回当前节点的指定标签名后代节点。返回一个 类数组 对象。属性childNodes，表示当前节点的所有子节点。返回一个 类数组 对象。该属性会获取包括文本节点在内的所有节点。 根据DOM标签，标签间的空白也会被当成文本节点！属性children获取当前元素的所有子元素。属性firstChild，表示当前节点的第一个子节点。属性firstElementsChild，获取当前元素的第一个子元素。属性lastChild，表示当前节点的最后一个子节点。 注意属性和方法使用方式的不同。 父节点和兄弟节点，通过具体的节点调用属性parentNode，表示当前节点的父节点。属性previousSibling，表示当前节点的前一个兄弟节点。如果HTML文档内有换行，也可能获取到空白文本。属性previousElementSibling，获取前一个兄弟元素，IE8以下不支持。属性nextSibling，表示当前节点的后一个兄弟节点。 选择器作为参数方法document.querySelector()需要一个选择器作为参数，可以根据一个CSS选择器来查询一个元素节点对象。使用该方法只能返回唯一的一个元素，如果满足条件的元素有多个，那么它只会返回第一个。可以使用document.querySelectorAll()，它与上面的方法类似，不同的是它会将符合条件的元素封装到一个数组中返回。即使符合条件的元素只有一个也会返回数组。 12345678910&lt;body&gt; &lt;div class=&quot;box1&quot;&gt; &lt;div&gt;这是box1中的div&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var div = document.querySelector(&quot;.box1 div&quot;); console.log(div.innerHTML);&lt;/script&gt; document中的其它属性属性body，它保存的是&lt;body&gt;``i`的引用。 属性html，它保存的是根标签``i`的引用。属性all，代表页面中的所有元素。document.all和document.getElementByTagName含义相同。 DOM增删改 使用innerHTML也可以完成DOM增删改的相关操作，但动作太大了，会把更大部分的HTML代码标记为修改过的状态。所以一般会两种方式结合使用。 document.createElement()用于创建一个元素节点对象，需要一个标签名作为参数，根据该标签名创建元素节点对象，并将创建好的对象作为返回值返回。 document.createTextNode()用于创建一个文本节点对象，需要一个文本内容作为参数，根据该内容创建文本节点，并将创建好的节点作为返回值返回。 .appendChild()用于向一个父节点中添加一个新的子节点。用法：父节点.appendChild(子节点)。 .insertBefore()用于向指定的 子节点 前插入新的子节点，因此调用该方法的一定是父元素。用法：父节点.insertBefore(新的子节点，指定的子节点)。 replaceChild()用于替换子节点，因此调用该方法的一定是父元素。用法：父节点.replaceChild(新的子节点，指定的子节点)。 removeChild()用于删除子节点，因此调用该方法的一定是父元素。用法：父节点.replaceChild(子节点)。一种更方便的、不用请它的父元素的方式：子节点.parentNode.replaceChild(子节点)。 123456789101112131415161718window.onload = function()&#123; myClick(&quot;mybtn&quot;,function()&#123; // 创建广州节点&lt;li&gt;广州&lt;/li&gt; var li = document.createElement(&quot;li&quot;); // 创建li元素节点 var gzText = document.createTextNode(&quot;广州&quot;); // 创建广州文本节点 li.appendChild(gzText); // 将gzText设置为li的子节点 var city = document.getElementById(&quot;city&quot;); // 将广州添加到city下 city.appendChild(li); &#125;)&#125; // 也可以直接利用innerHTML var city = document.getELementById(city); city.innerHTML += &quot;&lt;li&gt;广州&lt;/li&gt;&quot;; // 两种方法结合【推荐】 var li = document.createElement(&quot;li&quot;); li.innerHTML = &quot;广州&quot;; var city = document.getElementById(&quot;city&quot;); city.appendChild(li); 使用DOM操作CSS 能起到修改样式的只有style属性！ 通过JS修改元素的样式：元素.style.样式名 = 样式值。这里的样式值需要传入字符串，如”200px”。通过style属性设置的样式都是内联样式，而内联样式具有较高的优先级，所以通过JS修改的样式往往会立即显示。但如果在样式中写了!important那么它就会有最高优先级，即使通过JS也不能覆盖该样式，会导致JS修改样式失效。所以尽量别为样式添加!important。 如果CSS的样式名中含有减号”-“，如background-color，这种名称在JS中不合法。需要将这种样式名修改为驼峰命名法：去掉减号，然后将减号后的字母大写。 通过JS读取元素的样式：元素.style.样式名。 通过style属性读取到的都是内联样式！无法读取样式表中的样式。 读取元素的样式通过style属性读取到的都是内联样式，无法读取样式表中的样式。 （只有IE支持) 获取元素的当前显示的样式：元素.currentStyle.样式名。如果当前元素没有设置样式，则获取它的默认样式。 其它浏览器获取元素的当前显示的样式：元素.getComputedStyle()。这个方法是window的方法，可以直接使用。需要两个参数，第一个：要获取样式的元素，第二个：可以传递一个伪元素，很少用，一般都传null。该方法会返回一个对象，对象中封装了当前元素对应的样式。可以通过对象.样式名读取样式。如果获取的样式没有设置，则会获取到真实的值，而不是默认值。比如：没有设置width，它不会获取到auto，而是获取到实际的长度，和显示器大小、人为缩放都有关系。该方法不支持IE8及以下的浏览器。通过currentStyle和getComputedStyle()读到的样式都是只读的，不能修改。如果修改必须通过style属性。形如box1.currentStyle.width = &quot;200px&quot;的写法是行不通的。 总之，正常浏览器：getComputedStyle(box1,null).backgroundColorIE：如box1.currentStyle.backgroundColor 可以定义一个通用的函数，用来获取元素的当前的样式。需要两个参数：obj，要获取样式的元素；name，要获取的样式名。 123456789101112getStyle(box1,&quot;width&quot;);function getStyle(obj,name)&#123; if(window.getComputedStyle)&#123; // 加上window.，代表是以属性的形式调用。 // 不加就是变量 // 变量没有会报错，属性没有会报undefined return getComputedStyle(obj,null)[name]; // 正常浏览器的方式。这里注意由于name传入的是变量，所以需要用中括号的语法。 return obj.currentStyle.[name]； // IE8的方式 // 也可以用？ ：表达式整合成一条语句。 &#125;&#125; 其它样式操作的属性 这些 属性 都是不带px单位的，返回的只是数字，可以直接进行计算 属性clientX、clientY可以获取鼠标指针在当前可见窗口的坐标。 属性pageX、pageY可以获取鼠标指针在当前页面的坐标。 属性clientWidth、clientHeight：获取元素的可见宽度和高度。包括内容区和内边距，不包括边框。该属性是只读的，不能修改，想修改只能用style属性。 属性offsetWidth、offsetHeight：获取元素的整个宽度和高度。包括内容区、内边距和边框。。/÷÷÷÷÷÷÷、 属性offsetParent：获取当前元素的最近的开启了定位的父元素。（定位默认static。）如果所有的祖先元素都没开启定位，返回body。 属性offsetLeft、offsetTop：获取当前元素相对于其定位父元素的水平、垂直 属性scrollHeight、scrollWidth：获取元素的滚动高度/宽度。也就是整个滚动区域的高度/宽度。（通过overflow：auto添加滚动条） 属性scrollLeft、scrollTop：获取水平/垂直滚动条滚动的距离。Chrome认为浏览器的滚动条是body的，可以通过body.scrollTop获取；但事实上，滚动条出现是因为父元素容不下它，所以应该用body的父元素html获取。用var st = document.body.scrollTop || document.documentElement.scrollTop解决这个问题。 满足scrollHeight - scrollTop == clientHeight说明垂直滚动条滚动到底。 事件的冒泡、委派、绑定和传播 向上冒泡，向下委派。 事件的冒泡冒泡（bubble）指的就是事件的向上传导，当后代元素的事件被触发时，其祖先元素的 相同事件 也会被触发。开发中，大部分情况下的冒泡都是有用的，如果不希望发生事件冒泡可以将事件对象的cancelBubble设置为true。 123456s1.onclick = function(event)&#123; event = event || window.event; // 取消冒泡：可以将事件对象的cancelBubble设置为true。 event.cancelBubble = true;&#125; 事件的委派场景：希望只绑定一次事件即可应用到多个元素上，即使元素是后添加的。可以尝试将其绑定给元素的共同的祖先元素。 事件的委派：指将事件统一绑定给元素的共同的祖先元素，这样当后代元素上的事件触发时，会一直冒泡到祖先元素。从而通过祖先元素的响应函数来处理。事件委派利用了冒泡，可以减少事件绑定的次数，提高程序的性能。 事件的绑定使用对象.事件 = 函数的方法绑定响应函数，只能同时为一个元素的一个事件绑定一个响应函数，不能绑定过个，否则后面的会覆盖掉前面的。 通过addEventListener()方法也可以为元素绑定响应函数（IE8以上。IE8及以下用attachEvent()绑定事件，用法一样，除了第一个参数需要on和执行顺序相反。）。可以同时为一个元素的相同事件同时绑定多个响应函数，这样当事件触发时，响应函数将会按照函数绑定的顺序执行。参数：1.事件的字符串，不要on。比如onclick在这里写作click。2.回调函数，当事件触发时该函数会被调用。3.是否在捕获阶段触发事件，需要一个布尔值，一般都传false。 此外，addEventListener()的this是绑定事件的对象（如下面的btn01），attachEvent()中的this则是window。 123456btn01.addEventListener(&quot;click&quot;,function()&#123; alert(1);&#125;,false);btn01.addEventListener(&quot;click&quot;,function()&#123; alert(2);&#125;,false) 为了解决浏览器的兼容性问题，定义一个函数用来为指定元素绑定响应函数。需要注意addEventListener()中的this是绑定事件的对象，attachEvent()中的this是window，需要统一两个方法中的this。这里使用call()方法改变函数执行时的this，这个方法是函数对象的方法，需要通过函数对象来调用，所以我们在它外面套一层匿名函数。实现的效果是一样的，但满足了call的使用条件，再使用call修改this的指向。 12345678910111213141516// 三个参数分别为要绑定事件的对象，事件的字符串和回调函数// 由于拼串更为容易，所以第二个参数传的是没有on的function bind(obj,eventStr,callback)&#123; if(obj.addEventListener)&#123; // 大部分浏览器兼容的方式 obj.addEventListener(eventStr,callback,false); &#125;else&#123; // IE8及以下 // this是谁由调用方式决定。 // 原本的调用方式：obj.attachEvent(&quot;on&quot; + eventStr,callback) obj.attachEvent(&quot;on&quot; + eventStr,function()&#123; // 在匿名函数中使用回调函数以满足call的适用条件 callback.call(obj); &#125;) &#125;&#125; 事件的传播关于时间的传播，网景公司和微软公司有不同的理解：微软认为事件应该是由内向外传播，也就是当事件触发时应该先触发当前元素上的事件，然后再向当前元素的祖先元素上传播，也就是时间应该在冒泡阶段执行；网景公司认为事件应该由外向内传播，也就是当事件触发时应该先触发当前元素最外层的祖先元素的事件，然后再向内传播到后代元素，也就是时间应该在捕获阶段执行。 W3C综合了两个公司的方案，将事件传播分成了三个阶段： 捕获阶段：捕获阶段时从最外层的祖先元素向目标元素进行事件的捕获，但是默认捕获阶段内不会触发事件 目标阶段：事件捕获到目标元素，捕获结束开始在目标元素上触发事件 冒泡阶段：事件从目标元素向他的祖先元素传递，依次触发祖先元素上的事件 如果希望在捕获阶段就触发事件，可以将addEventListener()的第三个参数设置为true。一般情况下我们不会希望在捕获阶段触发事件，所以这个参数一般都是false。在IE8及以下的浏览器中没有捕获阶段。 方法setCapture()：调用一个元素的setCapture()方法以后，这个元素将会把下一次所有的鼠标按下相关的事件捕获到自身上。（流氓网站）方法releaseCapture()实现当鼠标松开时，停止对对象的捕获。这两个方法只有IE支持，火狐中不会报错，chrome会报错。可以用box1.setCapture &amp;&amp; box1.setCapture()实现浏览器兼容。 键盘事件 键盘事件通常绑定给可以获取到焦点的对象或document 按键被按下onkeydown。如果一直按住某个按键不松手事件会一直触发，为了防止误操作，第一次和第二次间隔会稍微长一点，其它的都很快。按键被松开onkeyup。【尽量避免使用】可以通过keyCode属性获取按键的ASCII编码。alert(event.keyCode)。现在是key属性。 实例：鼠标拖拽 当鼠标在被拖拽元素上按下时，开始拖拽—— onmousedown 当鼠标移动时，被拖拽元素跟随鼠标移动—— onmousemove 当鼠标松开时，被拖拽元素固定在当前位置—— onmouseup 12345678910111213141516171819202122232425var box1 = document,getElementById(&quot;box1&quot;);box1.onmousedown = function()&#123; // 鼠标按下，开始拖拽 event = event || window.event; // div的偏移量：鼠标.clientX - 元素.offsetLeft，Y和top同理 var ol = event.clientX - box1.offsetLeft; var ot = event.clientY - box1.offsetTop; document.onmousemove = function(event)&#123; // 注意这里是给document绑定 event = event || window.event; var left = event.clientX - ol; var top = event.clientY - ot; box1.style.left = left + &quot;px&quot;; // 修改位置。记得开绝对定位。 box1.style.top = top + &quot;px&quot;; &#125;; document.onmouseup = function()&#123; // 给document绑定。给box1绑定，如果页面有其他元素并且恰好在其他元素的范围内松开鼠标会有bug，因为触发的是其他元素的onmouseup // 取消onmousemove的效果。但如果只有这句也有bug，鼠标在页面其他地方点击也会触发 document.onmousemove = null; // 取消onmouseup document.onmouseup = null; &#125;; // 当拖拽一个网页中的内容时，浏览器会默认去搜索引擎中搜索内容，会导致拖拽功能异常。 // 这个是浏览器提供的默认行为，如果不希望发生可以通过return false取消默认行为。&#125;; BOM浏览器对象模型。BOM可以使我们通过JS操作浏览器，BOM中为我们提供了一组对象用来完成对浏览器的操作。常见的BOM对象如下： Window：代表整个浏览器的窗口，同时window也是网页中的全局对象。 Navigator：代表当前浏览器的信息，通过该对象可以识别不同的浏览器。由于历史原因，Navigator对象中的大部分属性都已经不能帮助我们识别浏览器了。一般我们只会用userAgent（这词等价于浏览器）来判断浏览器的信息。userAgent是一个含有用来描述浏览器信息的字符串，不同浏览器有不同的userAgent。如果userAgent还不能判断，可以通过一些浏览器中特有的对象来判断浏览器的信息。 Location：当前浏览器的地址栏信息，通过该对象可以获取地址栏信息或操作浏览器跳转页面。直接打印location则可以获取到地址栏的信息（当前页面的完整路径）。 如果直接将location属性修改为一个完整的路径或相对路径，则页面会自动跳转到该路径，并且会生成相应的历史记录。方法assign()：用来跳转到其他的页面，作用和直接修改location一样方法reload()：重新加载当前页面，作用和刷新一样。如果在方法中传递一个true作为参数，则会强制清空缓存并刷新页面。方法replace()：使用一个新的页面替换当前页面，调用完毕也会跳转页面。但和直接修改location属性不同的是，它不会生成历史记录，不能回退。 History：代表浏览器的历史记录，通过该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页，而且该操作只在当次访问时有效。属性length：获取到当前访问的链接数量方法back()：回退到上一个页面，作用和浏览器的回退按钮一样方法forward()：回退到下一个页面，作用和浏览器的前进按钮一样方法go()：跳转到指定页面，需要一个整数作为参数——1:向前跳转一个，相当于forward；其它正整数同理。负数就是回退。 Screen：代表用户的屏幕信息，通过该对象可以获取到用户显示器的相关信息（主要用在移动端） 虽然描述的时候大写，但用起来的时候都是小写 这些BOM对象在浏览器中都是作为window对象的属性保存的，都是全局对象。可以通过window对象来使用，由于是全局对象也可以直接使用。console.log(window.location)和console.log(location)都行。 定时器 方法setInterval()：将一个函数每隔一段时间执行一次。参数——1.回调函数，该函数会每隔一段时间被调用一次；2.调用的间隔时间，单位ms返回值——一个Number类型的数据，从1开始。这个数字用来作为定时器的唯一标识。 123setInterval(function()&#123; count.innerHTML = num++;&#125;,300) 很多情况下，要想不出错需要在开启定时器之前将 当前元素 上的其它定时器关闭 方法clearInterval()用来关闭定时器，传入的参数即是定时器的标识。参数——它可以接受任意参数，都不会报错。如果参数是一个有效的定时器的标识，则停止对应的定时器；如果参数不是有效的标识就什么都不做。 12345678910111213141516171819202122var imgArr = [&quot;1.jpg&quot;,&quot;2.jpg&quot;,&quot;3.jpg&quot;];var index = 0; // 保存当前图片的索引var timer; // 保存定时器的标识var btn01 = document.getElementById(&quot;btn01&quot;); // btn01是开始按钮btn01.onclick = function()&#123; // 解决：每点击一次按钮就会开启一个定时器，点击多次就会开启多个定时器，会导致图片切换速度过快，并且由于timer的值会被刷新就只能关闭最后一次开启的定时器的问题 // 在开启定时器之前将当前元素上的其它定时器关闭 clearInterval(timer); timer = setInterval(function()&#123; index++; // 判断索引是否超过最大索引 if(index &gt;= imgArr.length)&#123; index = 0; &#125; img1.src = imgArr[index]; &#125;,1000);&#125;;var btn02 = document.getElementById(&quot;btn02&quot;); // btn02是结束按钮btn02.onclick = function()&#123; clearInterval(timer);&#125;;","categories":[],"tags":[]},{"title":"HTML/CSS笔记","slug":"HTML-CSS笔记","date":"2022-01-09T13:41:50.000Z","updated":"2022-01-09T13:41:50.000Z","comments":true,"path":"2022/01/09/HTML-CSS笔记/","link":"","permalink":"https://avalooooooon.github.io/2022/01/09/HTML-CSS%E7%AC%94%E8%AE%B0/","excerpt":"","text":"HTML w3school的标签文档：tagsMDN的标签文档: tags Vscode安装的扩展：Live Server； 在浏览器中，检查元素的elements窗口显示的是代码在内存中的结构 HTML基本结构 vs code中新建.html文件，输入一个感叹号后直接tab可一键生成一个最简单的HTML模版。 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang = &quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt; &lt;/title&gt; &lt;style&gt; /* css中的注释 */ nav,article,aside&#123; float:left; &#125; ul&#123; margin:0; list-style:none; &#125; &lt;/style&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./css/reset.css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;header&gt; &lt;span&gt;&lt;/span&gt; &lt;/header&gt; &lt;main&gt; &lt;nav&gt;&lt;/nav&gt; &lt;article&gt;&lt;/article&gt; &lt;aside&gt;&lt;/aside&gt; &lt;/main&gt; &lt;footer&gt; &lt;span&gt;&lt;/span&gt; &lt;/footer&gt; &lt;ul&gt; &lt;li&gt; &lt;a href=&quot;javascript:;&quot;&gt; &lt;/a&gt; &lt;li&gt; &lt;li&gt; &lt;li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; &lt;DOCTYPE&gt;:文档声明，用来告诉浏览器当前网页的版本（语法规范）。就是html5的文档声明。 &lt;html&gt;: html的根标签，除了文档声明，所有内容都要写在根元素内；lang = “en”指定网页语言为英语，会触发浏览器的翻译功能，设置为zh则不会触发翻译 &lt;head&gt;: 给搜索引擎看帮助其解析网页，其中的内容不会出现在网页中 &lt;meta&gt;: 用来设置网页的元数据（与生俱来的、不会变的、底层的数据），也是给搜索引擎看的；可以通过该标签设置网页字符集charset(utf-8)；name；keywords是网站关键字，给搜索引擎分类网站的；description，介绍网站，会显示在搜索引擎搜索的结果中；title，作为搜索结果超链接中的文字显示。 &lt;title&gt;: 网页标题，在标题栏出现 &lt;body&gt;: 需要展示的所有内容都在其中 &lt;div&gt;: 没有语义，表示一个区块，是主要的布局元素 &lt;span&gt;: 没有语义，表示一个行内元素，是主要的布局元素 HTML属性属性是一个 名值对（x=y，即color=”red”），属性值应该使用引号引起来，可以是单引号也可以是双引号，但要一致。属性用来设置标签中的内容如何显示， HTML实体（转义）如需要在网页中书写特殊符号（多个连续空格、内容两侧的大于号和小于号），需要使用HTML中的实体（转义字符）。语法：&amp;实体的名字;。如，空格：&amp;nbsp;，多个连续空格可以写成&amp;nbsp;&amp;nbsp;&amp;nbsp;，大于号：&amp;gt;，小于号：&amp;lt; 在w3school:html实体中查询更多。 CSS层叠样式表。声明块中的声明是名值对，名和值用冒号连接。如color:red。注意这里CSS中的名值对用冒号链接；html中的属性值用的则是等号，如color=red。 样式的继承：为一个元素设置样式的同时也会应用到它的后代元素上。但背景相关的、布局相关的等一些样式不会被继承。 内联（行内）样式： 开发时不要使用内联样式！ 内部样式表：将样式全部写到&lt;head&gt;内的&lt;style&gt;标签里。 外部样式表：将样式写到外部的xxx.css文件中，再通过&lt;link&gt;标签引入。 浏览器的默认样式1234*&#123; margin:0; padding:0;&#125; 或者：使用重置样式表：style.css直接全部去除了浏览器的默认样式，normalize.css对不同浏览器的默认样式进行了统一。 长度和颜色单位 长度 像素（px）：根据屏幕不同而不同，像素越小的屏幕越清晰。同样的200px在不同设备下显示效果不同。 百分比：是相对其父属性而言。可以使子元素跟随父元素的改变而改变。 em：相对于当前元素（自身）的font- size。1em=1font-size。一般浏览器默认的字体大小都是16px，所以10em就是160px。会根据字体大小的改变而改变。 rem：相对于根元素（&lt;html&gt;标签）的font- size。 vw：视口宽度（viewport width）。 颜色 RGB值：rgb(红色,绿色,蓝色) RGBA值：rgba(红色,绿色,蓝色,.5)，第四个是透明度：1为完全不透，0为完全透明，.5为半透明 16进制值：#FFFFFF。两两重复可以简写。 HSL值：（同理有HSLA，色相：0～360+饱和度：颜色浓度0%～100%+亮度：0%～100%+透明度） 像素、（移动端）完美视口 移动端默认的视口大小是980px(css像素)。所以默认情况下，移动端的像素比就是980/移动端宽度（980/760，iPhone6），也就是一个css像素对应零点几个移动端的物理像素。又因为移动端的物理像素本来就小，所以如果我们直接在网页中编写移动端代码，在980的视口中像素比会很不好，导致网页中的内容很小。这就要求编写移动页面时必须确保有一个比较合理的像素比。 每一款移动设备设计时都会有一个最佳的像素比，一般把像素比设置为该值就可得到最佳效果。将像素比设置为最佳像素比的视口大小我们称其为完美视口。不同设备完美视口的大小不同：iPhone6-375px，iPhone6 plue-414px。由于不同设备视口和像素比不同，所以同样的375像素在不同设备下意义不同，比如在iPhone6中375是全凭，在plus中就会缺一块。所以在移动端开发时就不能再使用px进行布局了。 可以通过&lt;meta&gt;标签设置视口大小。&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;就把网页的视口设置为完美视口。总之就是再写移动端的页面时就把这句先写上。 移动端开发解决比例问题的最终方案使用less+rem的方法，换算设计图px和代码rem的比例。 12345678// total-width是设计图的宽度@total-width:750; html&#123; font-size:(100vw/@total-width)*40;&#125;.box&#123; height:175/40rem; // 这里的175指的是设计图上的宽度为175px&#125; 选择器 样式冲突：冲突时由选择器的权重（优先级）决定。比较时要将所有选择器的优先级相加计算。但选择器的累加不会超过其最大的数量级，即类选择器最高也不会超过id选择器的优先级。并集（分组）选择器单独计算。 「选择器越具体，优先级越高」：内联样式 1000 &gt; id选择器 100&gt; 类和伪类选择器 10&gt; 元素选择器 1&gt; 通配选择器 0&gt; 继承的样式 没有优先级；在样式最后加!important直接升为最高优先级。若优先级计算后相等，优先使用靠下的样式。 元素选择器：根据标签名选中指定的元素。语法：标签名&#123;&#125;，如h1&#123;&#125;。 id选择器：根据id选中 一个 元素。语法：#id属性值&#123;&#125;。 类选择器：根据类名选中 一组 元素。语法：.class属性值&#123;&#125;。 一个标签可以有多个class，class中间用空格分开。如&lt;p class=&quot;cla1 cla2&quot;&gt;。 通配选择器：选中页面所有元素。语法：*&#123;&#125;。 复合选择器 交集选择器：选择器1选择器2选择器n&#123;&#125;，如div.cla1&#123;&#125;。 如含有元素选择器，必须使用元素选择器开头。 并集选择器（分组选择器）:选择器1,选择器2,...,选择器n&#123;&#125;。 关系选择器 父元素（ 直接 包含子元素）、子元素（ 直接 被父元素包含）；祖先元素（直接或间接包含后代元素）、后代元素；兄弟元素 子元素选择器：父元素 &gt; 子元素&#123;&#125;。 后代元素选择器：祖先 后代&#123;&#125; 兄弟元素选择器： 1. 选择 下一个 兄弟，前一个 + 下一个&#123;&#125;。 2. 选择 下面所有 兄弟，前一个 ～ 下一个&#123;&#125;。 属性选择器 选择含有指定属性的元素：[属性名] 选择含有指定属性和属性值的元素：[属性名=属性值] 选择属性值以指定值开头的元素：[属性名^=指定值] 选择属性值以指定值结尾的元素：[属性名$=指定值] 选择属性值中含有指定值的元素：[属性名*=指定值] 伪类选择器伪类，一般使用:开头，是一种特殊的类，是不存在的类，用于描述一个元素的特殊 状态 。如第一个子元素、被点击的元素、鼠标移入的元素… 排序伪类语法：:first-child，第一个子元素；:nthchild()，选中第n个子元素，具体n值写在括号内； :nthchild()，括号内的特殊值括号内写n则为全选，2n或even为选中偶数位元素，2n+1或odd为选中奇数位元素； 以上的伪类都是根据所有的子元素进行的排序！想要在同类型元素中进行排序，需要使用形如:first-of-type的伪类，用法相似。 否定伪类如:not(): 将符合条件的元素从选择器中去除。eg:.cla1 li:not(:last-child)。 超链接伪类没访问过的链接：可用:link访问过的链接：:visited。由于隐私原因，只能修改链接颜色鼠标状态：:hover为鼠标移入的状态。 :active为鼠标点击的状态。 事实上，“ :link ” 可以表示一切正常的链接。 伪元素选择器伪元素，一般使用::开头，是一种特殊的元素，是不存在的元素。类似伪类。 如::first-letter。默认是行内元素！ ::before、::after：必须结合content属性使用。 content中的内容是通过css添加的，是不能选中的！ 示例：1234div::before&#123; content:&#x27;abc&#x27;; color:red;&#125; 盒模型 计算盒子整体 可见 大小时需要把内容区content、内边框padding、边框border都计算在内！ 内容区：content width和height设置的是内容区（content）的大小。 内边距：padding， 影响盒大小；背景颜色会延伸到内边距（默认时）。 边框：border。需要至少设置3个样式——宽度（border-width）、颜色（border- color）、样式（border-style，设置为none则无边框）。 简写属性：border: solid 10px red，无顺序要求。 关于border-width、border- color和border-style1.都可以省略（有默认值）；都有```border-xxx-width/color/style```的形式 2.四个值：上，右，下，左；三个值：上，左右，下；两个值：上下，左右 外边框：margin，不影响盒子可见框大小，但影响盒子的实际大小和位置。 注意，margin-top和margin-left移动自己，margin-bottom挤别人，margin-right经常没用。可以设置为负值。 轮廓：outline，用来设置元素的轮廓线，用法和border一摸一样。唯一和border不一样的点就是轮廓不会影响可见框的大小。 阴影：box-shadow，用来设置元素的阴影效果，不会影响页面布局。起始位置和元素本身的位置完全重合。 box-shadow: 2px 5px 10px rgba(0,0,0,.3) 第一个值：水平偏移，正值向右，负值向左。 第二个值：垂直偏移，正值向下，负值向上。 第三个值：模糊半径。即使前两个值都为0，设置了模糊半径也能看到阴影。 第四个值：颜色，常用带透明度的rgba。 圆角：border-radius，可以分别指定四个角的圆角。 对某个角同时指定两个半径：椭圆圆角。border-top-left-radius:10px 20px 四个值：左上 右上 右下 左下 三个值：左上 右上/左下 右下 两个值：左上/右下 右上/左下 不到四个值，缺哪个找哪个的对角值，这个值代表了两个角的半径。 将元素设置为圆形： border-radius:50% 水平布局一个元素在其父元素的内容区中存在，该元素的水平布局 必须满足： 左外边距+左边框+左内边距+width+右内边距+右边框+右外边距 = 其父元素内容区的宽度但元素设置浮动float后，该等式不需要强制成立！ 等式中的宽度width，左外边距margin-left，左内边距padding-left可以设置为auto。 如果不满足，如何调整？（注意margin可以为负） 如果这7个值没有auto，浏览器会自动调整margin-right。 如果这7个值有一个auto，浏览器会自动调整auto。width的默认值即为auto。 如果这7个值有两个auto，且一个是width一个是margin，则宽度会调整到最大，设置为auto的外边距自动为0。 如果三个都是auto，则padding为0，width最大。（全屏） 如果将两个外边距auto，宽度固定，则会将外边距设置为相同的值。（元素在父元素居中） 经常利用这个特点使元素在子元素内居中 垂直布局 默认情况下父元素的高度会被内容撑开如果子元素的大小超过了父元素，则子元素会从父元素溢出 使用overflow属性设置父元素如何处理溢出的子元素，可选值如下： visible：默认值，子元素会从父元素中溢出，在父元素外部的位置显示 hidden：溢出内容会被裁剪，不会显示（“一剪没”） scroll：生成垂直和水平两个滚动条，通过滚筒条查看完整内容 auto：根据需要生成滚动条（水平还是垂直） overflow-x：单独处理水平方向的 overflow-y：单独处理垂直方向的 相邻的垂直方向外边距的折叠（重叠） 相邻 且 垂直才适用这种情况。 兄弟元素 两者都是正值：会取两者之间的较大值 特殊情况：一正一负：取两者的和；两负：取两者绝对值较大的 兄弟元素外边距的重叠对开发是有利的，不需要处理 父子元素 子元素的会传递给父元素（上外边距） 父子元素外边距的重叠会影响到页面布局，必须处理！解决方法：要么不用外边距（给父元素padding），要么别相邻（给父元素border，隔开外边距） 解决方案：::before伪元素 + display:table 1234.box1::before&#123; content:&#x27;&#x27;; display:table&#125; table既可以解决高度塌陷，又可以解决外边框重叠。 行内元素的盒模型 文字的垂直居中：要让一个文字在父元素中垂直居中，只需让父元素的line-height和父元素height相等。 行内元素不支持设置宽度和高度，因为行内元素没有内容区，宽高是对内容区而言的 行内元素支持设置padding、border和margin，但垂直方向的这些属性不会影响页面的布局 display，用来设置元素显示的类型 inline：将元素设置为行内元素 block：将元素设置为块元素 inline-block：将元素设置为行内块元素（既可以设置宽高，又不会独占一行，有点像替换元素的特点） 行内块元素同时具备行内元素和块元素的优点和缺点。尽量避免使用行内块元素！ table：将元素设置为一个表格 none：元素不在页面中显示 不占据页面的位置！ visibility，用来设置元素的显示状态 visible：默认值，元素在页面中正常显示 hidden：元素在页面中隐藏不显示 依然占据页面的位置！ 浮动 元素设置浮动后会完全从文档流中脱离，不再占用文档流的位置！脱离后，元素的一些特点也会发生变化。脱离文档流的特点如下： 块元素不再独占一行，且宽度和高度默认都被内容撑开 行内元素会变成块元素。 脱离文档流后，不需要再去区分块元素和行内元素! 设置浮动后，元素会向其父元素的左侧或右侧移动。默认值为none。 浮动元素不会从父元素中移出。 水平上，浮动元素向左或向右移动时， 不会超过 它前面的其他浮动元素。 垂直上，浮动元素不会超过它上边的浮动的兄弟元素，最多和它一样高。 若浮动元素的上边是一个没浮动的块元素，则浮动元素无法上移。 浮动元素不会盖住文字，文字会自动环绕在浮动元素周围。所以可以利用浮动设置文字环绕图片的效果。 浮动的高度塌陷问题在布局中，父元素的高度默认是被子元素撑开的。但是若子元素浮动后，其会完全脱离文档流，子元素从文档流中脱离将会无法撑起父元素的高度，导致父元素的高度丢失。其下一个元素会自动上移。页面布局混乱。 解决方案： 如果塌陷了的元素样式可以写死，可以直接给塌陷了的元素设置一个height。 BFC（Block Formatting Context）、clear和clearfix。 BFCBFC：CSS中的一个隐含属性，可以为一个元素开启BFC。开启BFC后，该元素会变成一个 独立的布局区域 。元素开启BFC后的特点如下： 开启BFC的元素不会被浮动元素覆盖 开启BFC的元素子元素和父元素的外边距不会重叠 开启BFC的元素可以包含浮动的子元素（解决高度塌陷） 由于BFC是一种隐含属性，不能直接开启，可以通过一些特殊的方式开启元素的BFC： （不推荐）设置元素的浮动（给想要包含浮动子元素的元素开启）。副作用：从文档流中脱离，宽度丢失。可能影响布局。 （不推荐）将元素设置为行内块元素。不会从文档流中脱离。副作用：宽度丢失。 （推荐）将元素的overflow设置为一个不是visible的属性：overflow：hidden或overflow：auto。 clear作用：清除浮动元素对当前元素产生的影响原理：设置清除浮动后，浏览器会自动为元素添加一个 上外边距，以使其位置不受其他元素的影响。可选值：left：清除左侧浮动元素对当前元素产生的影响；right：清除右侧浮动元素对当前元素产生的影响；both：清除两侧中最大影响的那侧（最常用）。 高度塌陷的最终解决方案：用::after伪类 12345.box1::after&#123; content:&#x27;&#x27;; clear:both; display:block/table; &#125; 解决高度塌陷和外边框重叠的最终方案（灵活，推荐）给存在这两种问题的元素直接添加一个clearfix类名： 12345.clearfix::before,.clearfix::after&#123; content:&#x27;&#x27;; display:table; clear:both;&#125; flex布局主要用来代替浮动完成页面布局。可以使元素带有弹性，让元素可以跟随页面大小的改变而改变。当父元素盒子设置为flex布局后，子元素的float、clear、vertical-align属性将失效。弹性容器：通过display:flex设置为块级弹性容器，display:inline-flex设置为行内的弹性容器。弹性元素：弹性容器的 直接子元素 是弹性元素。元素可以既是弹性容器，又是弹性元素。 弹性容器的样式主轴：弹性元素的排列方向；侧轴：与主轴垂直方向。凡是justify***都是主轴的，align***都是辅轴的。 容器中弹性元素的排列方式：flex-direction 弹性元素是否在容器中自动换行：flex-wrap 排列方式和换行的简写属性：flex-flow 对齐相关的样式： justify-content：元素在主轴如何对齐（如何分配主轴空白空间） flex-start、flex-end：沿主轴起边/终边对齐 center：居中 space-around、space-between、space-evenly align-content：设置元素在辅轴如何对齐（如何分配辅轴空白空间）。可选值和justify-content一样，多一个stretch。 只能用于子项出现换行的情况（多行），单行下没有效果。 align-items：子项为单行时使用。设置元素在辅轴如何对齐。 适用于单行的情况，只有上对齐、下对齐、居中和拉伸。 stretch：默认值，将元素的长度设置为相同的值 flex-start、flex-end：沿辅轴起边/终边对齐，不会拉伸元素 center：居中 base-line：基线对齐，用的不多。 弹性元素的样式只有三个：增长、缩短、基础长度。通过align-self覆盖当前元素上的align-items。 flex-grow、flex-shrink：指定弹性元素的伸展/收缩系数。父元素的剩余空间会按照比例分配/当父元素空间不足以容纳所有子元素时，对子元素进行压缩。 flex-basis：元素在主轴上的基础长度。默认auto，即参考元素自身的高度和宽度。 这三个值可以看作是弹簧的三个状态：伸长，压缩，放松。 可以通过简写属性flex设置弹性元素所有的三个样式。flex:增长 缩减 基础。 initial：即为flex:0 1 auto，只能减。 auto：即为flex:1 1 auto，可增可减。 none：即为flex:0 0 auto，元素没有弹性。 还可以使用order决定弹性元素的排列顺序。 定位用position属性。默认为static，即元素是静止的，没有开启定位。只要开了定位，就都是一个层级；和哪种定位无关。 关于层级：如果元素的层级一样，则优先显示靠下的元素。祖先元素的层级再高也不会盖住后代元素。 绝对定位：absolute相对于其包含块（containing block）定位。 关于包含块（正常情况下，包含块就是当前元素 最近 的祖先 块 元素）绝对定位的包含块：当前元素最近的开启了定位的祖先元素；若所有祖先元素都没开启定位，则根元素就是它的包含块。 若不设置偏移量，元素位置 不会发生变化。 开启绝对定位的元素会 从文档流中脱离 ，性质发生变化：行内变成块，块的宽高被内容撑开。 会使元素提升一个层级。 水平方向的布局等式需要添加left和right两个值。规则还和以前一样。 当发生过度约束时： 如果9个值中没auto，则自动调整right； 如果有auto（margin width left right），则自动调整auto的值：由于left和right的值默认是auto，所以当未设置它们的值且等式不满足时会自动调整这两个值。所以如果想通过margin设置居中的话必须要设置left和right为0。即水平居中：left: 0；right:0; margin-left:auto;margin-right:auto 绝对定位后，垂直方向的等式也必须满足：top+margin-top/bottom+padding-top/bottom+height=包含块的高度 垂直居中：top:0;bottom:0;margin-top:0;margin-bottom:0 在 父元素 中垂直且水平居中：top:0;bottom:0;left:0;right:0; margin:auto 相对定位：relative“灵魂出窍：移出来的是魂，肉体还在之前的位置”偏移量：top,bottom,left,right，是定位元素和定位位置上下左右的距离。参照 元素自身在文档流 中的位置。而且， 没有脱离文档流。相对定位的特点： 开启后，若不设置偏移量，元素不会发生任何变化 会提升元素的层级 不会改变元素性质：块还是块，行内还是行内 固定定位：fixed也是一种绝对定位，大部分特点和绝对定位一样。唯一不同：固定定位永远参照浏览器的视口进行定位。不会随网页的滚动条滚动。 粘滞定位：sticky兼容性较差。一般不采用。（完全不兼容IE） 和相对定位的特点基本一致 不同的是粘滞定位可以在元素到达某个位置时进行固定，参照包含块。 文字font可以设置字体相关的所有属性。字体大小和字体族必须有。会覆盖单独设置的值。 12font: 样式（font-style） 字重（font-weight） 字体大小/行高（lineheight） 字体族font：italic bold 50px/2 微软雅黑，‘Times New Roman’,Times,serif; 行高lineheight和字体框行高lineheight指的是文字占有的实际高度。可以任意指定一个大小（px em），也可以设置为整数，整数的意义是字体的指定的倍数。 注意行高指的是 单行 的行高！ 字体框是字体存在的格子，设置font-size字体大小实际就是设置字体框的高度。 行高会在字体框上下平均分配。 可以将行高设置为和高度一样的值，使 单行 文字在父元素中垂直居中 行高经常还用来设置文字的行间距。css没有行间距的属性，利用公式行间距=行高-字体大小来间接控制行间距。 文本的水平和垂直对齐水平对齐：text-align，默认值left ；right ；居中对齐center ；两端对齐justify 注意text-align只能给块元素设置！ 垂直对齐：vertical-align，默认值基线对齐baseline；顶部对齐top；底部对齐bottom；居中对齐middle（中线对齐）。还可以直接指定值vertical-align:100px。 用img标签引入图片时，由于图片作为替换元素性质很像行内元素，默认是基线对齐，导致图片和它父元素的border之间有一条缝隙，这个缝隙就是图片的 基线 。想消除这个缝隙：将图片的vertical-align设置为除baseline外的任意值即可。 其他文本样式设置文本修饰：text-decoration。不兼容IE。可选：none ；overline ；underline ；line-through。 设置网页如何处理空白：white-space。可选：normal ；nowrap ；pre保留空白（预处理文本，保留html文件中写的格式）； 如何实现文字显示不全，有省略号的效果？ 123456.box&#123; width:200px; white-space:nowrap; overflow:hidden; text-decoration:ellipsis;&#125; 其中width设置文本包含框宽度；white-space:nowrap; overflow:hidden; text-decoration:ellipsis;三者缺一不可。 背景可以使用简写属性background设置。 background- size必须写在background-position后面，并且使用/隔开。即background-position/background-size。 background-origin必须在background-clip前面。 1background: url(&quot;./1.png&quot;) #bfa center center/contain no-repeat； 同时设置背景图片和背景颜色：background-img:url(&quot;./1.png&quot;)。背景重复方式：background-repeat:no-repeat。背景图片的位置：background-position:top left。使用方位词时必须同时指定两个，如果只写一个另一个默认为center。也可以通过偏移量指定背景图片的位置。背景图的偏移量：background-origin:content-boc。背景图片大小：background-size：100% auto。第一个值宽度，第二个值高度，如果只写一个则另一个默认为auto（图片比例不变）。cover：图片比例不变，将元素铺满contain：图片比例不变，将图片在元素中完整显示 关于background-position的计算原点padding-box：默认值，background-position从内边距（左上角）开始计算content-box：从内容区处计算border-box：从边框处计算用background-clip:padding-box设置背景范围。border-box：默认值，背景会出现在边框的下面（内容区内边框和边框）padding-box：背景只到内边距（内容区和内边距出现），不会出现在边框content-box：背景只到内容区 用background-attachment:scroll设置背景图片是否跟随元素移动。scroll：默认值，背景图片会跟随元素移动fixed：背景会固定在页面中 渐变色 需要通过backgroud-image设置！ 线性渐变：backgroud-image:linear-gradient(to right,red,yellow,#bfa)。开头可以指定渐变方向，多个颜色默认平均分布。 可以平铺的线性渐变：backgroud-image:repeating-linear-gradient(to right,red,yellow,#bfa) 径向渐变（放射渐变）：backgroud-image:radial-gradient(100px 100px at top left,red,yellow) 语法：radial-gradient(大小at位置,颜色 位置,颜色 位置,...) 大小：circle、ellipse、closet/fasthest-side/corner 位置：top、right、left、center、bottom 表格table中，使用tr表示表格的一行，有几个&lt;tr&gt;就有几行。tr中，使用td表示一个单元格，有几个&lt;td&gt;就有几个单元格。用rowspan指定行宽。即纵向合并单元格。用colspan指定列宽。 下面是一个两行四列的表格。 123456789101112&lt;table border=&quot;1&quot; width=&quot;50%&quot; align=&quot;center&quot;&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt;a1&lt;/td&gt; &lt;td&gt;c1&lt;/td&gt; &lt;td rowspan=&quot;2&quot;&gt;d1&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;a2&lt;/td&gt; &lt;td&gt;b2&lt;/td&gt; &lt;td&gt;c2&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 可以将一个表格分成三部分：头部thead，主体tbody，底部tfoot。还有&lt;th&gt;标签，表示头部部分的单元格，会有加粗效果。 若表格中没有使用tbody而是直接使用tr，那么浏览器会自动创建一个tbody，并且将tr全部放入tbody。因此 tr不是table的子元素 ！ 表格样式指定边框之间的距离：border-spacing设置边框的合并：border-collapse:collapse设置隔行变色效果：tr:nth-child(odd)&#123;backgroundcolor:gray;&#125; 默认情况下元素在td中垂直居中。也可以通过vertical-align设置垂直对齐方式。用text-align设置水平对齐方式。（top bottom center） 利用这个特性，可以通过将父元素display:table和vertical-align让子元素垂直居中。注意水平居中仍需要用margin:0 auto实现，不能直接使用text-align。 表单 数据要提交到服务器中，必须要为元素指定一个name属性！ 123456&lt;form action=&quot;target.html&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;这是一个文本框&quot; autocomplete=&quot;off&quot;&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; value=&quot;这是一个密码框&quot; disabled&gt; &lt;br&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;注册&quot; value=&quot;这是一个提交按钮&quot; readonly&gt;&lt;/form&gt; 必填项action：内容为表单要提交的服务器的地址。属性autocomplete：是否开启自动补全。 单选框：同一个“name”字段即可划分到同一组单选按钮中，“value”属性会作为用户填写的值发给服务器。“checked”可以将单选按钮设置为默认选中。 12&lt;input type=&quot;radio&quot; name=&quot;group1&quot; value=&quot;a&quot;&gt;&lt;input type=&quot;radio&quot; name=&quot;group1&quot; value=&quot;b&quot; checked&gt; 还有多选框（type=”checkbox”）、下拉列表（&lt;select&gt;&lt;option&gt;)等。 过渡简写属性：transtion。只有一个要求：如果要写 延迟 ，则两个时间中的第一个是持续时间。可以指定一个属性发生变化时的切换方式。 注意过渡时必须有两个有效数值！在它们之间过渡。auto不能起作用。 要执行过渡的属性：transtion-property:width。多个属性间使用，隔开，若所有属性都需要过渡，用all关键字。 过渡效果持续时间：transtion-duration。 过渡的时序函数：transtion-timing-function。 默认为ease，慢速开始，先加速再减速。 其他可选值：linear,ease-in,ease-in-out。用cubic-bezier()自己指定时序函数，参考本链接。 用steps()分布执行过渡效果。可以设置一个第二个值：end，在时间结束时执行过渡（默认值）; start，在时间开始时执行过渡。 过渡效果的延迟：transtion-delay，等待一段时间后再执行过渡。 动画简写属性：animation。只有一个要求：如果要写 延迟 ，则两个时间中的第一个是持续时间。过渡需要在某个属性发生变化时才会触发。动画可以自动触发。设置动画效果，必须先设置一个 关键帧 ，关键帧设置了动画执行的每一个步骤。 要对当前元素生效的关键帧的名字：animation-name:test 动画持续时间、延时和时序函数类似过渡：animation-duration animation-delay animation-timing-function 动画执行次数：animation-iteration-count 动画运动方向：animation-direction。可选：normal reverse alternate alternate-reverse。 动画执行状态：animation-play-state。可选：running paused 动画填充模式：animation-fill-mode。可选：none，默认值，动画执行完毕元素回到原来位置； forwards，动画执行完毕元素停在结束位置；backwards，动画延时等待时元素处于开始状态；both，结合了forwards和backwards。 关键帧12345678910111213@keyframes test&#123; /* from表示动画的开始位置，也可以使用0% */ from&#123; margin-top: 0; &#125; 25%,to&#123; margin-top: 400px; animation-timing-function: ease-out; &#125; 50%&#123; margin-top: 100px; &#125; /* to表示动画的结束位置，也可以使用100% */ 变形通过CSS改变元素的形状或位置。不会影响到页面布局。变形：transform。指定变形原点：transform-origin：0 0 平移使用translateX(100%)等。百分比是相对于 自身 去算的。之前所说的垂直且水平居中的方法：top:0;bottom:0;left:0;right:0; margin:auto，只适用于元素大小确定的情况；若元素大小是被内容撑开的则不能使用！因为在width、height、margin均为auto的情况下会优先调整宽和高。 利用X、Y轴方向上的平移实现水平/垂直居中，适用于元素大小被内容撑开的情况：水平居中：left:50%; transform:translateX(-50%);水平且垂直居中：left:50%; top:50%; transform:translateX(-50%) translateY(-50%);。 Z轴平移：立体效果（近大远小）。默认情况下网页不支持透视。如果需要看见效果，必须设置网页视距如：perspective：800px。一般在html或body标签的样式中设置。 旋转使用rotateX()使元素沿着x(y z)轴旋转指定的角度。是否显示元素背面：backface-visibility：hidden 缩放使用scaleX()等实现各个方向的缩放。 less事实上，css原生也支持变量的设置和计算函数calc()，但兼容性欠佳。 1234567html&#123; --color:#bfa;&#125;.box&#123; width:calc(400x/2); color:var(--color);&#125; less是一门css的预处理语言。它是css的增强版，通过less可以编写更少的代码实现更强大的样式。在less中添加了很多新特性，如对变量的支持，对mixin的支持，在less中所有的数值都可以直接进行运算… 新版less中，除法运算必须带着单位放在括号内！ 语法大体上和css一致，但增加了许多对css的扩展。所以浏览器无法直接执行less代码，要执行必须将less转化为css，然后再由浏览器执行。在vscode中，需要安装插件：easy less。 用//对less进行单行注释，这种注释方法中的内容不会被解析到css中。用/* */也可以对less进行注释，内容会被解析到css文件中。 可以通过在less文件开头@import &quot;demo.less&quot;引入其他外部less文件，方便模块化开发。 语法变量：语法为@变量名。变量发生重名时优先使用比较近的变量。 12345678910111213@a:200px;@b:box2;// 作为类名或一部分值使用时必须以 @&#123;变量名&#125; 的形式使用.@&#123;b&#125;&#123; // 直接使用以 @变量名 的形式使用 width:@a;&#125;div&#123; width:300px; height:$width;&#125; 父元素： 1234567891011121314.box1&#123; &gt;.box3&#123; color:blue; // &amp; 表示的是外层的父元素box3 &amp;:hover&#123; color:yellow; &#125; &#125; // &amp; 表示的是外层的父元素box1。 div &amp;&#123; width:300px; &#125;&#125; 扩展：:extend()。对当前选择器扩展指定选择器的样式（选择器分组） 1234567.p1&#123; width:100px; height:200px;&#125;.p2:extend(.p1)&#123; color:red;&#125; 功能类似的还有混合函数。 1234567891011121314151617181920212223242526// 也可以直接引用指定的样式，相当于将p1的样式在这复制。// mixin混合.p3&#123; .p1();&#125;// 使用类选择器时可以在选择器后边添加括号，这就创建了一个mixins。再引用的时候可以省略括号。.p4()&#123; width:100px;&#125;.p5&#123; .p4;&#125;// 在混合函数中可以直接设置变量，也可以给变量设置默认值。设置默认值再引用可以不用全指定值。.test(@w,@h,@bg-color)&#123; width:@w; height:@h; border:1px solid @bg-color;&#125;div&#123; // 调用混合函数，按顺序或按名字传递参数 .test(200px,300px,#red) // 或 .test(@bg-color:red,@h:100px;@w:300px)&#125; 媒体查询语法：@media 查询规则&#123;&#125;。 媒体类型 all：所有设备 print：打印设备 screen：带屏幕的设备 speech：屏幕阅读器 媒体特性 width、height：视口宽度、视口高度 min-width、max-width：视口大于/小于指定宽度时生效 样式切换的分界点称为断点，也就是网页样式会在这个点发生变化。 常用断点 小于768：超小屏幕，max-width=768px 大于768：小屏幕，min-width=768px 大于992：中型屏幕，min-width=992px 大于1200:大屏幕，min-width=1200px 可以在媒体类型前添加only，表示只有。only的使用主要是为了兼容一些老版本浏览器。使用逗号连接多个媒体类型，表示它们之间是 或 的关系。如@media print,screen&#123;&#125;；使用and连接多个媒体类型，表示它们之间是 且 的关系。在选择器前加not，表示“除了”，如@media not only screen and (min-width:768px)&#123;&#125;。一个较为完整的写法如下： 12345678910111213@media only screen and (min-width:768px) and (max-width:992px)&#123; body&#123; background-color: #red; &#125;&#125;// 或@media only screen &#123; @media (min-width:768px) and (max-width:992px)&#123; // 注意media后面要空格 body&#123; background-color: #red; &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"Vue笔记","slug":"Vue笔记","date":"2022-01-08T14:33:40.000Z","updated":"2022-01-08T14:33:40.000Z","comments":true,"path":"2022/01/08/Vue笔记/","link":"","permalink":"https://avalooooooon.github.io/2022/01/08/Vue%E7%AC%94%E8%AE%B0/","excerpt":"","text":"vscode插件：Vue 3 snippetsChrome插件：Vue.js devtools浏览器强制刷新：shift + 刷新按钮 简介Vue是一套用于构建用户界面的渐进式JS框架，渐进指Vue可以根据应用的复杂程度自底向上逐层的应用，对于简单应用它只需要一个轻量小巧的核心库，对于复杂应用则可以引入各式各样的Vue插件。它有以下特点： 采用组件化模式，提高代码复用率且更好维护。 声明式编码，让编码人员直接操作dom，提高开发效率。 使用虚拟dom+优秀的diff算法，尽量复用dom节点。 安装不使用cli在官网下载Vue.js和Vue.min.js，分别是开发版和生产版。在html文件head标签内指定路径，引入Vue.js：&lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt;。通过代码Vue.config.productionTip = false调整配置，以阻止 vue 在启动时生成生产提示。其它js代码应该都写在这句话之后。 使用cli环境：Windows101.安装node和npm环境 2.安装脚手架vue-cli 123npm install webpack -gnpm install --global vue-clivue -V 其中webpack是一个包管理工具，也是vue-cli的构建工具。上述命令可以完成webpack的全局安装。如果用nvs工具，可以在C:\\Program Files\\nodejs\\node_global中查看全局安装的vue-cli。 3.构建工程文件cd到工具区。在工作区中vue init webpack testproj以生成webpack脚手架。回车后可能会出现一些提示问题： 项目名称（注意名称中不要出现大写字母，否则会报错） 项目描述（可写可不写，看个人需要） 作者（可写可不写，看个人需要） vue编译，这个选默认即可，运行加编译Runtime + Compiler 是否安装vue-router是否安装vue路由工具 是否使用代码管理工具ESLint管理你的代码 后面几个是测试的工具，需要自己自行了解 可以选择在testproj工程新建好后系统自动进行初始化，安装package.json中描述的依赖。初始化完成后，cd进入项目文件夹。npm run dev运行项目。运行完成后打开浏览器，输入http://localhost:8080/ ，看到Welcome to Your Vue.js APP页面就可以说明项目脚手架已经初始化完成。 若出现报错&#39;webpack-dev-server&#39; 不是内部或外部命令，也不是可运行的程序或批处理文件，运行npm install webpack-dev-server --save-dev即可解决。 Vue核心12345678910111213141516171819202122232425&lt;body&gt; &lt;!-- 准备一个容器 --&gt; &lt;div id=&quot;demo&quot;&gt; &lt;h1&gt;hello,&#123;&#123;name.toUpperCase()&#125;&#125;&lt;/h1&gt; &lt;a v-bind:href=&quot;school.url&quot;&gt;百度一下&lt;/a&gt; &lt;/div&gt; &lt;script&gt; Vue.config.productionTip = false // 阻止 vue 在启动时生成生产提示 // 创建Vue实例 const vm = new Vue(&#123; // el指定当前Vue实例为哪个容器服务。建立实例和容器的关系。 // 值通常为CSS选择器字符串，也可以写作： // el: document.getElementById(&#x27;root&#x27;), el: &#x27;#demo&#x27;, data: &#123; // data中用于存储数据，数据供el所指定的容器去使用 name: &#x27;Bob&#x27;, school: &#123; url: &#x27;http://www.baidu.com&#x27; &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; el的两种写法 new Vue时配置el属性 el: &#39;#root&#39;, 创建完Vue实例后再通过v.$mount(&#39;#root&#39;);指定el的值，mount有“挂载”之意 data的两种写法 对象式data: &#123;name:&#39;Bob&#39;&#125; 函数式 data() &#123; return&#123;name:&#39;Bob&#39;&#125; &#125;。在使用组件时必须使用函数式。 由Vue管理的函数一定 不要写箭头函数 ！ 否则this将不再是Vue实例。 初识Vue 想让Vue工作，就必须创建一个Vue实例（new Vue(&#123;&#125;))，且需要传入一个配置对象（el:&#39;#root&#39;,data:&#123;name:&#39;bob&#39;&#125;）。 root容器内的代码依然符合html规范，只不过会混入一些特殊语法（如双括号&#123;&#123; &#125;&#125;。容器的两个作用：1.作Vue模版。2.让Vue知道把工作成果放在何处。 root容器内的代码被称为Vue 模版 。 模版的解析流程为，先有容器，再有Vue实例，实例工作时读到行el:&#39;#root&#39;，就会把容器拿过来并进行解析，扫描有没有自己的特殊语法，如果有则作相应的替换。解析完后放回页面，替换掉刚才的整个容器。也就是模版经过解析后变成目标html片段。 data中的数据发生任何变化，Vue都会把模版重新解析一遍，模版里调用的方法也会重新调用一遍。 Vue实例和容器必须一一对应。 真实开发中只有一个Vue实例，并且会配合组件一起使用。 MVVM模型MVVM(Model-view-viewmode)，简称vm，是一种软件架构模式，M指模型（model），对应data中的数据；V指视图（View），即模版（页面）；VM指视图模型，对应Vue实例对象（new Vue(&#123;&#125;)）。下图中的两个箭头分别表示监听DOM和数据绑定，即把数据放到指定位置。在文档中经常使用vm这个变量名表示Vue实例。 data中所有的属性最后都会出现在vm身上。（数据代理） vm身上所有的属性，Vue原型身上所有的属性，在Vue模版中都可以直接使用。 数据代理 方法**Object.defineproperty()**：第一个参数-给哪个对象添加属性；第二个参数-要添加的属性叫什么名字；第三个属性-配置项 123456789101112131415161718192021let number = 18;let person = &#123; name:&#x27;bob&#x27;,&#125;Object.defineProperty(person, &#x27;age&#x27;, &#123; // value: 18, // enumerable: true, // 控制属性是否可以枚举，默认值是false // writeble: true, // 控制属性是否可以被修改，默认值是false // confugurable: true, // 控制属性是否可以被删除，默认值是false // 当读取person的age属性时，get函数(getter)就会被调用且返回值是age的值 get: function hihi() &#123; return number; &#125;, // 当修改person的age属性时，set函数(setter)就会被调用且会收到修改的值 set(value) &#123; number = value; &#125;&#125;)console.log(person); 数据代理：通过一个对象代理另一个对象中属性的操作（读/写），好处是可以更加方便的操作data中的数据（否则就得&#123;&#123;_data.age&#125;&#125;。vm.data其实就是我们写的那个data。也可以在构造Vue实例前定义一个对象data，再将这个data给vm：const vm = new Vue(&#123;el: &#39;#demo&#39;,data&#125;)。此时vm._data = options.data = data，options就是new Vue时传入的配置对象。）。图中橙色和紫色的双箭头就是数据代理，每条线都既利用了get也利用了set。以name为例，它通过getter读取到data（.data）里的name，在修改vm里的name时通过setter也会将data（.data）里的name进行修改。.data里的内容是数据劫持的后果。数据代理的基本原理：通过Object.defineproperty()把data对象中所有属性添加到vm上，再为每个添加到vm上的属性都指定一个getter/setter，在getter/setter内部去操作（读/写)data中对应的属性， 模版语法 插值语法：用于解析标签体内容（标签体内使用）写法为&#123;&#123;xxx&#125;&#125;。xxx为js表达式，可直接读到data中的所有属性。注意插值插的是函数返回值时，需要加括号：&#123;&#123;fullName()&#125;&#125;。 指令语法：用于解析标签（标签属性、标签体内容、绑定事件等）都是以v-开头，有v-bind、v-model、v-on等。 数据绑定：分为单向绑定和双向绑定单向绑定：v-bind:href=&quot;xxx&quot;，数据只能从data流向页面。它可以简写为:href=&quot;xxx&quot;。xxx也要是js表达式，且可以直接读取到js中的所有属性。双向绑定：v-model:value=&quot;name&quot;，数据能从页面和data间双向流动，一般都应用在表单类元素中。它可以简写为v-model=&quot;name&quot;，因为v-model默认收集的就是value值。 事件处理 使用v-on:xxx（简写为@xxx，xxx为事件名）绑定事件，如v-on:click=&quot;showInfo&quot; 配合new Vue(&#123;methods:&#123;showInfo() alert(&#39;hell0&#39;)&#125;&#125;)。 绑定事件的时候”@xxx=”的后面可以加一些简单的语句，如@click=&quot;istrue = !istrue;x++&quot;。 事件的回调需要配置在methods对象中，最终会在vm上。 注意methods中配置的函数 不要用箭头函数！ 否则this就不是vm了。methods中配置的函数都是被Vue管理的函数，函数里this的指向是vm或组件实例对象。 @click=”demo”和@click=”demo($event)”效果一致，但后者可以传参。$event表示参数传入了event对象，如果使用前者但定义函数时传入了一个或多个参数，会自动给第一个参数复制为event其它为undefined。 事件修饰符 prevent：阻止默认事件（常用） stop：阻止事件冒泡（常用） once：事件只触发一次（常用） capture：使用事件的捕获模式 self：只有event.target是当前操作的元素时才触发事件 passive：事件的默认行为立即执行，无需等待事件回调执行完毕，移动端使用较多语法形如@click.prevent=&quot;showInfo&quot;。修饰符也可以连续写，@click.prevent.stop=&quot;showInfo&quot;意为先阻止默认行为再阻止冒泡。 键盘事件有@keyup和@keydown，前者更常用。在@keyup=&quot;showInfo&quot;中的函数showInfo里使用e.target.value或e.key可以获取按下的健名，使用e.keyCode可以获取按键的编码。通过语法@keyup.enter使用按键别名，事件在具有该别名的按键抬起时才会触发。 Vue提供的常用的按键别名：回车——enter，删除——delete（捕获“删除”和“退格”键），退出——esc，空格——space，换行——tab，上——up，下——down，左——left，右——right。 注意tab键本身有切换光标焦点的功能，使用 @keyup.tab达不到预期的效果，tab必须用keydown使用。 Vue未提供别名的按键可以使用按键原始的key值绑定（通过e.key获取），但注意要转为kebab-case（短横线命名，如e.key获取到的名字是CapsLock，需要写为caps-lock。） 系统修饰键（用法特殊）：ctrl、alt、shift、meta（win的徽标，mac的command） 配合keyup使用：按下修饰键的同时，再按下其他任意键随后释放该键，事件才被触发。 配合keydown使用：正常触发事件。 也适用于更强的要求，如按下ctrl+a才会触发事件：@keyup.ctrl.a。. （不推荐）可以使用keyCode去指定具体的按键，如@keydown.13。 通过Vue.config.keyCodes.自定义键名 = 键码，可以去定制按键别名 计算属性何为属性？Vue认为data里的东西就是属性，有属性名和属性值。计算属性就是要用的属性不存在，需要拿已有属性（Vue管理的属性才可以，不能是随便一个变量）去加工/计算并生成一个全新的属性。底层原理是借助了Object.defineproperty方法提供的getter和setter。优势是与methods实现相比内部多了一个缓存机制（复用），效率更高且调试方便。计算属性最终会出现在vm上，直接调用即可；且如果计算属性需要被修改（vm.sum=’张+三’ ），就必须写set函数响应修改，且set函数中需要引起计算时依赖的数据发生改变。计算属性不能放到data里，而需要放到另一个配置项computed里，并把计算过程放入一个 对象 ： 12345678910111213141516new Vue(&#123; el:&#x27;#root&#x27;, data:&#123;a:3,b:2&#125;, computed:&#123; sum:&#123; get()&#123; return this.a + &#x27;-&#x27; + this.b; &#125;， set(value)&#123; const arr = value.split(&#x27;-&#x27;); this.a = arr[0]; this.b = arr[1]; &#125; &#125; &#125;&#125;) 计算属性对象中get()函数的作用：当有人读取sum时就会被调用，且返回值作为sum的值。get()什么时候调用？1. 初次读取sum的值时。2.所依赖的数据（a或b）发生变化时。set()什么时候调用？sum的值被修改时。 当计算属性确定只有getter而没有setter时即只有读取需求，没修改需求时可以用简写属性。即不用写作配置对象，而是写作函数，此时函数就相当于getter： 123456// 简写属性computed:&#123; sum()&#123; return this.a + &#x27;-&#x27; + this.b; &#125;&#125; 监视和计算属性语法类似。 1234567891011// 监视属性watch:&#123; istrue:&#123; // handler:当istrue发生改变时调用 handler(newValue,oldValue)&#123; console.log(&#x27;istrue被修改了&#x27;,newValue,oldValue) &#125; // 初始化时让handler调用一下 immediate:true, &#125; &#125; class与style绑定条件渲染列表渲染收集表单数据Vue实例生命周期过渡&amp;动画过滤器内置指令与自定义指令自定义插件Vue组件化使用Vue-cliVue中的ajaxVuexVue-routerVue UI组件库","categories":[],"tags":[]},{"title":"gcc配置C++环境（Mingw-w64）","slug":"gcc配置C-环境（Mingw-w64）","date":"2022-01-06T11:13:53.000Z","updated":"2022-01-06T11:13:53.000Z","comments":true,"path":"2022/01/06/gcc配置C-环境（Mingw-w64）/","link":"","permalink":"https://avalooooooon.github.io/2022/01/06/gcc%E9%85%8D%E7%BD%AEC-%E7%8E%AF%E5%A2%83%EF%BC%88Mingw-w64%EF%BC%89/","excerpt":"","text":"官方文档 VS Code下 cmake 配置C++环境（windows） 下载 Mingw-w64下载MinGW-w64 - for 32 and 64 bit Windows。往下翻一翻，选择最新版本的x86_64-posix-seh。 解压下载下来的压缩包即可。这里我的解压路径为C: \\mingw64。 配置环境变量进入控制面板-&gt;系统和安全-&gt;系统-&gt;高级系统设置-&gt;环境变量，在系统变量的PATH中添加C:\\mingw64\\bin，保存；接下来cmd中以管理员身份运行gcc -v，验证是否配置好环境变量。 在VS Code中配置这一部分最好参考官方文档：使用Mingw-w64。 创建工作区比如在C盘创建一个空文件夹VSCode-C，然后在该文件夹下面再新建空文件夹“workspace”作为工作区，用于存放各种代码。再在workspace文件夹下创建一个test项目和它的配置文件“.vscode”。 安装扩展 C / C ++ IntelliSense配置按Ctrl + Shift + P打开命令面板，键入“ C / C ++”，从建议列表中选择“ 编辑配置（UI）”（Edit Configurations（UI））。VS Code会将在此处进行的更改写入c_cpp_properties.json.vscode文件夹中的文件中。主要修改的是配置集、编译器路径和IntelliSense模式。 C / C ++ IntelliSense配置 写入之后，可以看到 .vscode下添加了c_cpp_properties.json文件，然后按照官方给出的配置进行拷贝就可以了。 12345678910111213141516171819&#123; &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;Win32&quot;, &quot;includePath&quot;: [], &quot;defines&quot;: [ &quot;_DEBUG&quot;, &quot;UNICODE&quot;, &quot;_UNICODE&quot; ], &quot;windowsSdkVersion&quot;: &quot;10.0.17763.0&quot;, &quot;compilerPath&quot;: &quot;C:/mingw64/bin/g++.exe&quot;,//根据个人安装位置修改 &quot;cStandard&quot;: &quot;c17&quot;, &quot;cppStandard&quot;: &quot;c++17&quot;, &quot;intelliSenseMode&quot;: &quot;$&#123;default&#125;&quot; &#125; ], &quot;version&quot;: 4&#125; 创建tasks.json创建构建任务，即创建一个tasks.json文件来告诉VS Code如何构建（编译）程序。该任务将调用g ++编译器以基于源代码创建可执行文件。 任务：配置默认生成任务”（Configure Default Build Task)。在下拉列表中，选择```使用模板创建Tasks.json文件```，然后选择```Others```。VS Code创建一个最小tasks.json文件，并在编辑器中将其打开。1234567891011121314151617181920212223使用以下代码片段替换整个文件内容：```json&#123; &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ &#123; &quot;label&quot;: &quot;build hello world&quot;,//这里可以随意命名 &quot;type&quot;: &quot;shell&quot;, &quot;command&quot;: &quot;g++&quot;, &quot;args&quot;: [ &quot;-g&quot;, &quot;-o&quot;, &quot;HelloWorld&quot;, &quot;HelloWorld.cpp&quot; ], &quot;group&quot;: &#123; &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true &#125; &#125; ]&#125; 配置调试设置配置VS Code以在按F5键时启动GCC调试器（gdb.exe）。首次调试.cpp代码时，会弹出选择环境的下拉菜单。选择GDB / LLDB环境。选择“g++.exe-生成和调试活动文件”。vs code会自动打开launch.json文件。 123456789101112131415161718192021222324252627282930&#123; // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;g++.exe - 生成和调试活动文件&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;C:/VS-Code-C/workspace/HelloWorld/HelloWorld.exe&quot;,//按照个人工作区名字配置 &quot;args&quot;: [], &quot;stopAtEntry&quot;: true, //&quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;, &quot;cwd&quot;: &quot;C:/mingw64/bin&quot;, &quot;environment&quot;: [], &quot;externalConsole&quot;: true, &quot;MIMode&quot;: &quot;gdb&quot;, &quot;miDebuggerPath&quot;: &quot;C:\\\\mingw64\\\\bin\\\\gdb.exe&quot;,//按照个人路径配置 &quot;setupCommands&quot;: [ &#123; &quot;description&quot;: &quot;为gdb启用整齐打印&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true &#125; ], &quot;preLaunchTask&quot;: &quot;C/C++: g++.exe 生成活动文件&quot; &#125; ] &#125; VS Code现在已配置为使用Mingw-w64。该配置适用于当前工作空间。要重用配置，只需将三个JSON文件复制到新工作区中的.vscode子文件夹，然后根据需要更改源文件和可执行文件的名称。 运行HelloWorld.cpp运行结束后，打开工作区，可以看到新生成了一些文件： 如果你在workspace下再次创建一个Hello文件夹，并在它下面写c++文件，会导致程序无法运行，因为我们配置的工作区为workspace，而在其下面的文件夹里的文件无法生成.exe文件，导致程序 运行报错[errror]Id returned 1 exit status。因此我们最好在workspace下直接创建c++文件。","categories":[],"tags":[]},{"title":"node版本管理（macOS和windows）","slug":"node版本管理（macOS）","date":"2021-12-26T07:53:53.000Z","updated":"2021-12-26T07:53:53.000Z","comments":true,"path":"2021/12/26/node版本管理（macOS）/","link":"","permalink":"https://avalooooooon.github.io/2021/12/26/node%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%EF%BC%88macOS%EF%BC%89/","excerpt":"","text":"安装的npm全局模块不会在各个版本的node.js之间共享。还有可能有些npm包不支持当前使用的node版本 不要使用单数的node版本！ macOS：使用 n 版本管理工具检查node及npm环境12node -vnpm -v 安装node版本管理模块n12sudo npm i -g n n -V 安装和切换node版本可能要求权限，在命令前加sudo即可。 1234567891011121314# 列出所有node版本n ls # 安装某个版本n xx.xx.x (版本号)# 切换node版本(通过上下键盘加回车选择)n# 删除某个版本n rm xx.xx.x# 使用某个版本来运行脚本n use xx.xx.x a.js Windows/macOS：使用 nvs 版本管理工具安装nvs nvs的设置参考官方说明 在nvs/releases 下载最新版本的 nvs.msi，双击安装。添加环境变量： 1NVS_HOME=%LOCALAPPDATA%\\nvs 下面是一些基本命令。 12345678# 初始化并使用 NVSnvs install # 从 profile 和 environment 中移除 NVSnvs uninstall # 展示 NVS 版本nvs --version 如果想要把lts设置为系统默认的node版本： 1nvs link lts 注意，nvs use 是改变当前shell窗口的node版本，不是全局环境（nvm的区别）；nvs link是改变全局环境的node版本。 配置镜像地址国内需要把对应的镜像地址修改为淘宝的镜像地址。 12nvs remote node https://npm.taobao.org/mirrors/node/nvs remote nvs remote命令允许配置多个命名的下载位置。NVS 分别管理来自不同远程位置的版本，因此没有版本冲突的风险。默认情况下，只有一个远程指向 Node.js 官方版本： 123$ nvs remotedefault nodenode https://npm.taobao.org/mirrors/node/ 这样就可以从其他来源获得构建。以下命令为 nightly 添加了一个远程 remote，列出了 nightly ，并添加了一个构建： 12345$ nvs remote add nightly https://nodejs.org/download/nightly/$ nvs lsr nightly/13nightly/13.1.1-nightly20191120c7c566023f...$ nvs add nightly/13 安装和切换node版本12345678910111213141516171819# 展示本地的Node.js列表nvs ls [filter] # 切换Node版本nvs use node/[version]/x64# 更新当前环境的 Node.js 至最新版本nvs upgrade [fromver]# 列出可下载的 Node.js 版本nvs ls-remote [filter]nvs lsr [filter]# 下载某个版本的 Node.jsnvs add [version] # 移除某个版本的 Node.jsnvs rm &lt;version&gt; 根据目录自动切换版本在 Bash 或 PowerShell 中，NVS 可以在更改目录时自动切换当前 Shell 中的 Node.js 版本。默认情况下，此功能处于禁用状态。使它运行nvs auto on。之后，无论何时cd或pushd在包含.node-version或.nvmrc文件的目录下，NVS 都会相应地自动切换 Node.js 版本，并在必要时下载新版本。当您cd到达目录上方没有目录.node-version或.nvmrc文件的目录时，将还原默认（链接）版本（如果有）。 Windows 命令提示符中不提供此功能。请用 PowerShell。 1234567891011~$ nvs link 6.9.1~/.nvs/default -&gt; ~/.nvs/node/6.9.1/x64~$ nvs usePATH += ~/.nvs/default/bin~$ nvs auto on~$ cd myprojectPATH -= ~/.nvs/default/binPATH += ~/.nvs/node/4.6.1/x64/bin~/myproject$ cd ..PATH -= ~/.nvs/node/4.6.1/x64/binPATH += ~/.nvs/default/bin 如果您的外壳与自动切换不兼容，或者您 ​​ 希望手动切换但仍利用其中的任何一个.node-versionor.nvmrc文件，则可以nvs use auto使用该版本运行，也可以直接运行nvs auto。 1nvs use auto 或 nvs auto VS Code 支持nvs 这部分参考官方说明 VS Code可以使用 NVS 选择启动或调试时要使用的 Node.js 版本。在launch.json（位于项目根目录的.vscode文件夹中）添加一个“runtimeArgs”属性，该属性包含一个NVS可识别的版本字符串，以及一个“runtimeExecutable”属性，该属性指向nvs.cmd（Windows）或nvs（Mac, Linux）。对于多平台开发，可以为每个平台自定义配置。如果 NVS 不在 VS Code 的 PATH 环境变量中，则可能需要指定一个绝对路径，例如”${env:HOME}/.nvs/nvs”)配置示例：配置launch.json，以便VS Code使用NVS启动节点版本6.10： 12345678910111213&quot;configurations&quot;: [ &#123; &quot;type&quot;: &quot;node&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;name&quot;: &quot;Launch Program&quot;, &quot;program&quot;: &quot;$&#123;file&#125;&quot;, &quot;args&quot;: [ ], &quot;runtimeArgs&quot;: [ &quot;6.10&quot; ], &quot;windows&quot;: &#123; &quot;runtimeExecutable&quot;: &quot;nvs.cmd&quot; &#125;, &quot;osx&quot;: &#123; &quot;runtimeExecutable&quot;: &quot;nvs&quot; &#125;, &quot;linux&quot;: &#123; &quot;runtimeExecutable&quot;: &quot;nvs&quot; &#125; &#125;,] “runtimeArgs”中的NVS版本字符串值由完整或部分语义版本号或版本标签（“lts”、“latest”、“Argon”等）组成，可选前跟远程名称，可选后跟处理器架构或位数（“x86”、“x64”、“32”、“64”），用斜杠分隔。当部分版本与多个可用版本匹配时，会自动选择最新版本。示例：“节点/lts”、“4.6.0”、“6/x86”、“节点/6.7/x64”。NVS别名也可以代替版本字符串。 或者”runtimeArgs”中的版本字符串可能会被省略（相当于“auto”），在这种情况下，NVS搜索项目目录或父目录中最近的.node-version文件。如果找到，则下载（如有必要）并启动文件中指定的版本。如果没有找到.node-version文件，则将启动默认（链接）版本（如果有的话）。 当不将自动模式与.node-version文件一起使用时，launch.json中指定的节点版本必须已经使用nvs add命令下载。否则，启动将失败，NVS打印错误信息“未找到指定版本”。 有关更多详细信息，请参见NVS VS Code文档。或者执行命令nvs help vscode。 Windows：使用 nvm 版本管理工具查看nvm版本1nvm version 安装和切换node版本1234567891011121314151617# 列出所有node版本。* 代表当前版本。末尾输入 available 显示可供下载的所有版本列表。nvm list [available]# 安装某个版本。version：版本号 例如 8.9.0 或者 latest（最新稳定版）,[arch]可选、指定是否安装32位或64位版本（默认为系统架构），将[arch]设置为 all 安装32和64位版本。nvm install &lt;version&gt; [arch]# 切换node版本。可选[arch]32和64位版本nvm use &lt;version&gt; [arch]# 卸载指定的node版本nvm uninstall &lt;version&gt;# 设置nvm存放不同版本的node.js的目录。 如果没有设置 path ，则显示当前的根目录nvm root &lt;path&gt;# 设置node是以32还是64位模式运行。 指定32或64来覆盖默认操作系统版本。nvm arch [32|64]","categories":[],"tags":[{"name":"node","slug":"node","permalink":"https://avalooooooon.github.io/tags/node/"}]},{"title":"gitbook使用教程","slug":"gitbook使用教程","date":"2021-12-26T06:39:24.000Z","updated":"2021-12-27T04:34:54.000Z","comments":true,"path":"2021/12/26/gitbook使用教程/","link":"","permalink":"https://avalooooooon.github.io/2021/12/26/gitbook%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","excerpt":"","text":"参考了这篇文章 检查node环境1node -v 安装gitbook环境安装gitbook-cli工具gitbook-cli是一个在同一系统上安装和使用多个版本的GitBook的实用程序。它将自动安装所需版本的GitBook来构建一本书。打开终端输入npm install gitbook-cli -g进行全局安装： 12npm install gitbook-cli -g gitbook --version 可能遇到的问题:TypeError: cb.apply is not a function解决方案：降低node版本。10.xx.xx是可行的。 Gitbook使用初始化一本书（笔记文件夹）在想要的位置创建一个项目目录，cd到该目录，执行 1gitbook init 可以看到该目录下出现了README.md和SUMMARY.md两个文件。 编辑目录如果SUMMARY.md文件有已经编辑好的目录，gitbook init时会根据目录内容创建文件。下面是SUMMARY.md的一个实例： 12345678* [Introduction](README.md)* [第一章](part1/README.md) * [1.1](part1/1.md) * [1.2](part1/2.md) * [1.2.1](part1/2/1.md)* [第二章](part2/README.md) * [2.1](part2/1.md)* [第三章](part3/README.md) 它生成的文件结构如下： 写笔记根据喜好选择编辑器即可。 启动gitbook服务1gitbook serve 启动服务后，项目文件夹中会生成一个_book文件夹，此文件夹就是最终生成的项目。 生成电子书浏览器打开地址” http://localhost:4000&quot;即可预览。 部署到github首先在项目中创建一个.gitignore文件（和README.md、SUMMARY.md）同级，内容如下： 12# 忽略gitbook生成的项目目录_book 此外，由于gitbook生成的项目跟文档的源码是两个部分，所以可以把文档放到master分支上，部署的网站放到gh-pages 分支。 在github上创建一个仓库自行创建即可。 本地项目提交到github仓库12345git initgit add .git commit -m # 初始化gitbook本地项目&#x27;git remote add origin &lt;git仓库地址&gt;git push -u origin main # 推送到远程仓库的main分支 生成项目并上传到github仓库的gh-pages分支由于打包命令太多，为了简单化，现在写一个脚本命令来自动执行。当然你也可以终端自己执行这些命令。 为了部署方便，可以创建一个脚本文件deploy.sh,内容如下： 123456789101112131415161718192021222324252627282930#!/usr/bin/env shecho &#x27;开始执行命令&#x27;# 生成静态文件echo &#x27;执行命令：gitbook build .&#x27;gitbook build .# 进入生成的文件夹echo &quot;执行命令：cd ./_book\\n&quot;cd ./_book# 初始化一个仓库，仅仅是做了一个初始化的操作，项目里的文件还没有被跟踪echo &quot;执行命令：git init\\n&quot;git init# 保存所有的修改echo &quot;执行命令：git add -A&quot;git add -A# 把修改的文件提交echo &quot;执行命令：commit -m &#x27;deploy&#x27;&quot;git commit -m &#x27;deploy&#x27;# 如果发布到 https://&lt;USERNAME&gt;.github.io/&lt;REPO&gt;echo &quot;执行命令：git push -f git@github.com:Avalooooooon/ING_leetcode_2201.git head:gh-pages&quot;git push -f git@github.com:Avalooooooon/ING_leetcode_2201.git head:gh-pages# 返回到上一次的工作目录echo &quot;回到刚才工作目录&quot;cd - 注意脚本文件代码中仓库地址要替换成你自己的地址。文件保存后，在终端执行如下命令，把生成的项目推送到github仓库上的gh-pages分支： 123bash deploy.sh # macos# windows中，确保已经安装了git工具后直接双击deploy.sh即可运行 执行成功后，打开你的github仓库，然后选择branch分支，会发现多了一个gh-pages分支，打开这个分之后，里面会有一个index.html文件。说明部署的代码上传成功了。注意：如果没有gh-pages分支说明没有部署成功请查看刚才执行的终端看哪里报错了，解决报错直到成功部署。 配置GitHub Pages显示网站在github网站上的仓库里面点击Settings -&gt; GitHub Pages选项中 -&gt; Source里面选择gh-pages branch 然后点击Save按钮，然后在GitHub Pages下面就会看见一个网址，这个网址就是最终的网站。 gitbook多终端使用需要一台已经配置好gitbook环境且有完整gitbook文件夹的终端作为条件。在另一台设备上，git clone仓库的master分支，运行deploy.sh文件。 在Windows端，如果出现报错”Error:ENOENT:no such file or directory, stat ‘C:\\Users\\Lenovo\\www\\mdspg\\md\\mybook_book\\gitbook\\gitbook-plugin-fontsettings\\fontsettings.js’”，在C:\\Users\\username.gitbook\\versions\\3.2.3\\lib\\output\\website\\copyPluginAssets.js，将confirm:true全部替换为confirm:false。共两处。 多终端发布不论是在哪台终端，修改了书籍文件后按下列步骤进行操作： git pull origin main，先pull完成本地与远端的融合 修改书籍内容 git add - A ，添加本地所有文件到仓库 git commit -m 修改说明，提交修改； git push origin main，更新至main分支； 运行deploy.sh文件，生成项目并上传到github仓库的gh-pages分支； gitbook serve，启动gitbook服务。启动服务后，项目文件夹中会生成一个_book文件夹，此文件夹就是最终生成的项目。 gitbook的配置文件讲解如果想对你的网站有更详细的个性化配置或使用插件，那么需要使用配置文件。配置文件写完后，需要重启服务或者重新打包才能应用配置。gitbook的配置文件名是book.json，首先在项目的根目录中创建book.json文件。book.json主要内容： 123456789101112131415161718192021222324252627282930313233&#123; &quot;title&quot;: &quot;我的一本书&quot;, &quot;author&quot; : &quot;yu&quot;, &quot;description&quot; : &quot;我第一本书的描述，很好&quot;, &quot;language&quot; : &quot;zh-hans&quot;, &quot;structure&quot;: &#123; &quot;readme&quot;: &quot;introduction.md&quot; &#125;, &quot;plugins&quot;: [ &quot;-lunr&quot;, &quot;-search&quot;, &quot;search-pro&quot;, &quot;back-to-top-button&quot; ], &quot;pluginsConfig&quot;: &#123; &quot;anchor-navigation-ex&quot;: &#123; &quot;isShowTocTitleIcon&quot;: true &#125; &#125;, &quot;links&quot; : &#123; &quot;sidebar&quot; : &#123; &quot;个性链接1&quot; : &quot;https://www.baidu.com&quot;, &quot;个性链接2&quot; : &quot;https://www.baidu.com&quot; &#125; &#125;, &quot;styles&quot;: &#123; &quot;website&quot;: &quot;styles/website.css&quot;, &quot;ebook&quot;: &quot;styles/ebook.css&quot;, &quot;pdf&quot;: &quot;styles/pdf.css&quot;, &quot;mobi&quot;: &quot;styles/mobi.css&quot;, &quot;epub&quot;: &quot;styles/epub.css&quot; &#125;&#125; book.json中一些主要参数说明 title：标题 author：作者 description：描述，对应gitbook网站的description language：使用的语言，zh-hans是简体中文，会对应到页面的&lt;html lang=”zh-hans” &gt; structure：指定 Readme、Summary、Glossary 和 Languages 对应的文件名，下面是这几个文件对应变量以及默认值： Variable Description structure.readme Readme file name (defaults to README.md) structure.summary Summary file name (defaults to SUMMARY.md) structure.glossary Glossary file name (defaults to GLOSSARY.md) structure.languages Languages file name (defaults to LANGS.md) 比如想把readme文件换个名字，则可以使用如下配置 123&quot;structure&quot;: &#123; &quot;readme&quot;: &quot;introduction.md&quot;&#125;, 使用这个配置后，gitbook服务就不会找readme文件，而去找introduction文件当项目说明，这样就可以把readme文件完全当成代码仓库说明文档了。 plugins：使用的插件列表，所有的插件都在这里写出来，然后使用gitbook install来安装。 pluginsConfig：插件的配置信息，如果插件需要配置参数，那么在这里填写。 links：目前可以给侧导航栏添加链接信息12345&quot;links&quot; : &#123; &quot;sidebar&quot; : &#123; &quot;个性链接1&quot; : &quot;https://www.baidu.com&quot; &#125;&#125; styles：自定义页面样式，各种格式对应各自的css文件1234567&quot;styles&quot;: &#123; &quot;website&quot;: &quot;styles/website.css&quot;, &quot;ebook&quot;: &quot;styles/ebook.css&quot;, &quot;pdf&quot;: &quot;styles/pdf.css&quot;, &quot;mobi&quot;: &quot;styles/mobi.css&quot;, &quot;epub&quot;: &quot;styles/epub.css&quot;&#125; 配置默认主题默认的主题可以通过配置来做一下效果。比如侧边栏菜单显示标题数字，可以在配置文件的pluginsConfig参数中写入如下字段： 1234567&#123; &quot;pluginsConfig&quot;: &#123; &quot;theme-default&quot;: &#123; &quot;showLevel&quot;: true &#125; &#125;&#125; 效果如图： gitbook的一些实用插件 gitbook插件可以解决一些网站不太方便的地方，如侧边栏导航不能收缩，自带搜索不支持中文等。用了插件书籍网站会更灵活和美观。 由于插件很多，请参考另一篇文章：https://segmentfault.com/a/1190000019806829","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://avalooooooon.github.io/tags/git/"}]},{"title":"git笔记","slug":"git笔记","date":"2021-12-20T07:40:59.000Z","updated":"2021-12-20T07:40:59.000Z","comments":true,"path":"2021/12/20/git笔记/","link":"","permalink":"https://avalooooooon.github.io/2021/12/20/git%E7%AC%94%E8%AE%B0/","excerpt":"","text":"查看完整教程：Git-scm 查看版本/日志123# 项目所在目录git log：查看提交日志（查看版本号）git log git reflog # 查看版本号 不传入任何参数的默认情况下，git log 会按时间先后顺序列出所有的提交，最近的更新排在最上面。git log 有许多选项可以帮助你搜寻你所要找的提交，下面是最常用的几个： -p 或 ``–patch` ：显示每次提交所引入的差异（按补丁的格式输出） -&lt;n&gt; :仅显示最近的 n 条提交。 --since 和 --until ：按照时间作限制。12# 列出最近两周的所有提交$ git log --since=2.weeks 该命令可用的格式十分丰富——可以是类似 &quot;2008-01-15&quot; 的具体的某一天，也可以是类似 &quot;2 years 1 day 3 minutes ago&quot; 的相对日期。 --author : 指定作者 --grep : 搜索提交说明中的关键字 --stat：显示每次提交的简略统计信息。--stat 选项在每次提交的下面列出所有被修改过的文件、有多少文件被修改了以及被修改过的文件的哪些行被移除或是添加了。 在每次提交的最后还有一个总结。 --pretty：使用不同于默认格式的方式展示提交历史。 这个选项有一些内建的子选项供你使用。 比如 oneline 会将每个提交放在一行显示，在浏览大量的提交时非常有用。 当 oneline 或 format 与另一个 log 选项 --graph 结合使用时尤其有用。 这个选项添加了一些 ASCII 字符串来形象地展示你的分支、合并历史。 另外还有 short，full 和 fuller 选项，它们展示信息的格式基本一致，但是详尽程度不一。 format ：可以定制记录的显示格式。 这样的输出对后期提取分析格外有用——因为你知道输出的格式不会随着 Git 的更新而发生改变： 1234$ git log --pretty=format:&quot;%h - %an, %ar : %s&quot;ca82a6d - Scott Chacon, 6 years ago : changed the version number085bb3b - Scott Chacon, 6 years ago : removed unnecessary testa11bef0 - Scott Chacon, 6 years ago : first commit git log --pretty=format 常用的选项 列出了 format 接受的常用格式占位符的写法及其代表的意义。 更详细的选项说明可以参考git log 的常用选项 。 文件文件状态1234# 查看当前分支、分支同远程分支的比较、哪些文件处于什么状态git status# 开始跟踪一个文件/将一个文件放到暂存区、git add 文件名 未跟踪的文件意味着 Git 在之前的快照（提交）中没有这些文件；Git 不会自动将之纳入跟踪范围，除非你明明白白地告诉它“我需要跟踪该文件”。 这样的处理让你不必担心将生成的二进制文件或其它不想被跟踪的文件包含进来。 git add 是个多功能命令：可以用它开始跟踪新文件，也可以用它把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。 将这个命令理解为“精确地将内容添加到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。 注意！运行了 git add 之后又作了修订的文件，需要重新运行 git add 把最新版本重新暂存起来。 如果想缩短状态命令的输出： 12git status -s git status --short 新添加的未跟踪文件前面有 ?? 标记，新添加到暂存区中的文件前面有 A 标记，修改过的文件前面有 M 标记。 输出中有两栏，左栏指明了暂存区的状态，右栏指明了工作区的状态。 示例： 123456$ git status -sM READMEMM RakefileA lib/git.rbM lib/simplegit.rb?? LICENSE.txt README 文件在工作区已修改但尚未暂存，而 lib/simplegit.rb 文件已修改且已暂存。 Rakefile文件已修，暂存后又作了修改，因此该文件的修改中既有已暂存的部分，又有未暂存的部分。 文件的忽略总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下可以创建一个名为 .gitignore 的文件，列出要忽略的文件的模式。 123$ cat .gitignore*.[oa]*~ 第一行告诉 Git 忽略所有以 .o 或 .a 结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的。 第二行告诉 Git 忽略所有名字以波浪符（~）结尾的文件，许多文本编辑软件（比如 Emacs）都用这样的文件名保存副本。 此外，你可能还需要忽略 log，tmp 或者 pid 目录，以及自动生成的文档等等。 要养成一开始就为你的新仓库设置好 .gitignore 文件的习惯，以免将来误提交这类无用的文件。 文件 .gitignore 的格式规范如下： 所有空行或者以 # 开头的行都会被 Git 忽略。 可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。 匹配模式可以以（/）开头防止递归。 匹配模式可以以（/）结尾指定目录。 要忽略指定模式以外的文件或目录，可以在模式前加上叹号（!）取反。 所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。 星号（*）匹配零个或多个任意字符；[abc]匹配任何一个列在方括号中的字符 （这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）； 问号（?）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符， 表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。 使用两个星号（**）表示匹配任意中间目录，比如 a/**/z 可以匹配 a/z 、 a/b/z 或 a/b/c/z 等。 再看一个 .gitignore 文件的例子： 123456789101112# 忽略所有的 .a 文件*.a# 但跟踪所有的 lib.a，即便你在前面忽略了 .a 文件!lib.a# 只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO/TODO# 忽略任何目录下名为 build 的文件夹build/# 忽略 doc/notes.txt，但不忽略 doc/server/arch.txtdoc/*.txt# 忽略 doc/ 目录及其所有子目录下的 .pdf 文件doc/**/*.pdf 仓库将尚未进行版本控制的本地目录转换为 Git 仓库先cd到该项目目录，然后 1git init 该命令将创建一个名为 .git 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。 但是，在这个时候，我们仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪。 请记住，工作目录下的每一个文件都不外乎这两种状态：已跟踪 或 未跟踪。 已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后， 它们的状态可能是未修改，已修改或已放入暂存区。简而言之，已跟踪的文件就是 Git 已经知道的文件。其它所有文件都属于未跟踪文件。 编辑过某些文件之后，由于自上次提交后你对它们做了修改，Git 将它们标记为已修改文件。 在工作时可以选择性地将这些修改过的文件放入暂存区，然后提交所有已暂存的修改，如此反复。 如果在一个已存在文件的文件夹（而非空文件夹）中进行版本控制，你应该开始追踪这些文件并进行初始提交。 可以通过 git add 命令来指定所需的文件来进行追踪，然后执行 git commit ： 123git add *.cgit add LICENSEgit commit -m &#x27;initial project version&#x27; 从其它服务器克隆一个已存在的 Git 仓库Git 克隆的是该 Git 仓库服务器上的几乎所有数据，而不是仅仅复制完成你的工作所需要文件。 当你执行 git clone 命令的时候，默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来。克隆仓库的命令是 git clone 。 比如，要克隆 Git 的链接库 libgit2，可以用下面的命令： 1git clone https://github.com/libgit2/libgit2 这会在当前目录下创建一个名为 “libgit2” 的目录，并在这个目录下初始化一个 .git 文件夹， 从远程仓库拉取下所有数据放入 .git 文件夹，然后从中读取最新版本的文件的拷贝。 1git clone https://github.com/libgit2/libgit2 mylibgit 这会执行与上一条命令相同的操作，但目标目录名变为了 mylibgit。也就是在克隆远程仓库的时候，自定义了本地仓库的名字。 远程仓库1234567891011121314# 查看你已经配置的远程仓库服务器git remote# 指定选项 -v：显示需要读写远程仓库使用的Git保存的简写与其对应的URLgit remote -v# 添加远程仓库，同时指定一个方便使用的简写&lt;shortname&gt;git remote add &lt;shortname&gt; &lt;url&gt;# 查看某个远程仓库。同样会列出远程仓库的 URL 与跟踪分支的信息。git remote show &lt;remote&gt;# 修改一个远程仓库的简写名。这同样也会修改你所有远程跟踪的分支名字。git remote rename# 移除一个远程仓库git remote remove # 或git remote rm。一旦你使用这种方式删除了一个远程仓库，那么所有和这个远程仓库相关的远程跟踪分支以及配置信息也会一起被删除。 origin ——这是 Git 给你克隆的仓库服务器的默认名字。如果使用 clone 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。 拉取、抓取与推送抓取——fetch12# 从远程仓库中获得数据git fetch &lt;remote&gt; 这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。 必须注意 git fetch 命令只会将数据下载到你的本地仓库——它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。 拉取——pull如果你的当前分支设置了==跟踪远程分支==，那么可以用 git pull命令来自动抓取后合并该远程分支到当前分支。 这或许是个更加简单舒服的工作流程。默认情况下，git clone 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（或其它名字的默认分支）。 运行 git pull 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。 推送——push1git push &lt;remote&gt; &lt;branch&gt; 只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先抓取他们的工作并将其合并进你的工作后才能推送。 此外，如果直接使用git push origin xxx,“error: 源引用表达式xxx没有匹配”的问题会在关联的代码库远程分支名称与本地（当前）分支的名称不同时出现。如果不相同，就要用git push origin head:xxx，或者git push origin &lt;当前的本地分支名&gt;:xxx提交代码。 分支概述1234567891011# 查看所有分支及当前所在分支【* 表示当前】git branch# 查看每一个分支的最后一次提交git branch -v# 查看哪些分支已经合并到当前分支。 在这个列表中分支名字前没有 * 号的分支通常可以使用 git branch -d 删除掉，因为已经将它们的工作整合到了另一个分支，所以不会失去任何东西。git branch --merged# 查看所有包含未合并工作的分支。因为它包含了还未合并的工作，尝试使用 git branch -d 命令删除它时会失败。可以使用 -D 选项强制删除它。git branch --no-merged# 例如，尚未合并到 master 分支的有哪些？git branch --no-merged master Git怎么知道当前在哪一个分支上呢？ 很简单，它有一个名为 HEAD 的特殊指针指向当前所在的本地分支（译注：将 HEAD 想象为当前分支的别名）。HEAD 分支随着提交操作自动向前移动。 12345678910111213# 创建一个新的分支。这会在当前所在的提交对象上创建一个指针。# git branch 命令仅仅创建 一个新分支，并不会自动切换到新分支中去。git branch xxx # 创建一个新分支后立即切换过去git checkout -b &lt;newbranchname&gt;# 从当前分支切换到某个分支。HEAD指向切换之后的分支。git checkout xxx # 查看各个分支当前所指的提交对象git log --oneline --decorate# 查看提交历史、各个分支的指向以及项目的分支分叉情况git log --oneline --decorate --graph --all 分支切换会改变你工作目录中的文件!!git 会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。如果 Git 不能干净利落地完成这个任务，它将禁止切换分支。 要留意你的工作目录和暂存区里那些还没有被提交的修改。最好的方法是，在你切换分支之前，保持好一个干净的状态。 12# 删除某个分支【慎重操作】 注意当前不能在iii分支上,跳出之后,再删除git branch -d iii 合并分支——fast-forward当你试图合并两个分支时， 如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候， 只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”。 合并分支——merge当两个将要合并的分支各自有不同的父提交时发生。比如下面的例子，要合并master和iss53分支：你的开发历史从一个更早的地方开始分叉开来（diverged）。 因为，master 分支所在提交并不是 iss53 分支所在提交的直接祖先，Git 不得不做一些额外的工作。 出现这种情况的时候，Git 会使用两个分支的末端所指的快照（C4 和 C5）以及这两个分支的公共祖先（C2)，做一个简单的三方合并。和之前将分支指针向前推进所不同的是，Git 将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它。 合并分支——rebaserebase（变基） 命令将提交到某一分支上的所有修改都移至另一分支上。考虑之前提到的merge。开发任务分叉到两个不同分支，又各自提交了更新：Merge会把两个分支的最新快照（C3 和 C4）以及二者最近的共同祖先（C2）进行三方合并，合并的结果是生成一个新的快照（并提交)：其实，还有一种方法：你可以提取在 C4 中引入的补丁和修改，然后在 C3 的基础上应用一次。 在这个例子中，你可以检出 experiment 分支，然后将它变基到 master 分支上： 12git checkout experimentgit rebase master 这种操作就叫做 **变基（rebase)**。它的原理是首先找到这两个分支（即当前分支 experiment、变基操作的目标基底分支 master） 的最近共同祖先 C2，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件， 然后将当前分支指向目标基底 C3, 最后以此将之前另存为临时文件的修改依序应用。 （译注：写明了 commit id，以便理解，下同)现在回到 master 分支，进行一次快进合并: 12git checkout mastergit merge experiment 此时，C4&#39; 指向的快照就和merge中 C5 指向的快照一模一样了。 这两种整合方法的最终结果没有任何区别，但是变基使得提交历史更加整洁。 你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的， 但它们看上去就像是串行的一样，提交历史是一条直线没有分叉。 请注意，无论是通过变基，还是通过三方合并，整合的最终结果所指向的快照始终是一样的，只不过提交历史不同罢了。 变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。 如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基。 总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史， 从不对已推送至别处的提交执行变基操作， 合并分支——冲突如果在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。Git 会暂停下来，等待你去解决合并产生的冲突。 你可以在合并冲突后的任意时刻使用 git status 命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件。任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。 Git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。 12# 启动一个合适的可视化合并工具，并带领你一步一步解决这些冲突git mergetool 等你退出合并工具之后，Git 会询问刚才的合并是否成功。 如果回答“是”，Git 会暂存那些文件以表明冲突已解决。可以再次运行 git status 来确认所有的合并冲突都已被解决。 合并分支——提交1git commit 关于分支的几个常见场景：1.在新的分支上面常规开发【一般是dev分支】 123456# 在确保当前分支是上一步git checkout过来的即可【不放心的话可以git branch 确认下】git add .git commit -m &quot;yyyy&quot;git pull #注意在多人协作push之前,一定先pull下,养成良好的习惯,避免和被人提交的代码冲突,硬合并而照成代码事故】git push # 【再上一步，pull之后如无冲突，即可提交代码】git status #【查看当前工作空间状态】 2.将次分支和并到主分支上【一般是dev分支合并到主分支master上】【dev分支开发完毕,合并到master分支,并推送上线】 12345git checkout dev # 切到dev次分支】git pull #【获取dev分支变化,合并冲突,使本地dev次分支最新】git checkout master #【先切到主分支master上】git merge dev #【一般是git merge dev,将dev开发完的合并到master上】git push -u origin master #【提交master分支到线上master】 3.将主分支和并到次分支上【一般是主分支master合并到dev分支上】【master分支有变动，需要更新开发分支dev上的代码】 12345git checkout master #【切到主分支】git pull #【获取主分支变化,合并冲突,使本地主分支最新】git checkout dev #【先切到次分支dev上】git merge master #【一般是git merge master,将master开发完的合并到dev上】git push -u origin dev #【提交dev分支到线上dev】 版本回退针对部分文件的撤销操作1.有时提交完了才发现漏掉了几个文件没有添加，或提交信息写错了。 可以运行带有 --amend 选项的提交命令来重新提交： 1$ git commit --amend 这个命令会将暂存区中的文件提交。 如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令）， 那么快照会保持不变，而你所修改的只是提交信息。文本编辑器启动后，可以看到之前的提交信息。 编辑后保存会覆盖原来的提交信息，也即用一个新的提交替换旧的提交。 2.取消暂存的文件 1git reset HEAD 要取消暂存的文件名 git reset 确实是个危险的命令，如果加上了 --hard 选项则更是如此。 然而在上述场景中，工作目录中的文件尚未修改，因此相对安全一些。 3.撤消对文件的修改 将它还原成上次提交时的样子（或者刚克隆完的样子，或者刚把它放入工作目录时的样子）: 1git checkout -- &lt;file&gt; 请务必记得 git checkout -- &lt;file&gt; 是一个危险的命令。 你对那个文件在本地的任何修改都会消失——Git 会用最近提交的版本覆盖掉它。 除非你确实清楚不想要对那个文件的本地修改了，否则请不要使用这个命令。 针对整个版本的回退操作假设A 和 B 是正常提交， C 和 D 是错误提交，此时HEAD 指针指向 D 提交。现在想把 C 和 D 回退掉。我们只需将 HEAD 指针移动到 B 提交（idCodeB），就可以达到目的。此时回滚目标B的commitid为idCode1，操作如下： 12345678910# 如果保留修改的撤销-&gt;只删掉提交记录：在项目所在目录执行下列操作git reset HEAD~ # 仓库回滚到上一个版本git reset XXX # 仓库回滚到指定版本git reset --soft idCode1 # 仓库回滚到指定版本# 如果把修改记录也干掉：在项目所在目录执行下列操作git reset --hard idCodeBgit reset --hard HEAD^# 如果是提交到远程仓库上，则在远程仓库上同样执行一次相同的命令 然而，由于即使是在本地执行了git reset –hard (B提交的版本号）使得HEAD 指针移动到 B 提交下，但远程仓库的 HEAD 指针依然不变（还在D提交上），故只能使用 -f 选项将提交强制推到远程仓库：git push -f。它会使 HEAD 指针往回移动，从而会失去之后的提交信息。 而git resert则可以既回退代码，又保存错误的提交。(reset和revert的区别详见这篇博客，主要是 revert是生成一次新的commit冲抵原来的commit， reset直接删除某些commit的内容) 12345678910111213# 注意有多个提交需要回退的话，要由新到旧进行 revert，即先D后C。会生成两个新有提交：D’ 和 C’，按A B C D D’ C’的先后顺序依次排列在分支上git revert idCodeDgit revert idCodeCgit revert OLDER_COMMIT^…NEWER_COMMIT # 多个错误提交时批量回退# 回滚最新一次的提交记录：git revert HEAD# 回滚前一次的提交记录：git revert HEAD^# 对历史上的commit回滚git revert # 确认生成的新commit编译成功，也没有文件冲突，可以push到服务器，完成回滚。","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://avalooooooon.github.io/tags/git/"}]},{"title":"Typora使用指南","slug":"Typora使用指南","date":"2021-12-20T06:14:27.000Z","updated":"2021-12-20T06:14:27.000Z","comments":true,"path":"2021/12/20/Typora使用指南/","link":"","permalink":"https://avalooooooon.github.io/2021/12/20/Typora%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","excerpt":"","text":"文章参考网址官方文档 关于Typora主要使用Github制定的GFM标准。可以在文件 - 偏好设置 - Markdown 语法偏好 - 严格模式 中将标准设置为「更严格地遵循 GFM 标准」。 主题美化在 Typora 中 CSS 被称为「主题」，但其本质仍是 CSS 文件。可以在文件 - 偏好设置 - 主题 - 打开主题文件夹看到这些 CSS 文件。也可以自己修改、新建适合使用需求的 CSS 文件。 Typora 自带了若干主题，可以在 官网 下载更多的主题。 常用写作设置通过打开文件 - 偏好设置定制适合自己编辑习惯的设置。 实时预览通过视图 - 源代码模式或左下角的 &lt;/&gt; 按钮或用快捷键command+ /(Mac)进入源代码模式（Source Mode）。 打字机模式&amp;专注模式在视图 - 专注模式 / 打字机模式中勾选使用这两个模式。「打字机模式」使得你所编辑的那一行永远处于屏幕正中。「专注模式」使你正在编辑的那一行保留颜色，而其他行的字体呈灰色。 智能标点可以自动将不是很美观的直引号 “ ‘ 转化为更美观的弯引号 “ ‘ ’ ”。详情见官方文档。 换行在 Markdown 语法中，换行（line break）与换段是不同的。且换行分为软换行和硬换行。 软换行：在 Typora 中可以通过Shift + Enter完成一次软换行。软换行只在编辑界面可见，当文档被导出时换行会被省略。硬换行：通过空格 + 空格 + Shift + Enter完成一次硬换行，或直接插入HTML标签&lt;br/&gt;。这也是许多 Markdown 编辑器所原生支持的。硬换行在文档被导出时将被保留，且没有换段的段后距。 换段：通过 Enter 完成一次换段。Typora 会自动帮你完成两次 Shift + Enter 的软换行，从而完成一次换段。这也意味着在 Markdown 语法下，换段是通过在段与段之间加入空行来实现的。 Windows 风格（CR+LF）与 Unix 风格（CR）的换行符CR 表示回车 \\r,即回到一行的开头，而 LF 表示换行\\n ,即另起一行。所以 Windows 风格的换行符本质是「回车 + 换行」，而 Unix 风格的换行符是「换行」。这也是为什么 Unix / Mac 系统下的文件，如果在 Windows 系统直接打开会全部在同一行内。 可以在文件 - 偏好设置 - 编辑器 - 默认换行符中对此进行切换。 表格插入不需要按传统的md语法要求的操作，只需要在行内鼠标右键 - 插入 - 表格(注意不能在源代码模式下操作），并输入行数和列数，Typora 就会自动生成一张样式不错的空表格。 图片插入Markdown 原生不太注重图片插入的功能，但可以在 Typora 中： 直接使用右键 - 复制+ Ctrl + V将网络图片、剪贴板图片复制到文档中。 拖动本地图片到文档中 Typora 会自动帮你插入符合 Markdown 语法的图片语句，并给它加上标题。你也完全可以使用图床来保证文档在分享后图片仍能正常显示。 更强大的是，Typora 支持在拖动或 Ctrl + V 网络图片后自动将其保存到本地。可以在文件 - 偏好设置 - 编辑器 - 图片插入中选择复制到哪个路径，什么情况下需要复制。 空格已经把设置改了，现在导出也会保留连续空格。输入连续空格后，会在编辑器视图里保留这些空格，但打印或导出时，这些空格会被省略成一个。在源代码模式下，为每个空格前加一个 \\ 转义符，或者直接使用 HTML 风格的 &amp;nbsp;(No-Break Space) 来保持连续的空格。 表情插入emoji：用:emoji:的形式打出。 链接引用和脚注链接引用类似于我们常在论文末尾看到的「参考文献」的写法，你可以通过[]: 的语法来为你的文档加上链接引用。 脚注即某段话结尾右上角标有数字标记，页面底部进行注释的写法。你可以在需要插入脚注标号的位置写 [^ number ] ，再在下方通过 [^ number ]: 在文档中插入脚注。 注意: 不要遗漏了脚注编号 number 前后的空格 ! 示例[^ 这是一个脚注 ][^ 这是一个脚注 ][^ 这是一个脚注 ]:脚注内容 YAML front-matterTypora 支持在文档头部加上基于 YAML 的 front-matter 信息，这一特性适用于把 Markdown 文档分类归档上传到用 Hexo 框架搭建的博客中。 LaTeXTypora 原生支持 LaTeX 语法，有两种方式输入 LaTeX 风格的数学公式：行内公式（inline）：用$…$ 括起公式，公式会出现在行内。块间公式（display）：用$$…$$ 括起公式（注意 $$ 后需要换行），公式会默认显示在行中间。 其它使用范例typora 画流程图、时序图(顺序图)、甘特图1、横向流程图源码格式：横向流程图 123456graph LRA[方形] --&gt;B(圆角) B --&gt; C&#123;条件a&#125; C --&gt;|a=1| D[结果1] C --&gt;|a=2| E[结果2] F[横向流程图] 2、竖向流程图源码格式： 竖向流程图 123456graph TDA[方形] --&gt; B(圆角) B --&gt; C&#123;条件a&#125; C --&gt; |a=1| D[结果1] C --&gt; |a=2| E[结果2] F[竖向流程图] 3、标准流程图源码格式：标准流程图 123456789st=&gt;start: 开始框op=&gt;operation: 处理框cond=&gt;condition: 判断框(是或否?)sub1=&gt;subroutine: 子流程io=&gt;inputoutput: 输入输出框e=&gt;end: 结束框st-&gt;op-&gt;condcond(yes)-&gt;io-&gt;econd(no)-&gt;sub1(right)-&gt;op 4、标准流程图源码格式（横向）：横向标准流程图 123456789st=&gt;start: 开始框op=&gt;operation: 处理框cond=&gt;condition: 判断框(是或否?)sub1=&gt;subroutine: 子流程io=&gt;inputoutput: 输入输出框e=&gt;end: 结束框st(right)-&gt;op(right)-&gt;condcond(yes)-&gt;io(bottom)-&gt;econd(no)-&gt;sub1(right)-&gt;op 5、UML时序图源码样例：UML时序图 12345对象A-&gt;对象B: 对象B你好吗?（请求）Note right of 对象B: 对象B的描述Note left of 对象A: 对象A的描述(提示)对象B--&gt;对象A: 我很好(响应)对象A-&gt;对象B: 你真的好吗？ 6、UML时序图源码复杂样例：复杂UML 1234567891011Title: 标题：复杂使用对象A-&gt;对象B: 对象B你好吗?（请求）Note right of 对象B: 对象B的描述Note left of 对象A: 对象A的描述(提示)对象B--&gt;对象A: 我很好(响应)对象B-&gt;小三: 你好吗小三--&gt;&gt;对象A: 对象B找我了对象A-&gt;对象B: 你真的好吗？Note over 小三,对象B: 我们是朋友participant CNote right of C: 没人陪我玩 7、UML标准时序图样例：标准UML 123456789101112%% 时序图例子,-&gt; 直线，--&gt;虚线，-&gt;&gt;实线箭头 sequenceDiagram participant 张三 participant 李四 张三-&gt;王五: 王五你好吗？ loop 健康检查 王五-&gt;王五: 与疾病战斗 end Note right of 王五: 合理 食物 &lt;br/&gt;看医生... 李四--&gt;&gt;张三: 很好! 王五-&gt;李四: 你怎么样? 李四--&gt;王五: 很好! 8、甘特图样例：甘特图 12345678910111213141516171819%% 语法示例 gantt dateFormat YYYY-MM-DD title 软件开发甘特图 section 设计 需求 :done, des1, 2014-01-06,2014-01-08 原型 :active, des2, 2014-01-09, 3d UI设计 : des3, after des2, 5d 未来任务 : des4, after des3, 5d section 开发 学习准备理解需求 :crit, done, 2014-01-06,24h 设计框架 :crit, done, after des2, 2d 开发 :crit, active, 3d 未来任务 :crit, 5d 耍 :2d section 测试 功能测试 :active, a1, after des3, 3d 压力测试 :after a1 , 20h 测试报告 : 48h","categories":[],"tags":[]},{"title":"Markdown笔记","slug":"Markdown笔记","date":"2021-12-20T06:12:19.000Z","updated":"2021-12-20T06:12:19.000Z","comments":true,"path":"2021/12/20/Markdown笔记/","link":"","permalink":"https://avalooooooon.github.io/2021/12/20/Markdown%E7%AC%94%E8%AE%B0/","excerpt":"","text":"typora快捷键 标题#一级标题：## 二级标题### 三级标题#### 四级标题 段落在 Markdown 语法中，换行（line break）与换段是不同的。且换行分为软换行和硬换行。换行：两个以上空格加回车，或直接插入HTML标签&lt;br/&gt; 软换行：在 Typora 中可以通过 Shift + Enter 完成一次软换行。软换行只在编辑界面可见，当文档被导出时换行会被省略。硬换行：通过 空格 + 空格 + Shift + Enter 完成一次硬换行，或直接插入HTML标签&lt;br/&gt;。这也是许多 Markdown 编辑器所原生支持的。硬换行在文档被导出时将被保留，且没有换段的段后距。 换段：通过在段与段之间加入空行来实现。在段落后面使用一个空行来表示重新开始一个段落。 分隔线：在一行中用三个以上的星号、减号、下划线来建立一个分隔线，行内不能有其他东西。效果如下： 在星号或是减号中间插入空格没有影响。下面每种写法都可以建立分隔线：***---___* * * 文本~~要删除的文字~~: 要删除的文字&lt;u&gt;带下划线文本&lt;/u&gt;: 带下划线文本**演示粗体**: 演示粗体*演示斜体* : 演示斜体 脚注：创建脚注格式为： 主段落[^ 脚注01 ] [^ 脚注01 ]: 这是脚注内容。效果如下： 主段落^ 脚注01 。 代码段内插入代码片段`代码内容` ，效果为 代码内容 整段插入代码片段1. 用一对``` 包裹一段代码，并指定一种语言（也可以不指定）：``` pythonprint``` 1print 2. 用段落前缩进(4 个空格或者一个制表符（Tab ）)的方式显示代码块。注意代码要在一个新段开始，否则无法正确显示为代码格式。 区块引用在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号。一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推：&gt; 区块引用&gt;&gt; 第一层嵌套&gt;&gt;&gt; 第二层嵌套&gt; 这个位置，这样是无效的 区块引用 第一层嵌套 第二层嵌套这个位置，尝试用一个&gt;是无效的 在列表内添加区块需要在 &gt; 前添加四个空格的缩进。 列表无序列表使用*、+或-作为列表标记，这些标记后面要添加一个空格，然后再填写内容：+ 第一项+ 第二项 显示为： 第一项 第二项 有序列表使用数字并加上 . 号来表示：1. 第一项2. 第二项3. 第三项 显示为： 第一项 第二项 第三项 列表嵌套只需在子列表中的选项前面添加四个空格即可1. 第一项： - 第一项嵌套的第一个元素 - 第一项嵌套的第二个元素 显示为： 第一项： 第一项嵌套的第一个元素 第一项嵌套的第二个元素 链接和图片插入链接[链接名称](链接地址)或者&lt;链接地址&gt;链接名称或者https://avalooooooon.github.io/index 高级链接: 可以通过变量来设置一个链接，变量赋值在文档末尾进行：这个链接用 1 作为网址变量 [Google][1]: Google这个链接用avalon作为网址变量[mygithub][avalon]: mygithub然后在文档的结尾为变量赋值（网址） 插入图片可以是本地图片也可以是网络图片。格式：![alt 属性文本](图片地址 “可选标题”) Markdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 &lt;img&gt; 标签&lt;img src=”图片链接” width=”50%”&gt; 表格表格格式使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行| First Header | Second Header || ————- | ————- || Content Cell | Content Cell || Content Cell | Content Cell | First Header Second Header Content Cell Content Cell Content Cell Content Cell 对齐方式可以设置表格的对齐方式：-: 设置内容和标题栏居右对齐。:- 设置内容和标题栏居左对齐。:-: 设置内容和标题栏居中对齐。实例如下：| 左对齐 | 右对齐 | 居中对齐 || :—–| —-: | :—-: || 单元格 | 单元格 | 单元格 || 单元格 | 单元格 | 单元格 | 左对齐 右对齐 居中对齐 单元格 单元格 单元格 单元格 单元格 单元格 公式使用两个美元符$$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如：显示效果为：$$\\mathbf{V}_1 \\times \\mathbf{V}_2 = \\begin{vmatrix}\\mathbf{i} &amp; \\mathbf{j} &amp; \\mathbf{k} \\\\frac{\\partial X}{\\partial u} &amp; \\frac{\\partial Y}{\\partial u} &amp; 0 \\\\frac{\\partial X}{\\partial v} &amp; \\frac{\\partial Y}{\\partial v} &amp; 0 \\\\end{vmatrix}${$tep1}{\\style{visibility:hidden}{(x+1)(x+1)}}$$ 转义Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符：文本加粗** 正常显示星号 ** 使用HTML元素不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。目前支持的 HTML 元素有：&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;等 ，如：&lt;kbd&gt;Command&lt;/kbd&gt;+&lt;kbd&gt;C&lt;/kbd&gt; :使用 Command+C 组合键进行复制","categories":[],"tags":[]},{"title":"建站记录","slug":"建站记录","date":"2021-12-19T06:53:04.000Z","updated":"2022-01-08T17:11:29.536Z","comments":true,"path":"2021/12/19/建站记录/","link":"","permalink":"https://avalooooooon.github.io/2021/12/19/%E5%BB%BA%E7%AB%99%E8%AE%B0%E5%BD%95/","excerpt":"","text":"Part1 环境搭建安装nodejs12node -v npm -v #查看版本 安装git1git --version #查看版本 创建博客文件夹并安装hexo自己在想要的位置创建文件夹blog，在该文件夹中新建终端并运行以下命令： 12npm install -g hexo-clihexo -v 在Windows中，如果出现”‘hexo’不是内部或外部命令，也不是可运行的程序”，需要找到电脑中新安装的hexo的位置，并将hexo.cmd所在文件夹的路径添加到系统变量的PATH中。 可能出现的问题运行npm install -g hexo-cli时，可能提示没有权限。这里强烈建议不要用sudo方式强行获得权限。解决方法：第一步，赋予目录权限；第二步，安装hexo: 12sudo chown -R `whoami` /usr/local/lib/node_modules #这里不用改路径npm install hexo-cli -g 至此安装部分已经结束。下面对hexo进行初始化，给自己准备存放hexo主要内容的文件夹取一个名字（比如myblog），运行下列命令： 123hexo init myblogcd myblognpm install 可以看到，myblog目录下出现了：–node_modules: 依赖包–public：存放生成的页面–scaffolds：生成文章的一些模板–source：用来存放你的文章–themes：主题–_config.yml：博客的配置文件 运行下列命令打开hexo的服务，在浏览器输入localhost:4000就可以看到生成的博客了： 12hexo ghexo server 创建Github库并绑定SSH首先在自己的github下new一个和自己注册github时的用户名xxx同名的仓库，后面加.github.io。也就是新仓库的名字叫xxx.github.io。接下来生成SSH。依次运行下列命令： 12345git config --global user.name &quot;yourname&quot; #github用户名git config --global user.email &quot;youremail&quot; #github绑定的邮箱git config user.namegit config user.email #检查一下输对没有ssh-keygen -t rsa -C &quot;youremail&quot; #创建SSH，一路回车 找到～/.ssh文件夹。（Mac显示隐藏文件夹，同时按下三个组合键：Shift + Command + . ）在自己GitHub的setting中找到SSH keys，点击New SSH key。将id_rsa.pub里面的信息全部复制进去并保存。查看是否成功： 1ssh -T git@github.com 将hexo托管到个人Github先安装deploy-git ，也就是部署的命令，这样才能用命令部署到GitHub: 1npm install hexo-deployer-git --save 在myblog文件夹下打开站点配置文件*_config.yml*，翻到最后，修改为 1234deploy: type: git repo: git@github.com:xxx/xxx.github.io.git branch: master 准备就绪后, 123hexo clean #清除了之前生成的东西，也可以不加。hexo g #生成静态文章，hexo generate的缩写hexo d #部署文章，hexo deploy的缩写,,可与hexo g合并为 hexo d -g 过一会儿就可以在http://xxx.github.io 这个网站看到博客了。 写文章使用指令新建一篇文章： 1hexo new [layout] &lt;title&gt; 写完后，运行下列代码以部署更新。 123hexo cleanhexo ghexo d #可与hexo g合并为 hexo d -g 关于[layout]Hexo 有三种默认布局：post、page 和 draft，它们分别对应不同的路径。自己自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹。可以通过 publish 命令将草稿移动到 source/_posts 文件夹： 1hexo publish [layout] &lt;title&gt; 草稿默认是不会显示在页面中的，可在执行时加上 –draft 参数，或是把 render_drafts 参数设为 true来预览草稿。也可以编辑现有的layout，比如post的layout默认是hexo\\scaffolds\\post.md比如想添加categories（文章分类目录），以免每次手工输入，只需要修改这个文件添加一行，如下： 1234title: &#123; &#123; title &#125; &#125; #文章页面上的显示名称，可以任意修改，不会出现在URL中date: &#123; &#123; date &#125; &#125; #文章生成时间，一般不改，当然也可以任意修改categories: #文章分类目录，可以为空tags: #文章标签，可空，多标签请用格式[tag1,tag2,tag3]， 请注意，大括号与大括号之间多加了个空格，否则会被转义，不能正常显示。 注意，所有文件：后面都必须有个空格，不然会报错。 写作时可能用到的插件1.插入图片 12cd blog/myblog # 进入本地博客文件夹npm install https://github.com/CodeFalling/hexo-asset-image --save 接下来打开hexo的配置文件_config.yml，找到 post_asset_folder，把这个选项从false改成true。最后打开/node_modules/hexo-asset-image/index.js，将内容更换为下面的代码（参考了这篇博客)。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&#x27;use strict&#x27;;var cheerio = require(&#x27;cheerio&#x27;);// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) &#123; return str.split(m, i).join(m).length;&#125;var version = String(hexo.version).split(&#x27;.&#x27;);hexo.extend.filter.register(&#x27;after_post_render&#x27;, function(data)&#123; var config = hexo.config; if(config.post_asset_folder)&#123; var link = data.permalink; if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3) var beginPos = getPosition(link, &#x27;/&#x27;, 1) + 1; else var beginPos = getPosition(link, &#x27;/&#x27;, 3) + 1; // In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;. var endPos = link.lastIndexOf(&#x27;/&#x27;) + 1; link = link.substring(beginPos, endPos); var toprocess = [&#x27;excerpt&#x27;, &#x27;more&#x27;, &#x27;content&#x27;]; for(var i = 0; i &lt; toprocess.length; i++)&#123; var key = toprocess[i]; var $ = cheerio.load(data[key], &#123; ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false &#125;); $(&#x27;img&#x27;).each(function()&#123; if ($(this).attr(&#x27;src&#x27;))&#123; // For windows style path, we replace &#x27;\\&#x27; to &#x27;/&#x27;. var src = $(this).attr(&#x27;src&#x27;).replace(&#x27;\\\\&#x27;, &#x27;/&#x27;); if(!/http[s]*.*|\\/\\/.*/.test(src) &amp;&amp; !/^\\s*\\//.test(src)) &#123; // For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed. // In addition, to support multi-level local directory. var linkArray = link.split(&#x27;/&#x27;).filter(function(elem)&#123; return elem != &#x27;&#x27;; &#125;); var srcArray = src.split(&#x27;/&#x27;).filter(function(elem)&#123; return elem != &#x27;&#x27; &amp;&amp; elem != &#x27;.&#x27;; &#125;); if(srcArray.length &gt; 1) srcArray.shift(); src = srcArray.join(&#x27;/&#x27;); $(this).attr(&#x27;src&#x27;, config.root + link + src); console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+config.root + link + src); &#125; &#125;else&#123; console.info&amp;&amp;console.info(&quot;no src attr, skipped...&quot;); console.info&amp;&amp;console.info($(this)); &#125; &#125;); data[key] = $.html(); &#125; &#125;&#125;); 现在就可以插入图片了，比如hexo new post photo之后就在source/_posts生成photo.md文件和photo文件夹，我们把要插入的图片复制到photo文件夹内，在photo.md文件里面按markdown的标准写,（我的文件名是head.jpeg）比如 Part2 基本配置hexo基本配置——_config.yml在文件根目录下的_config.yml，就是整个hexo框架的配置文件了。可以在里面修改大部分的配置。详细可参考官方的配置描述。 网站参数 描述title 网站标题subtitle 网站副标题description 主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。author 用于主题显示文章的作者language 网站使用的语言timezone 网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。 网址参数 描述url 你的网站域名root 网站根目录permalink 文章的永久链接格式permalink_defaults 用于主题显示文章的作者 permalink，也就是你生成某个文章时的那个链接格式。比如我新建一个文章叫temp.md，那么这个时候他自动生成的地址就是http://yoursite.com/2018/09/05/temp。以下是官方给出的示例，关于链接的变量还有很多，需要的可以去官网上查找永久链接 。 参数 描述:year/:month/:day/:title/ 2013/07/14/hello-world:year-:month-:day-:title.html :year-:month-:day-:title.html:category/:title foo/bar/hello-world 再往下翻，中间这些都默认就好了。 12345678theme: landscape # Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: &lt;repository url&gt; branch: [branch] theme：主题名deploy：网站部署。repo就是仓库(Repository)的简写。branch选择仓库的哪个分支。这个在之前进行github page部署的时候已经修改过了，不再赘述。而这个在后面进行双平台部署的时候会再次用到。 Front-matterFront-matter 是文件最上方以 — 分隔的区域，用于指定个别文件的变量，举例来说： 123title: Hello Worlddate: 2013/7/13 20:46:25--- 下面是预先定义的参数，在模板中使用这些参数值并加以利用。参数 描述layout 布局title 标题date 建立日期updated 更新日期comments 开启文章的评论功能tags 标签（不适用于分页）。标签没有顺序和层次。categories 分类（不适用于分页）。具有顺序性和层次性，也就是说 Foo, Bar不等于 Bar, Foo。permalink 覆盖文章网址 Layout使用命令 1hexo new [layout] &lt;title&gt; 它默认使用的是post这个布局，也就是在source文件夹下的_post里面。Hexo 有三种默认布局：post、page 和 draft，它们分别对应不同的路径。自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹。 page如果想另起一页，那么可以使用 1hexo new page board draft如果想写文章，又不希望被看到，那么可以 1hexo new draft newpage 这样会在source/_draft中新建一个newpage.md文件。如果你的草稿文件写的过程中想要预览一下，那么可以使用 1hexo server --draft 在本地端口中开启服务预览。 如果你的草稿文件写完了，想要发表到post中， 1hexo publish draft newpage 就会自动把newpage.md发送到post中。 Part3 个性化官网上的主题们我用的是Volantis。在github下载并放到theme文件夹下，然后根目录下的_config.yml中把theme换成那个主题文件夹的名字，它就会自动在theme文件夹中搜索你配置的主题。volantis官方文档-主题配置进入volantis这个文件夹，可以看到里面也有一个配置文件_config.xml，这个配置文件是修改整个主题的配置文件。主题目录下的 _config.yml 文件通常负责主题相关配置，我们强烈建议您使用代替的主题配置文件以防止自己的配置丢失。如何操作呢–参见volantis官方文档-代替主题配置文件 。（以后补： default info cdn） menu其中，“关于”是找不到网页的，因为文章中没有about这个东西。如果想要的话，可以执行命令 1hexo new page about 它就会在根目录下source文件夹中新建一个about文件夹，以及index.md，在index.md中写上你想要写的东西，就可以在网站上展示出来了。如果你想要自己再自定义一个菜单栏的选项，那么就 1hexo new page yourdiy 然后在主题配置文件的menu菜单栏里按照其他菜单项的格式添加一个，注意把url改了且格式保持整齐（比如有时候直接回车会出错，要删掉多余的空间然后按空格键调整格式）。然后在languages文件夹中，找到zh-CN.yml，在index中添加yourdiy: ‘中文意思’就可以显示中文了。启用搜索功能用到的插件在主题的config.yml文件中，搜索search关键字，可以看到 12# To use hexo search, you need to install the following plugins:# npm i hexo-generator-json-content Part4 hexo附加功能评论系统在主题的config.yml文件中，搜索comment关键字，可以看到一些相关内容。 Part5 git分支进行多终端工作场景：现在在自己的笔记本上写的博客，部署在了网站上。那么在家里或者实验室的台式机，发现电脑里面没有博客的文件，或者要换电脑了，最后不知道怎么移动文件，怎么办？在这里我们就可以利用git的分支系统进行多终端工作了，这样每次打开不一样的电脑，只需要进行简单的配置和在github上把文件同步下来，就可以无缝操作了。 1 原理hexo本地文件夹中的public和.deploy.git文件夹存放的是根据.md生成的html文件，也就是博客的静态文件。对比GitHub上博客仓库的master分支也可以看到该分支的文件结构和这两个文件夹中的文件一致。也就是说，执行hexo d就是把public和.deploy.git文件夹下的文件同步到github。 我们之前在GitHub创建好的仓库默认只有master分支，这个分支存放的是静态文件。所以，可以在该仓库另外创建一个hexo分支以存放Hexo网站文件，这个分支的文件就是不同电脑需要同步的文件。 2 创建新分支在GitHub创建一个新分支hexo。该分支是由master拉取，所以其中的文件一开始和master是一样的。因为我们只需要手动管理Hexo网站文件，故可以把hexo分支设置为默认分支。这样操作后，当每次修改主题或者新增博文后，先将修改的主题文件（在themes文件夹中）或新增的博客（在source文件夹中)同步到远程仓库的hexo分支，然后再通过hexo d -g发布博文，也就是将新增的博文的静态页面同步到master分支，即可实现多台终端的同步管理。 注意！这里应进入username.github.io的settings-&gt;pages，确保是由master分支提交到了博客网站。可能会被系统变为hexo分支。 3 原主机操作：初始化分支在原主机安装了hexo的目录中，该目录包含所有博客文件，进行以下操作： git init，重新初始化仓库，对代码进行版本控制 git add - A， 添加本地所有文件到仓库 git commit -m “提交说明”，添加commit； git branch hexo，添加本地分支hexo git remote add origin &lt;server&gt;，添加远程仓库，&lt;server&gt;是在线仓库的地址 git push origin hexo，将本地仓库的源文件推送到远端hexo；此时博客的源文件就同步到github的hexo分支上了。 注意！如果当前使用的theme是使用git clone下载下来的话，由于git不能嵌套，会导致主题无法push到远程仓库，导致博客出现404页面。这种情况下，若是有自己fork的主题仓库，可以删除themes文件夹中的原主题文件夹，clone自己修改后的主题仓库地址到该文件夹。 4 新主机操作：同步分支在PC2上创建文件夹Blog，在Blog文件夹下面还行以下操作： git clone 仓库地址，把远端仓库的hexo分支clone到本地 cd yourname.github.io，切换到上一步clone的文件夹中 npm install，在clone下来的仓库文件夹中安装所需要的必要组件，不需要再init 5 发布博文后续不管是PC1还是PC2，如果修改了主题或者新增了博文，按照以下步骤即可： git pull origin hexo，先pull完成本地与远端的融合 hexo new post test.md，新建一个.md文件进行测试 git add source ，经测试只要更新source即可，因为只是修改了博客。如果修改的是主题文件，则更新theme文件夹 git commit -m “修改说明”，提交修改； git push origin hexo，更新至hexo分支； hexo d -g，将博文静态页面发布至maser分支。 参考链接原文链接：https://blog.csdn.net/sinat_37781304/article/details/82729029","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://avalooooooon.github.io/tags/hexo/"}]}],"categories":[],"tags":[{"name":"vpn","slug":"vpn","permalink":"https://avalooooooon.github.io/tags/vpn/"},{"name":"node","slug":"node","permalink":"https://avalooooooon.github.io/tags/node/"},{"name":"git","slug":"git","permalink":"https://avalooooooon.github.io/tags/git/"},{"name":"hexo","slug":"hexo","permalink":"https://avalooooooon.github.io/tags/hexo/"}]}